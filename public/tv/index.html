<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta http-equiv="X-Content-Security-Policy" content="default-src 'self'; script-src 'self'" />
  <script src="hls.js"></script>
  <title>Hunhe TV</title>
<style>
html, body {
  width: 100%;
  height: 100%;
}
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0;
  color: #333;
  margin: 0;
  position: relative;
  overflow: hidden;
  align-items: center;
  background: url(background.jpeg) center center / cover no-repeat;
}
  .container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-flow: row;
    align-items: flex-start;
    margin: 0px;
    position: relative;
  }
  .container .video-container {
    flex: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    min-width: 300px;
    width: 100%;
    height: 100%;
  }
    .container .video-container .video-wrapper {
      box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      width: 100%;
      max-height: 100%;
      min-width: 300px;
      height: auto;
      background-color: #333;
      position: relative;
    }
      .container .video-container .video-wrapper #videoPlayer {
        width: 100%;
        max-height: 100%;
        height: auto;
        z-index: 10;
      }
      .container .video-container .video-wrapper #frameVideo {
        width: 100%;
        max-height: 100%;
        height: auto;
        position: absolute;
        z-index: -1;
      }
    .container .video-container .video-control {
      flex: 1;
      align-items: flex-start;
      display: flex;
      column-gap: 1rem;
      justify-content: flex-end;
      width: 100%;
      flex-flow: column;
      row-gap: 0.5rem;
    }
    .container .video-container .video-control #errorControl {
      flex: 1;
    }
    .container .video-container .video-control .controls {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-flow: row;
      column-gap: 1rem;
    }

    .container #pagination {
      display: flex;
      justify-content: space-between;
      align-items: center;
      column-gap: 1rem;
      flex: 0;
      width: 100%;
      margin-top: 14px;
    }

    .container #playlistContainer {
      min-width: 300px;
      width: 100%;
      flex: 1;
      height: 100%;
      display: flex;
      z-index: 10;
    }
    .container #playlistContainer.settings {
      flex: 3;
    }

textarea, #categorySelect, #searchInput, #searchButton, #clearButton, #closeButton, #m3uUrlInput,
#loadM3uButton, #closeM3uButton, #loadContentuButton, #m3uContentKey, #settingsButton {
  width: 100%;
  padding: 12px;
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: 16px;
  -webkit-appearance: none;
  box-sizing: border-box;
}

#searchContainer, #m3uUrlInput, .m3u-controls, #playlistContent .category {
  margin-bottom: 10px;
}

#searchContainer {
  display: flex;
}
  #searchContainer .search {
    position: relative;
    flex: 1;
    display: flex;
  }
  #searchContainer #clearButton {
    position: absolute;
    right: 0px;
    top: 0px;
    background-color: transparent;
    width: auto;
    color: #999;
    flex: 1;
    padding: 0px 0.5rem;
    height: 100%;
    -webkit-appearance: none;
    appearance: none;
    border: 0px solid transparent;
    z-index: 10;
    border-radius: 0px;
  }
  #searchContainer #clearButton svg {
    background-color: white;
  }

#searchInput, #categorySelect {
  flex-grow: 1;
  border-right: none;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

textarea:focus-visible,
input:focus-visible,
select:focus-visible {
  outline: 1px solid #ddd;
}

#searchButton {
  border-radius: 0px;
}

#searchButton, #closeButton, #settingsButton {
  width: auto;
  background-color: #3498db;
  color: white;
  border: none;
  cursor: pointer;
  white-space: nowrap;
}

#settingsButton {
  border-radius: 0px;
  background-color: #39db34;
}

#closeButton, #playlistContent .category #listCheckButton {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
  background-color: #db6634;
}

#playlistItems {
  list-style-type: none;
  padding: 0px;
  margin: 0px;
  display: flex;
  flex-flow: column;
  flex: 1;
  row-gap: 0.3rem;
  justify-content: space-evenly;
  overflow: auto;
}

#playlistItems li {
  cursor: pointer;
  background-position: -100px center;
  background-color: #f1f1f1;
  border-radius: 8px;
  padding: 0.5rem 0.9rem;
  height: 100%;
  min-height: 1rem;
  white-space: nowrap;
  overflow: auto;
  overflow-y: hidden;
  text-overflow: ellipsis;
  display: flex;
  align-items: center;
  scrollbar-width: none;
  border-left: 3px solid gray;
  user-select: none;
  transition: 0.5s all;
  column-gap: 0.5rem;
  border-bottom: 1px solid #eee;
}

  #playlistItems li::-webkit-scrollbar { 
    display: none;
  }
  #playlistItems li.good {
    border-left: 3px solid green;
  }
  #playlistItems li.good:hover {
    border-bottom: 1px solid green;
  }
  #playlistItems li.average {
    border-left: 3px solid orange;
  }
  #playlistItems li.average:hover {
    border-bottom: 1px solid orange;
  }
  #playlistItems li.bad {
    border-left: 3px solid red;
  }
  #playlistItems li.bad:hover {
    border-bottom: 1px solid red;
  }
  #playlistItems li.favorite {
    box-shadow: inset -2px 0 1px 0px gray;
  }
  #playlistItems li.active {
    font-weight: bold;
  }
  #playlistItems li.broken {
    font-style: italic;
    color: #888;
    font-size: small;
    text-indent: 1rem;
  }
  #playlistItems li.frame {
    background: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%23666%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M6.002%205.5a1.5%201.5%200%201%201-3%200%201.5%201.5%200%200%201%203%200%22%2F%3E%3Cpath%20d%3D%22M2.002%201a2%202%200%200%200-2%202v10a2%202%200%200%200%202%202h12a2%202%200%200%200%202-2V3a2%202%200%200%200-2-2zm12%201a1%201%200%200%201%201%201v6.5l-3.777-1.947a.5.5%200%200%200-.577.093l-3.71%203.71-2.66-1.772a.5.5%200%200%200-.63.062L1.002%2012V3a1%201%200%200%201%201-1z%22%2F%3E%3C%2Fsvg%3E') no-repeat 0.5rem center;
    text-indent: 1rem;
  }
  #playlistItems li:nth-of-type(even) {
    background-color: transparent;
  }
  #playlistItems li.frame:nth-of-type(even) {
    background-color: rgba(255, 255, 255, 0.55);
  }
  #playlistItems li.frame:hover,
  #playlistItems li:hover {
    background-color: #e9ecef5c;
  }
  #playlistItems li div {
    width: 100%;
  }

button {
  user-select: none;
  padding: 10px 20px;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  white-space: nowrap;
  display: flex;
  align-items: center;
  justify-content: center;
}

#pagination button, .controls button {
  flex: 1;
}
#pagination button {
  font-size: 16px;
  flex: 0;
  background-color: lightslategrey;
}

#pageInfo {
  font-size: 16px;
  white-space: nowrap;
  width: 100%;
  flex: 0;
  text-align: center;
}

#errorMessage {
  color: #e74c3c;
  text-align: center;
  flex: 1;
  width: 100%;
}

@media (min-width: 768px) {
  #videoPlayer {
    width: 640px;
  }

  #playlistContainer {
    width: 640px;
  }
}

#loadM3uButton {
  background-color: #3498db;
  color: white;
  border: none;
  cursor: pointer;
}

#settingsButton {
  background-color: #606060;
}
#favoriteButton {
  background-color: darkslategrey;
}
  #favoriteButton.remove {
    background-color: #cc2e68;
  }

#playListButton {
  background-color: #2e6bcc;
}
#fullscreenButton {
  background-color: darkslateblue;
}

#playVideoButton {
  background-color: blueviolet;
}
#playVideoButton.playing {
  background-color: darkmagenta;
}
#playVideoButton.played {
  background-color: #e74c3c;
}

#m3uList {
  display: flex;
  column-gap: 1rem;
  flex-flow: column;
}

#m3uList div {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 4px;
}
  #m3uList div.active {
    background-color: #fff;
  }
#m3uList div a {
  cursor: pointer;
  padding: 0.5rem 0.8rem;
  border-radius: 4px;
}
  #m3uList div a:hover {
    background-color: #eee;
  }
  #m3uList div a.load {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 0.9rem;
  }
  #m3uList div a.delete {
    color: #e74c3c;
    opacity: 0.6;
    transition: all 1s;
  }
  #m3uList div a.delete:hover {
    background-color: #fbe3e3;
    opacity: 1;
  }
#m3uContentKey {
  margin-top: 1rem;
}
#m3uContent {
  resize: vertical;
}

#playlistContent {
  display: flex;
  flex-flow: column;
  height: 100%;
}
#playlistContent .category {
  display: flex;
}

#playlistContent .category #listCheckButton {
  background-color: #3471db;
}

.hidden {
  display: none !important;
}
.box {
  display: flex;
  flex-flow: column;
  width: 100%;
  flex: 1;
  position: relative;
  background-color: rgba(237, 237, 237, 0.85);
  border-radius: 0px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  box-sizing: border-box;
  overflow: auto;
  padding: 0.5rem;
  column-gap: 0.6rem;
  row-gap: 0.6rem;
}

.range {
  -webkit-appearance: none;
  width: 100%;
  height: 15px;
  border-radius: 5px;  
  background: #b5b5b5;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

/* Mouse-over effects */
.range:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 25px;
  height: 25px;
  border-radius: 50%; 
  background: #4682b4;
  cursor: pointer;
}

.range::-moz-range-thumb {
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #04AA6D;
  cursor: pointer;
}

.m3u-controls {
  display: flex;
  column-gap: 0.5rem;
  flex-flow: row;
  align-items: center;
  justify-content: flex-end;
}
  .m3u-controls #closeM3uButton {
    background-color: #db6634;
  }
  .m3u-controls #loadM3uButton,
  .m3u-controls #closeM3uButton {
    width: auto;
  }

.page-information {
  flex: 1;
}

.tools {
  display: flex;
  padding: 0.5rem 0.8rem;
  align-items: flex-start;
  justify-content: center;
  flex-flow: column;
}

  .tools #databaseSize {
    border-radius: 4px;
  }
  .tools #databaseCategories {
    display: flex;
    column-gap: 0.5rem;
    justify-content: space-evenly;
    align-items: center;
    width: 100%;
    flex: 1;
  }
  .tools #databaseCategories button {
    flex: 1;
    background-color: darkred;
    font-size: 0.9rem;
  }
.usage {
  row-gap: 0.5rem;
}
button:disabled {
  background-color: #bdc3c7 !important;
  color: #eee;
}

.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 0.5rem 0px;
  column-gap: 1rem;
  border-bottom: 1px solid #777;
  margin-top: -1px;
  border-top: 1px solid #777;
}
.settings-row .label {
  width: 100%;
  flex: 1;
  white-space: nowrap;
  align-items: center;
  display: flex;
  height: 34px;
}
/* The switch - the box around the slider */
.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

/* Hide default HTML checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* The slider */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(26px);
  -ms-transform: translateX(26px);
  transform: translateX(26px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}
.debug #debugLogs {
  border: 1px solid #ccc;
  width: 100%;
  resize: vertical;
  flex: 1;
  white-space: pre-wrap;
}
/* iPhone Portrait */
@media only screen and (max-device-width: 812px) and (orientation: portrait)
{
  .container #playlistContainer {
    position: absolute;
    z-index: 20;
    top: 0px;
    left: 0px;
  }
}
</style>
</head>

<body id="pageBody">
  <svg xmlns="http://www.w3.org/2000/svg" class="hidden">
    <!-- PLAY -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="play" viewBox="0 0 16 16">
      <path d="M10.804 8 5 4.633v6.734zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696z"/>
    </symbol>
    <!-- STOP -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="stop" viewBox="0 0 16 16">
      <path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5"/>
    </symbol>
    <!-- CANCEL -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="cancel" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0M5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293z"/>
    </symbol>
    <!-- FULLSCREEN -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="fullscreen" viewBox="0 0 16 16">
      <path d="M5.5 0a.5.5 0 0 1 .5.5v4A1.5 1.5 0 0 1 4.5 6h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5m5 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 10 4.5v-4a.5.5 0 0 1 .5-.5M0 10.5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 6 11.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5m10 1a1.5 1.5 0 0 1 1.5-1.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0z"/>
    </symbol>
    <!-- REWIND -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="rewind" viewBox="0 0 16 16">
      <path d="M9.196 8 15 4.633v6.734zm-.792-.696a.802.802 0 0 0 0 1.392l6.363 3.692c.52.302 1.233-.043 1.233-.696V4.308c0-.653-.713-.998-1.233-.696z"/>
      <path d="M1.196 8 7 4.633v6.734zm-.792-.696a.802.802 0 0 0 0 1.392l6.363 3.692c.52.302 1.233-.043 1.233-.696V4.308c0-.653-.713-.998-1.233-.696z"/>
    </symbol>
    <!-- FORWARD -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="forward" viewBox="0 0 16 16">
      <path d="M6.804 8 1 4.633v6.734zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C.713 12.69 0 12.345 0 11.692V4.308c0-.653.713-.998 1.233-.696z"/>
      <path d="M14.804 8 9 4.633v6.734zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C8.713 12.69 8 12.345 8 11.692V4.308c0-.653.713-.998 1.233-.696z"/>
    </symbol>
    <!-- SETTINGS - GEAR -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="gear" viewBox="0 0 16 16">
      <path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492M5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0"/>
      <path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52zm-2.633.283c.246-.835 1.428-.835 1.674 0l.094.319a1.873 1.873 0 0 0 2.693 1.115l.291-.16c.764-.415 1.6.42 1.184 1.185l-.159.292a1.873 1.873 0 0 0 1.116 2.692l.318.094c.835.246.835 1.428 0 1.674l-.319.094a1.873 1.873 0 0 0-1.115 2.693l.16.291c.415.764-.42 1.6-1.185 1.184l-.291-.159a1.873 1.873 0 0 0-2.693 1.116l-.094.318c-.246.835-1.428.835-1.674 0l-.094-.319a1.873 1.873 0 0 0-2.692-1.115l-.292.16c-.764.415-1.6-.42-1.184-1.185l.159-.291A1.873 1.873 0 0 0 1.945 8.93l-.319-.094c-.835-.246-.835-1.428 0-1.674l.319-.094A1.873 1.873 0 0 0 3.06 4.377l-.16-.292c-.415-.764.42-1.6 1.185-1.184l.292.159a1.873 1.873 0 0 0 2.692-1.115z"/>
    </symbol>
    <!-- LIST CHECK -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="list-check" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
      <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
    </symbol>
    <!-- FAVORITE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="favorite" viewBox="0 0 16 16">
      <path d="M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.33-.314.16-.888-.282-.95l-4.898-.696L8.465.792a.513.513 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.56.56 0 0 0-.163-.505L1.71 6.745l4.052-.576a.53.53 0 0 0 .393-.288L8 2.223l1.847 3.658a.53.53 0 0 0 .393.288l4.052.575-2.906 2.77a.56.56 0 0 0-.163.506l.694 3.957-3.686-1.894a.5.5 0 0 0-.461 0z"/>
    </symbol>
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="unfavorite" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </symbol>
    <!-- LIST CHECK -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="list" viewBox="0 0 16 16">
        <path d="M12 13c0 1.105-1.12 2-2.5 2S7 14.105 7 13s1.12-2 2.5-2 2.5.895 2.5 2"/>
        <path fill-rule="evenodd" d="M12 3v10h-1V3z"/>
        <path d="M11 2.82a1 1 0 0 1 .804-.98l3-.6A1 1 0 0 1 16 2.22V4l-5 1z"/>
        <path fill-rule="evenodd" d="M0 11.5a.5.5 0 0 1 .5-.5H4a.5.5 0 0 1 0 1H.5a.5.5 0 0 1-.5-.5m0-4A.5.5 0 0 1 .5 7H8a.5.5 0 0 1 0 1H.5a.5.5 0 0 1-.5-.5m0-4A.5.5 0 0 1 .5 3H8a.5.5 0 0 1 0 1H.5a.5.5 0 0 1-.5-.5"/>
    </symbol>
    <!-- CLOSE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="close" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z"/>
    </symbol>
    <!-- SEARCH -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="search" viewBox="0 0 16 16">
      <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
    </symbol>
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="reset" viewBox="0 0 16 16">
      <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708"/>
    </symbol>
  </svg>

  <div class="container" id="pageContainer">
    <div id="playlistContainer" class="hidden">
      <div class="box">
        <div id="m3uInputContainer">
          <input type="url" id="m3uUrlInput" required placeholder="输入 M3U 文件 URL">
          <div class="m3u-controls">
            <button id="loadM3uButton">加载播放列表</button>
            <button id="closeM3uButton"><svg width="20" height="20"><use xlink:href="#close"/></svg></button>
          </div>

          <div id="m3uList"></div>

          <!-- <input type="text" id="m3uContentKey" placeholder="Key" value="Content">
          <textarea id="m3uContent"></textarea>
          <button id="loadContentuButton">读取内容</button> -->

          <div class="tools">
            <div class="settings-row">
              <label class="label">检查缩略图</label>
              <label class="switch">
                <input type="checkbox" id="storeFrameCheckbox">
                <span class="slider"></span>
              </label>
            </div>
            <div class="settings-row">
              <label class="label">检查超时 (<span id="checkTimeoutDisplay">0</span>ms)</label>
              <input type="range" id="checkTimeout" class="range" min="5" max="60" step="1" required />
            </div>
            <div class="settings-row">
              <label class="label">数据使用情况</label>
              <div id="databaseSize"></div>
            </div>
          </div>

          <div class="tools usage">
            <div id="databaseCategories"></div>
          </div>

          <div class="tools debug">
            <div id="debugLogs"></div>
          </div>

        </div>
        <div id="playlistContent">
          <form id="searchContainer">
            <div class="search">
              <input type="text" id="searchInput" required placeholder="搜索...">
              <button type="reset" id="clearButton" class="hidden"><svg width="20" height="20"><use xlink:href="#reset"/></svg></button>
            </div>
            <button type="submit" id="searchButton"><svg width="20" height="20"><use xlink:href="#search"/></svg></button>
            <button type="button" id="settingsButton"><svg width="20" height="20"><use xlink:href="#gear"/></svg></button>
            <button type="button" id="closeButton"><svg width="20" height="20"><use xlink:href="#close"/></svg></button>
          </form>
          <div class="category">
            <select id="categorySelect"></select>
            <button id="listCheckButton"><svg width="20" height="20"><use xlink:href="#list-check"/></svg></button>
          </div>
          <ul id="playlistItems"></ul>
          <div class="controls">
            <div id="pagination">
              <button id="prevPage" disabled>上页</button>
              <div class="page-information">
                <input id="pageControl" class="range" min="1" type="range" />
                <div id="pageInfo"></div>
              </div>
              <button id="nextPage" disabled>下页</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="video-container">
      <div class="box">
        <div class="video-wrapper">
          <video id="videoPlayer" playsinline poster="background.jpeg"></video>
          <video id="frameVideo" playsinline disablepictureinpicture muted></video>
        </div>
        <div class="video-control">

          <div class="controls" id="errorControl">
            <div id="errorMessage"></div>
          </div>

          <div class="controls">
            <button id="favoriteButton" disabled><svg width="20" height="20"><use xlink:href="#favorite"/></svg></button>
            <button id="playListButton"><svg width="20" height="20"><use xlink:href="#list"/></svg></button>
          </div>

          <div class="controls">
            <button id="playVideoButton" class="stopped"><svg width="20" height="20"><use xlink:href="#play"/></svg></button>
            <button id="fullscreenButton" disabled><svg width="20" height="20"><use xlink:href="#fullscreen"/></svg></button>
            <button id="rewindButton" disabled><svg width="20" height="20"><use xlink:href="#rewind"/></svg></button>
            <button id="forwardButton" disabled><svg width="20" height="20"><use xlink:href="#forward"/></svg></button>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
const DB_VERSION = 4;
const SITE_TITLE = 'Hunhe IPTV';
// M3U list store
const M3U_STORE = 'm3u-store';
// Favorites
const FAV_STORE = 'fav-store';
// The status cache of the playlist item
const STA_STORE = 'sta-store';

const UNSAFE_HTTP = 'http://';
const TYPES = {
  M3U: 'm3u', TXT: 'txt'
};
const SOURCES = {
  URL: 'url', CONTENT: 'content'
};

const database = {
  openDB: (dbName = 'm3u') => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(dbName, DB_VERSION);
      request.onblocked = (event) => {
        // If some other tab is loaded with the database, then it needs to be closed
        // before we can proceed.
      };

      request.onupgradeneeded = (event) => {
        /** @type {IDBDatabase} **/
        const db = event.target.result;
        try {
          db.createObjectStore(M3U_STORE, { keyPath: "id" });
        }
        catch(error) {}

        try {
          db.createObjectStore(FAV_STORE, { keyPath: "id" });
        }
        catch(error) {}

        try {
          db.createObjectStore(STA_STORE, { keyPath: "id" });
        }
        catch(error) {}

        db.onversionchange = (event) => {
          db.close();
        };
      };

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        reject(event.target.error);
      };
    });
  },
  addData: async (data, storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readwrite");
    const store = transaction.objectStore(storeName);
    const request = store.add(data);

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  readData: async (id, storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readonly");
    const store = transaction.objectStore(storeName);
    const request = store.get(id);

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  updateData: async (data, storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readwrite");
    const store = transaction.objectStore(storeName);
    const request = store.put(data);

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  deleteData: async (id, storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readwrite");
    const store = transaction.objectStore(storeName);
    const request = store.delete(id);

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  listData: async (storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readonly");
    const store = transaction.objectStore(storeName);
    let request = store.openCursor();
    const list = [];
    return new Promise((resolve, reject) => {
      request.onsuccess = (evt) => {
        const cursor = evt.target.result;
        if(cursor) {
          // const path = database.decodeString(cursor.key);
          // const pathSegments = path.split('/');
          // const fileName = pathSegments[pathSegments.length - 1];
          list.push(cursor.value);
          cursor.continue();
        }
        else {
          resolve(list);
        }
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  purgeData: async (storeName = FAV_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readwrite");
    const store = transaction.objectStore(storeName);
    const request = store.clear();
    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  /** @returns {{ totalSize: number, storeSize: Object.<string, number> }} Returns total size **/
  totalSize: async () => {
    let totalSize = 0;
    let storeSize = {};
    const db = await database.openDB();
    const transaction = db.transaction(db.objectStoreNames, "readonly");
    return await new Promise((resolve) => {
    
      for (const objectStoreName of db.objectStoreNames) {
        const objectStore = transaction.objectStore(objectStoreName);
        storeSize[objectStoreName] = 0;

        // Retrieve all objects in the object store
        const getAllRequest = objectStore.getAll();

        getAllRequest.onsuccess = (event) => {
          const items = event.target.result;

          // Calculate the size of each object and add it to the total
          for (const item of items) {
            const size = new Blob([JSON.stringify(item)]).size;
            totalSize += size;
            storeSize[objectStoreName] += size;
          }

          // If all object stores have been processed, return the total size
          if (objectStoreName === db.objectStoreNames[db.objectStoreNames.length - 1]) {
            resolve({ totalSize, storeSize });
          }
        };

        getAllRequest.onerror = (event) => {
          resolve({ totalSize, storeSize });
        };
      }
    })
  },
  encodeString: (plainText) => {
    const base64Encoded = btoa(unescape(encodeURIComponent(plainText)));
    return base64Encoded;
  },
  decodeString: (encodedText) => {
    const decodedText = decodeURIComponent(escape(atob(encodedText)));
    return decodedText;
  }
};

const allChannels = '所有频道';
const originalChannels = '原始所有频道';
const favoriteChannels = '收藏频道';

function getElementById(idList = []) {
  const domList = [];
  for(const id of idList) {
    domList.push(document.getElementById(id));
  }
  return domList;
}

/** @type {[
 * HTMLBodyElement,
 * HTMLVideoElement, HTMLDivElement, HTMLDivElement, HTMLInputElement, HTMLButtonElement,
 * HTMLButtonElement, HTMLButtonElement, HTMLDivElement, HTMLDivElement,
 * HTMLDivElement, HTMLButtonElement, HTMLDivElement, HTMLFormElement,
 * HTMLButtonElement, HTMLButtonElement, HTMLButtonElement, HTMLButtonElement, HTMLInputElement,
 * HTMLButtonElement, HTMLButtonElement, HTMLButtonElement, HTMLDivElement, HTMLButtonElement,
 * HTMLInputElement, HTMLButtonElement, HTMLButtonElement, HTMLTextAreaElement, HTMLInputElement,
 * HTMLButtonElement, HTMLSelectElement, HTMLUListElement, HTMLDivElement,
 * HTMLDivElement, HTMLButtonElement, HTMLDivElement, HTMLInputElement,
 * HTMLInputElement, HTMLSpanElement, HTMLTextAreaElement, HTMLVideoElement
 * ]} **/
const [
  pageBody,
  videoPlayer, errorMessage, errorControl, m3uUrlInput, closeM3uButton,
  loadM3uButton, settingsButton, m3uInputContainer, playlistContent,
  playlistContainer, playVideoButton, m3uList, searchContainer,
  favoriteButton, playListButton, rewindButton, forwardButton, searchInput,
  fullscreenButton, prevButton, nextButton, pageInfo, listCheckButton,
  pageControl, clearButton, closeButton, m3uContent, m3uContentKey,
  loadContentuButton, categorySelect, playlistItems, paginationGroup,
  pageContainer, databaseSize, databaseCategories, storeFrameCheckbox,
  checkTimeout, checkTimeoutDisplay, debugLogs, frameVideo
 ] = getElementById([
  'pageBody',
  'videoPlayer', 'errorMessage', 'errorControl', 'm3uUrlInput', 'closeM3uButton',
  'loadM3uButton', 'settingsButton', 'm3uInputContainer', 'playlistContent',
  'playlistContainer', 'playVideoButton', 'm3uList', 'searchContainer',
  'favoriteButton', 'playListButton', 'rewindButton', 'forwardButton', 'searchInput',
  'fullscreenButton', 'prevPage', 'nextPage', 'pageInfo', 'listCheckButton',
  'pageControl', 'clearButton', 'closeButton', 'm3uContent', 'm3uContentKey',
  'loadContentuButton', 'categorySelect', 'playlistItems', 'pagination',
  'pageContainer', 'databaseSize', 'databaseCategories', 'storeFrameCheckbox',
  'checkTimeout', 'checkTimeoutDisplay', 'debugLogs', 'frameVideo'
]);

let itemsPerPage = 15;
/** @type {Array<{ title: string, url: string, group: string }>} **/
let playlistData = [];
let currentPage = 1;
/** @type {Object.<string, Array<{ title: string, group: string, url: string }>>} **/
let categories = {};
let currentCategory = allChannels;
/** @type {Array<{ title: string, url: string, group: string }>} **/
let filteredPlaylistData = [];
/** @type {Object.<string, number>} **/
let videoTimestamp = {};
let storeFrame = 'false';
let stopURL = null;

function generateBlankFrame() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'darkblue';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  canvas.toBlob(blob => {
    stopURL = URL.createObjectURL(blob);
  }, 'video/mp4');
}

const uniqueUrls = new Set();

const VARS = {
  CURRENT_TITLE: '', CURRENT_GROUP: '', CURRENT_URL: '',
  ICON_PLAY: '<svg width="20" height="20"><use xlink:href="#play"/></svg>',
  ICON_STOP: '<svg width="20" height="20"><use xlink:href="#stop"/></svg>',
  ICON_CANCEL: '<svg width="20" height="20"><use xlink:href="#cancel"/></svg>',
  ICON_FULLSCREEN: '<svg width="20" height="20"><use xlink:href="#fullscreen"/></svg>',
  ICON_UNFAVORITE: '<svg width="20" height="20"><use xlink:href="#unfavorite"/></svg>',
  ICON_FAVORITE: '<svg width="20" height="20"><use xlink:href="#favorite"/></svg>',
  POSTER: 'background.jpeg',
  PING_TIMEOUT: 0
};

async function listStore(source) {

  const cachedM3uSource = localStorage.getItem('cachedM3uSource') || SOURCES.URL;
  const cachedM3uUrl = localStorage.getItem('cachedM3uUrl') || '';

  m3uList.innerHTML = '';

  /** @type {Array<{ key: string, id: string, source: string }>} */
  const list = await database.listData();
  for(const m3uItem of list) {
    const url = database.decodeString(m3uItem.id);
    const isCurrent = cachedM3uUrl.includes(url) || (cachedM3uSource === SOURCES.CONTENT && m3uItem.source === SOURCES.CONTENT && cachedM3uUrl.includes(url));

    const divItem = document.createElement('div');
    const aItem = document.createElement('a');
    const dItem = document.createElement('a');
    dItem.innerText = '删';
    dItem.className = 'delete';
    dItem.dataset['id'] = m3uItem.id;
    dItem.ondblclick = async (evt) => {
      evt.preventDefault();
      await database.deleteData(evt.target.dataset['id']);
      listStore('click');
    };
    aItem.textContent = url;
    aItem.className = 'load';
    aItem.dataset['id'] = m3uItem.id;
    aItem.onclick = async (evt) => {
      /** @type {HTMLAnchorElement} **/
      const element = evt.target;
      const data = await database.readData(element.dataset['id']);
      if(element.textContent === cachedM3uUrl) {
        return;
      }
      // if(data.source === SOURCES.CONTENT) {
      //   m3uUrlInput.value = '';
      //   m3uContent.value = data.m3u;
      // }
      // else 
      if(data.source === SOURCES.URL) {
        m3uUrlInput.value = database.decodeString(m3uItem.id);
      }
      gotoPage(1);
      processM3uData(data.type || TYPES.M3U, data.m3u);
    };
    divItem.append(aItem);
    if(isCurrent) {
      divItem.classList.add('active');
    }
    else {
      divItem.append(dItem);
    }
    m3uList.append(divItem);
  }
}

function loadCurrentChannel(isBooting = false, source = '') {
  currentCategory = allChannels;
  if(isBooting) {
    const category = window.localStorage.getItem('currentCategory');
    if(category) {
      currentCategory = category;
    }
  }
  return currentCategory;
}

function saveCurrentChannel() {
  window.localStorage.setItem('currentCategory', currentCategory);
}

function loadLocalCache() {
  loadVideoTimestamp();
  currentPage = parseInt(window.localStorage.getItem('currentPage')) || 1;

  storeFrame = window.localStorage.getItem('storeFrame') === 'true' ? 'true' : 'false';
  storeFrameCheckbox.checked = storeFrame === 'true';

  VARS.PING_TIMEOUT = parseInt(window.localStorage.getItem('PING_TIMEOUT')) || 10000;
  checkTimeout.value = Math.round(VARS.PING_TIMEOUT / 1000);
  checkTimeoutDisplay.textContent = checkTimeout.value;
}

function initSideMenu() {
  const playListVisible = window.localStorage.getItem('playListVisible') || 'false';
  if(playListVisible === 'false') {
    playlistContainer.className = 'hidden';
  }
  else {
    playlistContainer.className = 'play-list';
  }
}

/**
 * Get last played video data
 * @returns {{ url: string, group: string, title: string }?} Returns Play item
 */
function getLastVideoItem() {
  const data = window.localStorage.getItem('lastPlayedItem');
  if(data) {
    return JSON.parse(data);
  }
  return null;
}

function saveVideoTimestamp() {
  window.localStorage.setItem('videoTimestamp', JSON.stringify(videoTimestamp));
}

function loadVideoTimestamp() {
  const videoTimestampData = window.localStorage.getItem('videoTimestamp');
  videoTimestamp = videoTimestampData ? JSON.parse(videoTimestampData) : {};
  return videoTimestamp;
}


function playLastVideo(isUserAction = true) {
  const lastPlayedItem = getLastVideoItem();
  if (lastPlayedItem) {
    loadVideoTimestamp();
    playVideo(lastPlayedItem, isUserAction);
  }
}

function changePoster(poster) {
  videoPlayer.poster = poster;
  pageBody.style.background = `transparent url("${poster}") center center / cover no-repeat`;
}

function stopVideo(poster = VARS.POSTER) {
  videoPlayer.src = stopURL;
  videoPlayer.pause();
  document.title = SITE_TITLE;
  showPlayButton(false);
  rewindButton.disabled = forwardButton.disabled = true;
  saveVideoTimestamp();
  changePoster(poster);
}

function showPlayButton(showControls = false) {
  playVideoButton.innerHTML = VARS.ICON_PLAY;
  fullscreenButton.disabled = true;
  playVideoButton.className = 'stopped';
  videoPlayer.controls = showControls;
  videoPlayer.className = 'paused';
}

function onStopped() {
  showPlayButton(true);
  document.title = SITE_TITLE;;
  saveVideoTimestamp();
}

function setVideoTimestamp(timestamp) {
  const lastPlayedItem = getLastVideoItem();
  videoTimestamp[lastPlayedItem.url] = timestamp;
}

function resetVideoTimestamp() {
  const lastPlayedItem = getLastVideoItem();
  if (lastPlayedItem) {
    loadVideoTimestamp();
    setVideoTimestamp(0);
    saveVideoTimestamp();
  }
}

// 保存数据到缓存
function saveDataToCache() {
  window.localStorage.setItem('cachedM3uUrl', m3uUrlInput.value);
  window.localStorage.setItem('currentPage', currentPage);
  saveCurrentChannel();
}

// 显示播放列表内容
function showPlaylistContent() {
  m3uInputContainer.classList.add('hidden');
  playlistContent.classList.remove('hidden');
  playlistContainer.className = 'play-list';
}

function getMegaBytes(val) {
  return (val/1024/1024).toFixed(2);
}

// 显示 M3U 输入界面
async function showM3uInput() {
  window.localStorage.setItem('playListVisible', 'true');

  if(m3uInputContainer.classList.contains('hidden')) {
    m3uInputContainer.classList.remove('hidden');
    playlistContent.classList.add('hidden');
    await listStore('showM3uInput');
    playlistContainer.className = 'settings';
  }
  else {
    showPlaylistContent();
  }
  const { totalSize, storeSize } = await database.totalSize();
  const size = getMegaBytes(totalSize);
  databaseSize.textContent = `${size} MB`;
  databaseCategories.innerHTML = '';
  for(const item in storeSize) {
    const button = document.createElement('button');
    const labels = { [FAV_STORE]: '收藏', [M3U_STORE]: '频道', [STA_STORE]: '缓存' };
    button.textContent = `${labels[item]}: ${getMegaBytes(storeSize[item])} MB`;
    button.ondblclick = async () => {
      await database.purgeData(item);
      window.location.reload();
    };
    databaseCategories.append(button);
  }
}

function processM3uData(type, data, fromCache = false, isBooting = false) {
  initPlayData(type, data);
  initializeCategories(isBooting);
  initializePlaylist();
  showPlaylistContent();
  if (!fromCache) {
    saveDataToCache();
  }
  errorMessage.textContent = '';
}

// 加载 M3U 文件
async function loadM3uFile(fromCache = false, isBooting = false) {

  /** @type {string} **/
  const m3uUrl = m3uUrlInput.value.trim();
  const type = (m3uUrl.endsWith('m3u') || m3uUrl.endsWith('m3u8')) ? TYPES.M3U : m3uUrl.endsWith('txt') ? TYPES.TXT : '';

  if (type && m3uUrlInput.checkValidity()) {
    const id = database.encodeString(m3uUrl);
    const payload = await database.readData(id);
    if(payload && payload.m3u && fromCache) {
      processM3uData(type, payload.m3u, true, isBooting);
    }
    else {
      loadM3uButton.disabled = true;
      // Main M3U URL
      const url = m3uUrl.startsWith(UNSAFE_HTTP) ? `${window.location.origin}/api/fetch?url=${m3uUrl}` : m3uUrl;
      fetch(url).then(response => {
        if(response.status === 200 || response.status === 202 || response.status === 302) {
          return response.text();
        }
        return null;
      })
      .then(async data => {
        loadM3uButton.disabled = false;
        if(data) {
          if(payload) {
            await database.updateData({ id, m3u: data, source: SOURCES.URL, type });
          }
          else {
            await database.addData({ id, m3u: data, source: SOURCES.URL, type });
          }
          processM3uData(type, data, fromCache, false, isBooting);
          listStore('fetch');
          gotoPage(1);
        }
        else {
          errorMessage.textContent = '加载 M3U 文件时出错，请检查 URL 是否正确。';
          showM3uInput();  
        }
      })
      .catch(error => {
        errorMessage.textContent = '加载 M3U 文件时出错，请检查 URL 是否正确。';
        showM3uInput();
        loadM3uButton.disabled = false;
      });
    }
  } else {
    errorMessage.textContent = '请输入有效的 M3U 文件 URL。';
  }
}

// async function loadM3uContent() {
//   if(m3uContent.value.includes('#EXTINF:')) {
//     const id = database.encodeString(m3uContentKey.value);
//     const payload = await database.readData(id);
//     const data = { id, m3u: m3uContent.value, source: SOURCES.CONTENT, type: TYPES.M3U }; // m3u only
//     if(payload) {
//       await database.updateData(data);
//     }
//     else {
//       await database.addData(data);
//     }
//     processM3uData(TYPES.M3U, data.m3u, true);
//   }
// }

/**
 * 处理 M3U 文件单行
 * @param {string} line Line
 */
function processM3uLine(line) { 
  if (line.startsWith('#EXTINF:')) {
    const infoLine = line.substring(8);
    const groupMatch = infoLine.match(/group-title="([^"]+)"/);
    VARS.CURRENT_GROUP = groupMatch ? groupMatch[1] : allChannels;
    VARS.CURRENT_TITLE = infoLine.split(',').pop().trim();
  } else if (line && !line.startsWith('#')) {
    if (!uniqueUrls.has(line)) {
      uniqueUrls.add(line);

      const item = { title: VARS.CURRENT_TITLE || line, url: line, group: VARS.CURRENT_GROUP };
      playlistData.push(item);
      categories[allChannels].push(item);
      if (VARS.CURRENT_GROUP !== allChannels) {
        if (!categories[VARS.CURRENT_GROUP]) {
          categories[VARS.CURRENT_GROUP] = [];
        }
        categories[VARS.CURRENT_GROUP].push(item);
      }
    }
  }
}

/**
 * 处理 TXT 文件单行
 * @param {string} line Text line
 */
function processTxtLine(line) {
  if (line.endsWith('#genre#')) {
    const infoLine = line.replace(',#genre#', '');
    VARS.CURRENT_GROUP = infoLine ? infoLine : allChannels;
  } else if (line && !line.endsWith('#genre#')) {
    const lineArray = line.split(',');
    if(lineArray.length < 2) return;

    VARS.CURRENT_URL = lineArray.pop().trim();
    VARS.CURRENT_TITLE = lineArray.pop().trim();

    if (!uniqueUrls.has(VARS.CURRENT_URL)) {
      uniqueUrls.add(VARS.CURRENT_URL);
      const group = VARS.CURRENT_GROUP || allChannels;
      const item = { title: VARS.CURRENT_TITLE, url: VARS.CURRENT_URL, group };
      playlistData.push(item);
      categories[allChannels].push(item);
      if (group !== allChannels) {
        if (!categories[group]) {
          categories[group] = [];
        }
        categories[group].push(item);
      }
    }
  }
}

// 解析 M3U 数据
function initPlayData(type, data) {
  // Data for all
  playlistData = [];
  // Data in categories
  categories = { [allChannels]: [], [favoriteChannels]: [] };
  uniqueUrls.clear();

  const lines = data.split('\n');

  for(const item of lines) {
    const line = item.trim();
    // [M3U] Start - Process data
    if(type === TYPES.M3U) {
      processM3uLine(line);
    }
    else if (type === TYPES.TXT) {
      processTxtLine(line);
    }
    // [M3U] End - Process data
  }
  categories[originalChannels] = [...categories[allChannels]];
}

// 初始化分类
function initializeCategories(isBooting = false) {
  categorySelect.innerHTML = '';
  for (let category in categories) {
    if(category === originalChannels){
      continue;
    }
    const option = document.createElement('option');
    option.value = category;
    option.textContent = category;
    categorySelect.appendChild(option);
  }

  categorySelect.value = loadCurrentChannel(isBooting, 'initializeCategories');
}

function resetListStyle() {
  for(const node of playlistItems.childNodes) {
    node.classList.remove('active');
  }
}
/**
 * @param {HTMLLIElement} li List item
 * @param {{ title: string, url: string, group: string }} item Play item
 */
function playNow (li, item) {
  if(li.dataset['proxy']) return;
  resetListStyle();
  li.classList.add('active');
  playVideo(item);
}

// 显示播放列表页面
async function displayPlaylistPage(page) {
  playlistItems.innerHTML = '';
  /** @type {Array<{ title: string, url: string, group: string }>} **/
  const itemsToDisplay = filteredPlaylistData || [];
  const startIndex = (page - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const pageItems = itemsToDisplay.slice(startIndex, endIndex);
  const lastPlayedItem = getLastVideoItem();

  listCheckButton.disabled = true;
  // Loop list items
  pageItems.forEach(async (item, index) => {
    /** @type {HTMLLIElement} **/
    const li = document.createElement('li');
    /** @type {HTMLDivElement} **/
    const div = document.createElement('div');
    div.className = 'label';
    div.textContent = item.group === currentCategory ? item.title : `[${item.group}] ${item.title}`;

    if(item.url.startsWith(UNSAFE_HTTP)) {
      li.dataset['proxy'] = true;
      li.classList.add('proxy');
      li.classList.add('broken');
    }

    li.dataset['url'] = item.url;
    li.dataset['group'] = item.group;
    li.title = item.title;

    li.onclick = (evt) => {
      evt.preventDefault();
      const { currentTarget } = evt;
      if(currentTarget.dataset['proxy']) return;
      const frame = currentTarget.dataset['frame'] ? currentTarget.dataset['frame'] : VARS.POSTER;
      if(videoPlayer.poster === frame || frame === VARS.POSTER) {
        playNow(currentTarget, item);
        // stopVideo(VARS.POSTER);
      }
      else {
        stopVideo(frame);
      }
    };

    // li.onclick = () => {
    //   playNow(li, item);
    // };
    li.append(div);
    playlistItems.appendChild(li);
  });

  // Update styles
  for (const li of playlistItems.childNodes) {
    const videoUrl = li.dataset['url'];
    const id = database.encodeString(videoUrl);
    const isFav = await isFavorite(id);
    const playCache = await database.readData(id, STA_STORE);
    if (playCache) {
      updateListItemStyle(li, playCache.result, lastPlayedItem, isFav);
    }
    else {
      // No cache or cleaned
      const result = await checkVideoPlayability(videoUrl);
      await database.addData({ id, result }, STA_STORE);
      updateListItemStyle(li, result, lastPlayedItem, isFav);
    }
  }
  listCheckButton.disabled = false;
}

/**
 * @param {HTMLLIElement} li List item
 * @param {{ ok: boolean, duration: number, frame: string, timeout: boolean }} checkResult List item
 * @param {{ url: string, group: string, title: string }} lastPlayedItem Last played data
 * @param {boolean} isFav If it is favorite
 */
function updateListItemStyle(li, checkResult, lastPlayedItem, isFav) {
  li.className = '';
  if (checkResult.ok) {
    if(checkResult.duration < 300) {
      li.classList.add('good');
    }
    else if (checkResult.duration >= 300 && checkResult.duration <= 1000) {
      li.classList.add('average');
    }
    else {
      li.classList.add('bad');
    }
    if(checkResult.frame) {
      li.dataset['frame'] = URL.createObjectURL(checkResult.frame);
      li.classList.add('frame');
    }
  }
  else {
    if(checkResult.timeout === false) {
      li.classList.add('broken');
      li.dataset['proxy'] = true;
      li.classList.add('proxy');
    }
    li.title = `此视频源可能无法播放`;
  }
  if(lastPlayedItem?.url === li.dataset['url']) {
    li.classList.add('active');
  }
  if(isFav && currentCategory !== favoriteChannels) {
    li.classList.add('favorite');
  }
}

// 更新分页控件
function updatePaginationControls() {
  const itemsToDisplay = filteredPlaylistData || [];
  const totalPages = Math.ceil(itemsToDisplay.length / itemsPerPage);
  const hasData = itemsToDisplay.length > 0;
  pageControl.max = totalPages;

  if(hasData) {
    pageInfo.innerHTML = `第 <span id="pageCurrent">${currentPage}</span>/${totalPages} 页`;
    pageControl.min = 1;
  }
  else {
    pageInfo.textContent = '';
    pageControl.min = 0;
  }
  pageControl.value = currentPage;
  prevButton.disabled = (currentPage === 1 || hasData === false);
  nextButton.disabled = (currentPage === totalPages || hasData === false);
}

// 初始化播放列表
async function initializePlaylist() {
  await fetchFavorites();
  filteredPlaylistData = categories[currentCategory] || playlistData;
  displayPlaylistPage(currentPage);
  updatePaginationControls();
}

// 执行搜索
function performSearch() {
  const searchTerm = searchInput.value.toLowerCase();

  if (currentCategory === allChannels || currentCategory === originalChannels) {
    filteredPlaylistData = categories[originalChannels].filter(item => 
      item.title.toLowerCase().includes(searchTerm)
    );
  } else {
    filteredPlaylistData = categories[currentCategory].filter(item => 
      item.title.toLowerCase().includes(searchTerm)
    );
  }
  gotoPage(1);
}

// 刷新当前页面
async function refreshCurrentPage() {
  listCheckButton.disabled = true;
  const lastPlayedItem = getLastVideoItem();
  const items = playlistItems.children;

  for (let i = 0; i < items.length; i++) {
    const li = items[i];
    li.title = '';
    li.className = 'checking';

    const itemUrl = li.dataset['url'];

    if (itemUrl) {
      const id = database.encodeString(itemUrl);
      const result = await checkVideoPlayability(itemUrl);
      const isFav = await isFavorite(id);
      await database.updateData({ id, result }, STA_STORE);
      updateListItemStyle(li, result, lastPlayedItem, isFav);
    }
    else {
      li.title = '';
      li.classList.add('broken');
    }
  }
  listCheckButton.disabled = false;
  saveDataToCache();
}

function playVideSource(source) {
  videoPlayer.play().catch(error => {
    errorMessage.textContent = '无法播放所选视频，请尝试其他源或检查网络连接。';
  }).then(() => {
    onPlay(source);
  });
}

function hlsPlay(source) {
  printLog('hlsPlay');
  try {
    const hls = new Hls();
    hls.loadSource(source.url);
    hls.attachMedia(videoPlayer);
    hls.on(Hls.Events.MANIFEST_PARSED, (evt) => {
      printLog('Hls.Events.MANIFEST_PARSED');
      playVideSource(source);
    });
    hls.on(Hls.Events.ERROR, (error) => {
      hls.destroy();
    });
  }
  catch(error) {
    console.log('HLS ERROR 1');
  }
}

function nativePlay(source) {
  printLog('nativePlay');
  videoPlayer.src = source.url;
  const onLoadedMetadata = (evt) => {
    printLog('videoPlayer.loadedmetadata');
    if (source) {
      playVideSource(source);
    }
  }
  videoPlayer.removeEventListener('loadedmetadata', onLoadedMetadata);
  videoPlayer.addEventListener('loadedmetadata', onLoadedMetadata);
}

function refreshFavoriteButton(hasFavorite) {
  if(hasFavorite) {
    favoriteButton.innerHTML = VARS.ICON_UNFAVORITE;
    favoriteButton.dataset['action'] = 'remove';
    favoriteButton.classList.add('remove');
  }
  else {
    favoriteButton.innerHTML = VARS.ICON_FAVORITE;
    favoriteButton.dataset['action'] = 'add';
    favoriteButton.classList.remove('remove');
  }
}

function saveLastPlayedVideo(playingItem) {
  window.localStorage.setItem('lastPlayedItem', JSON.stringify(playingItem));
}

/**
 * If the URL is favorite
 * @param {string} id ID
 * @returns {Promise<boolean>} Returns true or false
 */
async function isFavorite(id) {
  const data = await database.readData(id, FAV_STORE);
  return data ? true : false;
}

/**
 * @param {{ title: string, url: string, group: string }} playingItem Play item
 **/
async function onPlay(playingItem) {
  videoPlayer.controls = true;
  errorMessage.textContent = '';
  favoriteButton.disabled = false;

  const id = database.encodeString(playingItem.url);

  favoriteButton.dataset['id'] = id;
  favoriteButton.dataset['url'] = playingItem.url;
  favoriteButton.dataset['group'] = playingItem.group;
  favoriteButton.dataset['title'] = playingItem.title;

  refreshFavoriteButton(await isFavorite(id));
  const lastPlayedTime = videoTimestamp[playingItem.url];
  if (!isNaN(lastPlayedTime)) {
    videoPlayer.currentTime = lastPlayedTime;
  }
  saveLastPlayedVideo(playingItem);
}

function onPlaying() {
  playVideoButton.innerHTML = VARS.ICON_STOP;;
  fullscreenButton.disabled = false;
  playVideoButton.className = 'played';
  videoPlayer.controls = true;
  errorMessage.textContent = '';
  videoPlayer.className = '';
  rewindButton.disabled = forwardButton.disabled = false;
}

/**
 * @param {{ title: string, group: string, url: string }} source Play item
 * @param {boolean} isUserAction If it is controled by user
 */
function playVideo(source, isUserAction = true) {
  favoriteButton.disabled = true;
  if (source) {
    document.title = source.title;
  } else {
    document.title = SITE_TITLE;
  }
  if(isUserAction === false) { return; }
  window.localStorage.removeItem('lastPlayedItem');
  videoPlayer.muted = true;
  if (Hls.isSupported() && source.url.startsWith(UNSAFE_HTTP) === false) {
    hlsPlay(source);
  }
  else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
    nativePlay(source);
  }
  else {
    errorMessage.textContent = '您的浏览器不支持 HLS 视频流。';
  }
}

/**
 * @param {Array<any>} args
 */
function printLog(...args) {
  debugLogs.innerHTML = `$ ${args.join(' ')}\n`.concat(debugLogs.innerHTML);
}

/** @param {HTMLVideoElement} video **/
async function captureFrame(url, hls = false) {
  if(storeFrame === 'true') {
    let timer = 0;
    const frame = await new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const canvasContext = canvas.getContext('2d');

      if(hls) {
        hls.attachMedia(frameVideo);
      }
      else {
        frameVideo.src = url;
      }

      const onLoadedMetaData = (evt) => {
        canvas.width = frameVideo.videoWidth;
        canvas.height = frameVideo.videoHeight;
        frameVideo.play().then(() => {
          frameVideo.currentTime = 360;
        }).catch(error => {
          clearTimeout(timer);
          cleanupEvents(null);
        });
      },
      onSeeked = (evt) => {
        canvas.width = frameVideo.videoWidth;
        canvas.height = frameVideo.videoHeight;
        canvasContext.drawImage(frameVideo, 0, 0, canvas.width, canvas.height);
        canvas.toBlob((blob) => {
          clearTimeout(timer);
          cleanupEvents(blob);
        });
      };

      const cleanupEvents = (data) => {
        frameVideo.removeEventListener('seeked', onSeeked);
        frameVideo.removeEventListener('loadedmetadata', onLoadedMetaData);
        resolve(data);
      };

      frameVideo.addEventListener('seeked', onSeeked);
      frameVideo.addEventListener('loadedmetadata', onLoadedMetaData);

      timer = setTimeout(() => {
        cleanupEvents(null);
      }, VARS.PING_TIMEOUT - 1000);
    });
    return frame;
  }
  return null;
}

/**
 * 检查视频可播放性
 * @param {string} url URL
 * @returns {{ ok: boolean, duration: number, frame: string, timeout: boolean }}
 **/
async function checkVideoPlayability(url) {
  const timestamp = new Date().getTime();
  return new Promise((resolve) => {
    let timeoutId = 0;
    if (Hls.isSupported() && url.startsWith(UNSAFE_HTTP) === false) {
      try {
        const hls = new Hls();
        const cleanup = () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          hls.destroy();
        };

        hls.loadSource(url);
        hls.on(Hls.Events.MANIFEST_PARSED, async () => {
          const duration = new Date().getTime() - timestamp;
          const frame = await captureFrame(url, hls);
          cleanup();
          resolve({ ok: true, duration, frame, timeout: false });
        });

        hls.on(Hls.Events.ERROR, () => {
          cleanup();
          resolve({ ok: false, duration: new Date().getTime() - timestamp, timeout: false });
        });

        timeoutId = setTimeout(() => {
          cleanup();
          resolve({ ok: false, duration: new Date().getTime() - timestamp, timeout: true });
        }, VARS.PING_TIMEOUT);
      }
      catch(error) {
        console.log('HLS ERROR 2');
      }
    }
    else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
      const video = document.createElement('video');
      video.src = url;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        video.remove();
      };

      video.onloadedmetadata = async () => {
        const duration = new Date().getTime() - timestamp;
        const frame = await captureFrame(url);
        cleanup();
        resolve({ ok: true, duration, frame, timeout: false });
      };

      video.onerror = () => {
        cleanup();
        resolve({ ok: false, duration: new Date().getTime() - timestamp, timeout: false });
      };

      timeoutId = setTimeout(() => {
        cleanup();
        resolve({ ok: false, duration: new Date().getTime() - timestamp, timeout: true });
      }, VARS.PING_TIMEOUT);
    } else {
      resolve({ ok: false, duration: new Date().getTime() - timestamp, timeout: false });
    }
  });
}

function gotoPage(p) {
  currentPage = p;
  displayPlaylistPage(currentPage);
  updatePaginationControls();
  saveDataToCache();
}

async function fetchFavorites() {
  categories[favoriteChannels] = await database.listData(FAV_STORE);
  return categories[favoriteChannels];
}

// 加载缓存的数据
async function startup() {
  const cachedM3uUrl = window.localStorage.getItem('cachedM3uUrl') || '';
  if (cachedM3uUrl) {
    m3uUrlInput.value = cachedM3uUrl;
    await loadM3uFile(true, true); // 添加一个参数来表示这是从缓存加载
  }
  else {
    await showM3uInput();
  }
  loadLocalCache();
  gotoPage(currentPage);
  playLastVideo(false);
  listStore('startup');
  initSideMenu();
  generateBlankFrame();
}

// 事件监听器
favoriteButton.addEventListener('click', async (evt) => {
  const id = favoriteButton.dataset['id'];
  const url = favoriteButton.dataset['url'];
  const group = favoriteButton.dataset['group'];
  const title = favoriteButton.dataset['title'];
  const isAddingData = favoriteButton.dataset['action'] === 'add';
  const isDeletingData = favoriteButton.dataset['action'] === 'remove';
  if(isAddingData) {
    await database.addData({ id, url, title, group }, FAV_STORE);
  }
  else if(isDeletingData) {
    await database.deleteData(id, FAV_STORE);
  }
  refreshFavoriteButton(isAddingData);
  initializePlaylist();
});

categorySelect.addEventListener('change', async (evt) => {
  currentCategory = evt.target.value;
  // 重置搜索
  searchInput.value = '';
  // 更新当前类别的数据
  if(currentCategory === favoriteChannels) {
    filteredPlaylistData = await fetchFavorites();
  }
  else {
    filteredPlaylistData = categories[currentCategory === allChannels ? originalChannels : currentCategory];
  }
  gotoPage(1);
});
loadM3uButton.addEventListener('click', (evt) => loadM3uFile(false));
// loadContentuButton.addEventListener('click', () => loadM3uContent());
closeM3uButton.addEventListener('click', (evt) => {
  showM3uInput();
});

settingsButton.addEventListener('click', showM3uInput);

function gotoPrevPage(evt) {
  evt.preventDefault();
  if (currentPage > 1) {
    currentPage--;
    gotoPage(currentPage);
  }
}
prevButton.addEventListener('click', gotoPrevPage);
prevButton.addEventListener('dblclick', gotoPrevPage);
document.addEventListener('dblclick', (evt) => {
  /** @type {HTMLElement} **/
  const node = evt.target;
  switch(node.tagName) {
    case 'input':
      break;
    case 'video':
      videoPlayer.requestFullscreen();
      break;
    default:
      evt.preventDefault();
      evt.stopPropagation();
  }
});

function gotoNextPage(evt) {
  evt.preventDefault();
  const itemsToDisplay = filteredPlaylistData || [];
  if (currentPage < Math.ceil(itemsToDisplay.length / itemsPerPage)) {
    currentPage++;
    gotoPage(currentPage);
  }
}

function resetPoster(evt) {
  evt.preventDefault();
  if(evt.target.poster !== VARS.POSTER) {
    changePoster(VARS.POSTER);
  }
}

nextButton.addEventListener('click', gotoNextPage);
nextButton.addEventListener('dblclick', gotoNextPage);

pageControl.addEventListener('change', (evt) => {
  gotoPage(parseInt(evt.target.value));
  document.getElementById('pageCurrent').textContent = currentPage;
});
pageControl.addEventListener('input', (evt) => {
  document.getElementById('pageCurrent').textContent = parseInt(evt.target.value);
});

searchContainer.addEventListener('submit', (evt) => {
  evt.preventDefault();
  evt.stopImmediatePropagation();
  if(searchContainer.checkValidity())
    performSearch();
});

searchInput.addEventListener('keyup', (evt) => {
  if(evt.target.value === '') {
    clearButton.classList.add('hidden');
  }
  else {
    clearButton.classList.remove('hidden');
  }
});

searchInput.addEventListener('input', function() {
  if (this.value === '') {
    // 清空搜索关键字后，恢复到当前类别的播放列表
    filteredPlaylistData = categories[currentCategory === allChannels ? originalChannels : currentCategory];
    gotoPage(1);
  }
  searchInput.dispatchEvent(new Event('keyup'));
});

clearButton.addEventListener('click', (evt) => {
  evt.preventDefault();
  searchInput.value = '';
  performSearch();
  gotoPage(1);
  searchInput.dispatchEvent(new Event('keyup'));
});

closeButton.addEventListener('click', (evt) => {
  playListButton.dispatchEvent(new Event('click'));
});

listCheckButton.addEventListener('click', (evt) => {
  refreshCurrentPage();
});

videoPlayer.addEventListener('timeupdate', (evt) => {
  console.log(evt.target);
  if(videoPlayer.src === stopURL) { return; }

  const lastPlayedItem = getLastVideoItem();
  if(lastPlayedItem) {
    /** @type {HTMLVideoElement} **/
    const player = evt.target;
    if(player.duration - player.currentTime < 10) {
      resetVideoTimestamp();
    }
    else {
      setVideoTimestamp(player.currentTime);
    }
  }
});

videoPlayer.addEventListener('pause', (evt) => {
  printLog('videoPlayer.pause');
  onStopped();
});
videoPlayer.addEventListener('seeked', (evt) => {
  printLog('videoPlayer.seeked', evt.target.src);
});
videoPlayer.addEventListener('canplay', (evt) => {
  printLog('videoPlayer.canplay');
});
videoPlayer.addEventListener('play', (evt) => {
  printLog('videoPlayer.play');
  onPlaying();
});
videoPlayer.addEventListener('loadeddata', (evt) => {
  printLog('videoPlayer.loadeddata');
});
videoPlayer.addEventListener('playing', (evt) => {
  printLog('videoPlayer.playing');
});
videoPlayer.addEventListener('waiting', (evt) => {
  printLog('videoPlayer.waiting');
  playVideoButton.className = 'playing';
  playVideoButton.innerHTML = VARS.ICON_CANCEL;
});
videoPlayer.addEventListener('canplaythrough', (evt) => {
  printLog('videoPlayer.canplaythrough');
  onPlaying();
});
videoPlayer.addEventListener('ended', (evt) => {
  printLog('videoPlayer.ended');
  onStopped(true);
});
videoPlayer.addEventListener('error', (evt) => {
  printLog('videoPlayer.error');
  if(videoPlayer.src === stopURL) {
    showPlayButton();
    return;
  }
  errorMessage.textContent = '加载视频时出错，请尝试其他源或检查网络连接。';
});
videoPlayer.addEventListener('click', resetPoster);
errorControl.addEventListener('click', resetPoster);
playVideoButton.addEventListener('click', (evt) => {
  if(playVideoButton.className === 'played' || playVideoButton.className === 'playing') {
    stopVideo();
  }
  else {
    playLastVideo();
  }
});

fullscreenButton.addEventListener('click', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  videoPlayer.requestFullscreen();
});

rewindButton.addEventListener('click', (evt) => {
  videoPlayer.currentTime -= 30;
  const lastPlayedItem = getLastVideoItem();
  if(lastPlayedItem) {
    setVideoTimestamp(videoPlayer.currentTime);
  }
});

forwardButton.addEventListener('click', (evt) => {
  videoPlayer.currentTime += 30;
  const lastPlayedItem = getLastVideoItem();
  if(lastPlayedItem) {
    setVideoTimestamp(videoPlayer.currentTime);
  }
});

playListButton.addEventListener('click', (evt) => {
  let playListVisible = window.localStorage.getItem('playListVisible') || 'false';
  // Hide playlist
  if(playListVisible === 'true') {
    playlistContainer.className = 'hidden';
    playListVisible = 'false';
  }
  // Show playlist
  else {
    showPlaylistContent();
    playListVisible = 'true';
  }
  window.localStorage.setItem('playListVisible', playListVisible);
});

storeFrameCheckbox.addEventListener('change', (evt) => {
  storeFrame = evt.target.checked ? 'true' : 'false';
  window.localStorage.setItem('storeFrame', storeFrame);
});

checkTimeout.addEventListener('input', (evt) => {
  VARS.PING_TIMEOUT = parseInt(evt.target.value) * 1000;
  checkTimeoutDisplay.textContent = evt.target.value;
  window.localStorage.setItem('PING_TIMEOUT', VARS.PING_TIMEOUT);
});

let muted = true, isHidden = false;

document.addEventListener('keydown', function (event) {
  if (event.key === 'Escape' || event.keyCode === 27) {
    event.preventDefault();
    if(isHidden) {
      pageContainer.className = 'container';
    }
    else {
      pageContainer.className = 'hidden';
      muted = videoPlayer.muted;
      //
      videoPlayer.muted = true;
      videoPlayer.pause();
    }
    isHidden = !isHidden;
  }
});

window.addEventListener('beforeunload', (evt) => {
  saveVideoTimestamp();
});

// 初始化
startup();
</script>

</body>
</html>
