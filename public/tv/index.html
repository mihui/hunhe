<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Hunhe IPTV</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="format-detection" content="telephone=no">
  <meta name="msapplication-tap-highlight" content="no">
  <script src="js-hls.js"></script>
  <script src="js-swipe.js?v=1"></script>
  <script src="js-simple-peer.js"></script>
  <script>
    // M3U list store
const M3U_STORE = 'm3u-store';
// Favorites
const FAV_STORE = 'fav-store';
// The status cache of the playlist item
const STA_STORE = 'sta-store';

/**
 * 数据库类，封装了IndexedDB的操作
 */
class Database {
  /** @type {IDBDatabase} */
  db;
  /** @type {IDBOpenDBRequest} */
  request;
  /** @type {string} */
  dbName;
  /** @type {number} */
  dbVersion;
  /** @type {number} */
  retries = 0;
  /**
   * 构造函数，初始化数据库版本和名称
   * @param {number} dbVersion - 数据库版本，默认为1
   * @param {string} dbName - 数据库名称，默认为'm3u'
   */
  constructor(dbVersion = 1, dbName = 'm3u') {
    this.dbName = dbName; // 数据库名称
    this.dbVersion = dbVersion; // 数据库版本
    this.db = null; // 数据库实例
  }

  closeDB() {
    try {
      this.db?.close();
      this.db = null;
    }
    catch(error) {}
  }

  async reconnect() {
    for (; this.retries < 3; this.retries++) {
      this.closeDB();
      this.retries++;
      const result = await this.openDB();
      if(result.db) {
        this.db = result.db;
        return { error: null, db: this.db };
      }
    }
    if(this.db === null) {
      window.location.reload();
    }
    return { error: new Error('重连失败'), db: this.db };
  }

  /**
   * 打开数据库方法
   * @returns {Promise<{ db: IDBDatabase, error: Error }>} - 返回一个Promise对象，解析为数据库实例
   */
  async openDB() {
    return new Promise((resolve, reject) => {
      if(this.db === null) {
        this.request = window.indexedDB.open(this.dbName, this.dbVersion);

        this.request.onblocked = async (event) => {
          this.closeDB();
          const { error, db } = await this.reconnect();
          resolve({ error, db });
        };

        this.request.onupgradeneeded = async (event) => {
          console.log('数据库版本号从 ' + event.oldVersion + ' 升级到 ' + event.newVersion);
          /** @type {IDBDatabase} */
          const db = event.target.result;
          try {
            db.createObjectStore(M3U_STORE, { keyPath: "id" });
          } catch (error) {}

          try {
            db.createObjectStore(FAV_STORE, { keyPath: "id" });
          } catch (error) {}

          try {
            db.createObjectStore(STA_STORE, { keyPath: "id" });
          } catch (error) {}

          db.onversionchange = (event) => {
            console.log("The version of this database has changed");
          };
        };
        this.request.onsuccess = (event) => {
          this.db = event.target.result;
          this.db.onclose = (evt) => {
            console.log('The database has been closed');
            this.db = null;
          };
          resolve({ db: this.db });
        };

        this.request.onerror = async (event) => {
          const { error, db } = await this.reconnect();
          resolve({ error, db });
        };
      }
      else {
        resolve({ db: this.db });
      }
    });
  }

  /**
   * 添加数据到数据库
   * @param {Object} data - 要添加的数据对象
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise} - 返回一个Promise对象，解析为添加操作的结果
   */
  async addData(data, storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }

    const transaction = db.transaction(storeName, "readwrite"); // 创建事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.add(data); // 添加数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 读取数据库中的数据
   * @param {number} id - 数据的ID
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise<{ data: any, error: Error }>} - 返回一个Promise对象，解析为读取到的数据对象
   */
  async readData(id, storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readonly"); // 创建只读事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.get(id); // 获取数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 更新数据库中的数据
   * @param {Object} data - 要更新的数据对象
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise<{ data: any, error: Error }>} - 返回一个Promise对象，解析为更新操作的结果
   */
  async updateData(data, storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readwrite"); // 创建事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.put(data); // 更新数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 从数据库中删除数据
   * @param {number} id - 要删除的数据的ID
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise<{ data: any, error: Error }>} - 返回一个Promise对象，解析为删除操作的结果
   */
  async deleteData(id, storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readwrite"); // 创建事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.delete(id); // 删除数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 列出存储对象中的所有数据
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise<{ data: [], error: Error }>} - 返回一个Promise对象，解析为数据列表
   */
  async listData(storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readonly"); // 创建只读事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    let request = store.openCursor(); // 打开游标
    const list = []; // 保存数据列表
    return new Promise((resolve, reject) => {
      request.onsuccess = (evt) => {
        const cursor = evt.target.result; // 获取游标
        if (cursor) {
          list.push(cursor.value); // 将数据添加到列表中
          cursor.continue(); // 继续遍历
        } else {
          resolve({ data: list }); // 在遍历完成后，解析Promise为列表
        }
      };
      request.onerror = () => {
        resolve({ data: [], error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 清空存储对象中的所有数据
   * @param {string} storeName - 存储对象名称，默认为FAV_STORE
   * @returns {Promise} - 返回一个Promise对象，解析为清空操作的结果
   */
  async purgeData(storeName = FAV_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readwrite"); // 创建事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.clear(); // 清空数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 计算数据库中所有数据的总大小
   * @returns {Promise<{ totalSize: number, storeSize: Object.<string, number> }>} - 返回一个Promise对象，解析为包含总大小和各存储对象大小的对象
   */
  async totalSize() {
    let totalSize = 0; // 总大小
    let storeSize = {}; // 各存储对象大小
    try {
      const { db, error } = await this.openDB();
      if(db) {
        const transaction = db.transaction(db.objectStoreNames, "readonly"); // 创建只读事务
        const promises = [];
        for (const objectStoreName of db.objectStoreNames) { // 遍历所有存储对象
          const objectStore = transaction.objectStore(objectStoreName); // 获取存储对象
          storeSize[objectStoreName] = 0; // 初始化存储对象大小

          const getAllRequest = objectStore.getAll(); // 获取所有数据的请求
          promises.push(new Promise((resolve) => {
            getAllRequest.onsuccess = (event) => {
              const items = event.target.result; // 获取所有数据
              for (const item of items) {
                const size = new Blob([JSON.stringify(item)]).size; // 计算数据大小
                totalSize += size; // 累加到总大小
                storeSize[objectStoreName] += size; // 累加到存储对象大小
              }
              resolve();
            };
            getAllRequest.onerror = (event) => {
              resolve();
            };
          }));
        }
        await Promise.all(promises);
      }
    }
    catch(error) { }

    return { totalSize, storeSize };
  }

  /**
   * 将字符串编码为Base64格式
   * @param {string} plainText - 明文字符串
   * @returns {string} - Base64编码后的字符串
   */
  encodeString(plainText) {
    const base64Encoded = btoa(unescape(encodeURIComponent(plainText))); // 进行Base64编码
    return base64Encoded; // 返回编码后的字符串
  }

  /**
   * 将Base64编码的字符串解码为原始字符串
   * @param {string} encodedText - Base64编码的字符串
   * @returns {string} - 解码后的原始字符串
   */
  decodeString(encodedText) {
    const decodedText = decodeURIComponent(escape(atob(encodedText))); // 进行Base64解码
    return decodedText; // 返回解码后的字符串
  }
}

  </script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

  <style>
html, body {
  width: 100%;
  height: 100%;
  zoom: 1;
}
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0;
  color: #333;
  margin: 0;
  position: relative;
  overflow: hidden;
  align-items: center;
  background: url(background.jpeg) center center / cover no-repeat;
}
  .container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-flow: row;
    align-items: flex-start;
    margin: 0px;
    position: relative;
  }
  .container .video-container {
    flex: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    min-width: 300px;
    width: 100%;
    height: 100%;
    user-select: none;
    -webkit-user-select: none;
  }
    .container .video-container .video-wrapper {
      box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      width: 100%;
      max-height: 100%;
      min-width: 300px;
      height: auto;
      background-color: #333;
      position: relative;
      flex: none;
    }
    .play-list .container .video-container .video-wrapper {
      max-height: calc(100vh - 4rem);
    }
      .container #videoContainer {
        display: flex;
        width: 100%;
        flex: 1;
        margin: 0px;
        padding: 0px;
      }
      .container #videoContainer #videoPlayer {
        width: 100%;
        max-height: 100%;
        height: auto;
        z-index: 10;
      }
      .container .video-container .video-wrapper #frameVideo {
        width: 100%;
        max-height: 100%;
        height: auto;
        position: absolute;
        z-index: -1;
      }
    .container .video-container .bottom-controls {
      flex: 1;
      align-items: flex-start;
      display: flex;
      column-gap: 1rem;
      justify-content: flex-end;
      width: 100%;
      flex-flow: column;
      row-gap: 0.5rem;
      user-select: none;
      -webkit-user-select: none;
      overflow: auto;
    }
    .container .video-container .bottom-controls::-webkit-scrollbar {
      display: none;
    }
    .container .video-container .bottom-controls #errorControl {
      flex-flow: column;
    }
    .container .video-container .user-controls {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-flow: row;
      column-gap: 0.5rem;
      flex: 0 0;
    }
    .container #videoContainer #videoControls {
      position: absolute;
      bottom: 0px;
      left: 0px;
      width: 100%;
      background-color: rgba(0, 0, 0, 0.3);
      z-index: 20;
      padding: 0.5rem;
      box-sizing: border-box;
      opacity: 1;
      pointer-events: auto;
      transition: opacity 0.5s;
      flex-flow: column;
    }
      .container #videoContainer #videoControls.transparent {
        opacity: 0;
        pointer-events: none;
      }
      .container #videoContainer #videoControls button {
        flex: 0;
      }
      .container #videoContainer #videoControls .buttons {
        width: 100%;
        display: flex;
        justify-content: space-between;
        box-sizing: border-box;
        position: relative;
        padding: 0px;
        column-gap: 1rem;
      }
      .container #videoContainer #videoControls .buttons .group {
        display: flex;
        flex: 1;
        justify-content: flex-end;
      }

      .container #videoContainer #videoControls .buttons .divider {
        flex: 1;
      }
      .container #videoContainer #videoControls .progress {
        flex: 1;
        width: 100%;
        display: flex;
        column-gap: 0.3rem;
        align-items: center;
        justify-content: space-between;
        box-sizing: border-box;
        padding: 0.5rem;
      }
      .container #videoContainer #videoControls .progress #progressControl {
        width: 100%;
        flex: 1;
        height: 0.7rem;
      }
      .container #videoContainer #videoControls .progress #progressControl::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: #eee;
        cursor: ew-resize;
      }
      .container #videoContainer #videoControls .progress #progressControl::-moz-range-thumb {
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: #eee;
        cursor: ew-resize;
      }
      .container #videoContainer #videoControls .progress .time {
        color: #eee;
        text-align: center;
      }
      #pageBody.settings #videoContainer #videoControls {
        opacity: 0;
        pointer-events: none;
      }

    .container #playlistContainer {
      min-width: 300px;
      width: 100%;
      flex: 1;
      height: 100%;
      display: flex;
      z-index: 10;
      background: #ffffff99;
      box-shadow: 2px 0px 6px 1px #ccc;
      transition: all 0.2s;
    }
      #pageBody .container .player-interface {
        display: flex;
        flex: 1;
        width: 100%;
        height: 100%;
        z-index: 10;
      }
      #pageBody .container #m3uInputContainer {
        width: 100%;
        height: 100%;
        position: absolute;
        left: 0px;
        top: 0px;
        overflow: hidden;
        z-index: 0;
        justify-content: center;
        display: flex;
        align-items: center;
        background: #ffffffbd;
        transition: all 0.2s;
        z-index: -1;
      }
        #pageBody .container #m3uInputContainer .box {
          justify-content: flex-start;
          margin: 0px auto;
          max-height: 78%;
          flex: 0 0 78%;
          box-shadow: 0px 0px 4px #999;
          transition: all 0.3s;
          opacity: 0;
          border-radius: 6px;
        }

      #pageBody.settings .container #m3uInputContainer {
        width: 100%;
        z-index: 40;
      }
        #pageBody.settings .container #m3uInputContainer .box {
          flex: 0 0 80%;
          max-height: 80%;
          opacity: 1;
        }

    #pageBody.menu .container #playlistContainer {
      width: 0px;
      flex: 0 0;
      min-width: 0px;
      max-width: 0px;
      overflow: hidden;
    }

textarea, #searchInput, #searchButton, #clearButton, #closeButton, #m3uUrlInput,
#m3uContentKey, #settingsButton,
.m3u-controls #loadM3uButton, .m3u-controls #closeM3uButton {
  width: 100%;
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: 16px;
  appearance: none;
  box-sizing: border-box;
}
#m3uUrlInput {
  border-top-right-radius: 0px;
  border-bottom-right-radius: 0px;
  font-size: 14px;
}

#searchContainer, #playlistContent .top-buttons {
  margin-bottom: 10px;
}

#searchContainer {
  display: flex;
}
  #searchContainer .search {
    position: relative;
    flex: 1;
    display: flex;
  }
  #searchContainer #clearButton {
    position: absolute;
    right: 0px;
    top: 0px;
    background-color: transparent;
    width: auto;
    color: #999;
    flex: 1;
    padding: 0px 0.5rem;
    height: 100%;
    -webkit-appearance: none;
    appearance: none;
    border: 0px solid transparent;
    z-index: 10;
    border-radius: 0px;
  }
  #searchContainer #clearButton svg {
    background-color: white;
  }

#searchInput, #m3uUrlInput {
  padding: 12px;
}

#searchInput {
  flex-grow: 1;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

textarea:focus-visible,
input:focus-visible,
select:focus-visible {
  outline: 1px solid #ddd;
}

#searchButton {
  border-radius: 0px;
}

#searchButton, #closeButton, #settingsButton {
  width: auto;
  background-color: #3498db;
  color: white;
  border: none;
  cursor: pointer;
  white-space: nowrap;
}
#closeButton {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

#playlistContent .top-buttons #listCheckButton {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
  background-color: #db6634;
}

ul.menu-list {
  list-style-type: none;
  padding: 0px;
  margin: 0px;
  display: flex;
  flex-flow: column;
  flex: 1;
  row-gap: 0.3rem;
  justify-content: flex-start;
  overflow: auto;
  scrollbar-width: none;
  -ms-overflow-style: none;
}
  ul.menu-list::-webkit-scrollbar { 
    display: none;
  }

ul.menu-list li {
  cursor: pointer;
  background-color: #f1f1f1;
  border-radius: 0px;
  padding: 0px 0px 0px 0.5rem;
  height: 100%;
  min-height: 1.9rem;
  white-space: nowrap;
  overflow: hidden;
  overflow-y: hidden;
  text-overflow: ellipsis;
  display: flex;
  align-items: center;
  scrollbar-width: none;
  -ms-overflow-style: none;
  border-left: 3px solid gray;
  transition: 0.5s all;
  border-bottom: 1px solid #eee;
  user-select: none;
  -webkit-user-select: none;
  position: relative;
  background-position: -1rem center;
  padding: 0px;
  font-size: 0.8rem;
}
  ul.menu-list li::after {
    content: attr(data-duration);
    display: flex;
    font-size: 0.6rem;
    color: #555;
    text-align: right;
    justify-content: end;
    flex: 0;
    padding: 0.2rem;
    border-radius: 4px;
    width: auto;
  }
  ul.menu-list li.favorite::after {
    padding: 0.3rem;
  }
  ul.menu-list li::-webkit-scrollbar,
  ul.menu-list li label::-webkit-scrollbar {
    display: none;
  }
  ul.menu-list li.selected {
    background: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E') no-repeat 0.5rem center;
    border-left: 3px solid green;
    border-bottom: 1px solid green;
  }
  ul.menu-list li.good {
    border-left: 3px solid green;
  }
  ul.menu-list li.good.preview,
  ul.menu-list li.good:hover {
    border-bottom: 1px solid green;
  }
  ul.menu-list li.average {
    border-left: 3px solid orange;
  }
  ul.menu-list li.average.preview,
  ul.menu-list li.average:hover {
    border-bottom: 1px solid orange;
  }
  ul.menu-list li.bad {
    border-left: 3px solid red;
  }
  ul.menu-list li.bad.preview,
  ul.menu-list li.bad:hover {
    border-bottom: 1px solid red;
  }
  ul.menu-list li.favorite {
    box-shadow: inset -2px 0 1px 0px gray;
  }
  ul.menu-list li.active {
    font-weight: bold;
  }
  ul.menu-list li.broken {
    font-style: italic;
    color: #888;
    font-size: small;
    background: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkred%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M0%2010.5a.5.5%200%200%201%20.5-.5h15a.5.5%200%200%201%200%201H.5a.5.5%200%200%201-.5-.5M12%200H4a2%202%200%200%200-2%202v7h1V2a1%201%200%200%201%201-1h8a1%201%200%200%201%201%201v7h1V2a2%202%200%200%200-2-2m2%2012h-1v2a1%201%200%200%201-1%201H4a1%201%200%200%201-1-1v-2H2v2a2%202%200%200%200%202%202h8a2%202%200%200%200%202-2z%22%2F%3E%3C%2Fsvg%3E') no-repeat 0.5rem center;
  }
  ul.menu-list li.timeout {
    color: #888;
    font-size: small;
    background: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22gray%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%203.5a.5.5%200%200%200-1%200V9a.5.5%200%200%200%20.252.434l3.5%202a.5.5%200%200%200%20.496-.868L8%208.71z%22%2F%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016m7-8A7%207%200%201%201%201%208a7%207%200%200%201%2014%200%22%2F%3E%3C%2Fsvg%3E') no-repeat 0.5rem center;
  }
  ul.menu-list li.broken:hover {
    border-bottom: 1px solid black;
    background-color: white;
  }
  ul.menu-list li.frame {
    background: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M6.002%205.5a1.5%201.5%200%201%201-3%200%201.5%201.5%200%200%201%203%200%22%2F%3E%3Cpath%20d%3D%22M2.002%201a2%202%200%200%200-2%202v10a2%202%200%200%200%202%202h12a2%202%200%200%200%202-2V3a2%202%200%200%200-2-2zm12%201a1%201%200%200%201%201%201v6.5l-3.777-1.947a.5.5%200%200%200-.577.093l-3.71%203.71-2.66-1.772a.5.5%200%200%200-.63.062L1.002%2012V3a1%201%200%200%201%201-1z%22%2F%3E%3C%2Fsvg%3E') no-repeat 0.5rem center;
  }
  ul.menu-list li.preview {
    background: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E') no-repeat 0.5rem center;
  }
  ul.menu-list li.preview.active {
    background: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M10.804%208%205%204.633v6.734zm.792-.696a.802.802%200%200%201%200%201.392l-6.363%203.692C4.713%2012.69%204%2012.345%204%2011.692V4.308c0-.653.713-.998%201.233-.696z%22%2F%3E%3C%2Fsvg%3E') no-repeat 0.5rem center;
  }
  ul.menu-list li.checking {
    color: #5c5c5c;
    border-left-color: #000;
    font-size: 0.8rem;
    background: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%23666%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M2%201.5a.5.5%200%200%201%20.5-.5h11a.5.5%200%200%201%200%201h-1v1a4.5%204.5%200%200%201-2.557%204.06c-.29.139-.443.377-.443.59v.7c0%20.213.154.451.443.59A4.5%204.5%200%200%201%2012.5%2013v1h1a.5.5%200%200%201%200%201h-11a.5.5%200%201%201%200-1h1v-1a4.5%204.5%200%200%201%202.557-4.06c.29-.139.443-.377.443-.59v-.7c0-.213-.154-.451-.443-.59A4.5%204.5%200%200%201%203.5%203V2h-1a.5.5%200%200%201-.5-.5m2.5.5v1a3.5%203.5%200%200%200%201.989%203.158c.533.256%201.011.791%201.011%201.491v.702c0%20.7-.478%201.235-1.011%201.491A3.5%203.5%200%200%200%204.5%2013v1h7v-1a3.5%203.5%200%200%200-1.989-3.158C8.978%209.586%208.5%209.052%208.5%208.351v-.702c0-.7.478-1.235%201.011-1.491A3.5%203.5%200%200%200%2011.5%203V2z%22%2F%3E%3C%2Fsvg%3E') no-repeat 0.5rem center;
  }
  ul.menu-list li:nth-of-type(even) {
    background-color: transparent;
  }
  ul.menu-list li.frame:nth-of-type(even) {
    background-color: rgba(255, 255, 255, 0.55);
  }
  ul.menu-list li.frame:hover,
  ul.menu-list li:hover {
    background-color: #cceeee5c;
    border-bottom: 1px solid black;
  }
  ul.menu-list li label {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    flex: 1;
    overflow: auto;
    margin: 0px 0.5rem;
    cursor: pointer;
    transition: 0.5s all;
  }
  ul.menu-list li.selected label,
  ul.menu-list li.timeout label,
  ul.menu-list li.broken label,
  ul.menu-list li.checking label,
  ul.menu-list li.frame label,
  ul.menu-list li.preview label {
    margin: 0px 0.3rem 0px 2rem;
  }
  ul.menu-list li label i {
    font-style: normal;
    width: 100%;
    user-select: none;
    -webkit-user-select: none;
  }
  ul.menu-list li .delete {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: absolute;
    right: 0;
    width: 3rem;
    flex: 0;
    height: 100%;
  }

button {
  user-select: none;
  -webkit-user-select: none;
  padding: 10px 20px;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  white-space: nowrap;
  display: flex;
  align-items: center;
  justify-content: center;
}

#errorControl #errorMessage {
  color: #e74c3c;
  text-align: center;
  flex: 1;
  width: 100%;
}
#errorControl #statisticsMessage {
  text-align: right;
  width: 100%;
  font-size: 0.8rem;
  color: gray;
  font-style: italic;
  display: flex;
  justify-content: flex-end;
}

#settingsButton {
  background-color: #606060;
}

#reCaptureButton {
  background-color: darkorchid;
}
#favoriteButton {
  background-color: lightslategrey;
}
  #favoriteButton.remove {
    background-color: #cc2e68;
  }
#dislikeButton {
  background-color: lightslategrey;
}
  #dislikeButton.remove {
    background-color: #cc2e68;
  }

#playListButton {
  background-color: #2e6bcc;
}
#fullscreenButton {
  background-color: darkslateblue;
}
#playVideoButton {
  background-color: blueviolet;
}
#speakerButton {
  background-color: rgb(43, 89, 226);
}
#playVideoButton.playing {
  background-color: darkmagenta;
}
#playVideoButton.played {
  background-color: #e74c3c;
}
#pinButton.pinned {
  background-color: orange;
}

#m3uList {
  display: flex;
  column-gap: 1rem;
  flex-flow: column;
  padding: 0.5rem 0.8rem;
  scrollbar-width: none;
  -ms-overflow-style: none;
}
#m3uList::-webkit-scrollbar {
  display: none;
}

#m3uList div {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-top: 1px solid #ccc;
}
  #m3uList div.active {
    background-color: #fff;
  }
#m3uList div a {
  cursor: pointer;
  padding: 0.5rem 0.8rem;
  border-radius: 4px;
  cursor: pointer;
    padding: 0.5rem 0.8rem;
    border-radius: 4px;
    display: flex;
    height: 100%;
    align-items: center;
    box-sizing: border-box;
    justify-content: flex-start;
    margin: 2px 0px;
}
  #m3uList div a:hover {
    background-color: #eee;
  }
  #m3uList div a.load {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 0.85rem;
  }
    #m3uList div::before {
      content: attr(title);
      font-size: 0.75rem;
      padding: 0.5rem 0.8rem;
      width: 4rem;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }
  #m3uList div a.delete {
    color: #e74c3c;
    opacity: 0.6;
    transition: all 1s;
  }
  #m3uList div a.refresh {
    color: #5c5c5c;
    transition: all 1s;
  }
  #m3uList div a.refresh.disabled {
    opacity: 0.2;
  }
  #m3uList div a.ready,
  #m3uList div a.delete:hover {
    background-color: #e74c3c;
    color: white;
    opacity: 1;
  }
#m3uContentKey {
  margin-top: 1rem;
}

#playlistContent {
  display: flex;
  flex-flow: column;
  height: 100%;
}
#playlistContent .top-buttons {
  display: flex;
  justify-content: space-between;
  flex: 0;
}
#playlistContent .top-buttons #channelButton {
  flex: 1;
  border-radius: 0;
}
#playlistContent .top-buttons #closeButton,
#playlistContent .top-buttons #listCheckButton {
  background-color: #3471db;
}
  #playlistContent .top-buttons #listCheckButton.checking {
    background-color: #db6634;
  }
  #playlistContent .page-controls {
    flex: 0 0;
    user-select: none;
    -webkit-user-select: none;
  }
  #playlistContent .page-controls #pagination {
    display: flex;
    justify-content: space-between;
    align-items: center;
    column-gap: 1rem;
    flex: 0;
    width: 100%;
    margin-top: 14px;
  }
  #playlistContent .page-controls #pagination button, .user-controls button {
    flex: 1;
  }
  #playlistContent .page-controls #pagination button {
    font-size: 16px;
    flex: 0;
    background-color: lightslategrey;
  }
  #playlistContent .page-controls #pagination #pageInfo {
    font-size: 16px;
    white-space: nowrap;
    width: 100%;
    flex: 0;
    text-align: center;
  }

.box {
  display: flex;
  flex-flow: column;
  width: 100%;
  flex: 1;
  position: relative;
  background-color: rgba(237, 237, 237, 0.85);
  border-radius: 0px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  box-sizing: border-box;
  overflow: auto;
  padding: 0.5rem;
  column-gap: 0.6rem;
  row-gap: 0.6rem;
  scrollbar-width: none;
  -ms-overflow-style: none;
  height: 100%;
  justify-content: space-between;
}
.box::-webkit-scrollbar { 
  display: none;
}

.range {
  appearance: none;
  width: 100%;
  height: 15px;
  border-radius: 5px;  
  background: #b5b5b5;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

/* Mouse-over effects */
.range:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.range::-webkit-slider-thumb {
  appearance: none;
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #4682b4;
  cursor: pointer;
}

.range::-moz-range-thumb {
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #04AA6D;
  cursor: pointer;
}

.m3u-controls {
  display: flex;
  flex-flow: row;
  align-items: center;
  justify-content: flex-end;
  padding: 0.5rem;
}
  .m3u-controls #closeM3uButton {
    background-color: #db6634;
    border-top-left-radius: 0px;
    border-bottom-left-radius: 0px;
  }
  .m3u-controls #loadM3uButton,
  .m3u-controls #closeM3uButton {
    width: auto;
    border: 0px;
  }

  .m3u-controls #loadM3uButton {
    background-color: #3498db;
    color: white;
    border: 0px;
    cursor: pointer;
    border-radius: 0px;
    font-size: 14px;
  }

.page-information {
  flex: 1;
}

.tools {
  display: flex;
  padding: 0.5rem 0.8rem;
  align-items: flex-start;
  justify-content: center;
  flex-flow: column;
  user-select: none;
}

  .tools #databaseSize {
    border-radius: 4px;
  }
  .tools #databaseCategories {
    display: flex;
    column-gap: 0.5rem;
    row-gap: 0.5rem;
    justify-content: space-evenly;
    align-items: center;
    width: 100%;
    flex: 1;
    flex-wrap: wrap;
  }
  .tools #databaseCategories button {
    flex: 1;
    background-color: darkred;
    font-size: 0.9rem;
  }
  .tools .debug {
    border: 1px solid #ccc;
    flex: 1;
    display: flex;
    box-sizing: border-box;
    width: 100%;
    padding: 0.5rem;
    position: relative;
    user-select: all;
  }
  .tools .debug #debugLogs {
    width: 100%;
    resize: vertical;
    flex: 1;
    white-space: pre-wrap;
    line-height: 1.2;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  .tools .debug #debugLogs::-webkit-scrollbar {
    display: none;
  }
  .tools .debug #logClearButton {
    position: absolute;
    right: 0.5rem;
    top: 0.5rem;
    background-color: #e74c3c;
    padding: 0.2rem;
    border-radius: 4px;
    cursor: pointer;
    opacity: 0.6;
  }
.settings-usage {
  row-gap: 0.5rem;
}
button:disabled {
  background-color: #bdc3c7 !important;
  color: #eee;
}

.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 0.5rem 0px;
  column-gap: 1rem;
  border-bottom: 1px solid #777;
  margin-top: -1px;
  border-top: 1px solid #777;
}
.settings-row .label {
  width: 100%;
  flex: 1;
  white-space: nowrap;
  align-items: center;
  display: flex;
  height: 34px;
}
/* The switch - the box around the slider */
.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

/* Hide default HTML checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* The slider */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(26px);
  -ms-transform: translateX(26px);
  transform: translateX(26px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}

@media (min-width: 768px) {
  #videoPlayer {
    width: 640px;
  }

  #playlistContainer {
    width: 640px;
  }
}

/* iPhone Portrait */
@media only screen and (max-width: 812px) and (orientation: portrait)
{
  .container #playlistContainer {
    position: absolute;
    z-index: 30;
    top: 0px;
    left: 0px;
  }
  #pageBody.settings .container #m3uInputContainer .box {
    flex: 1;
    max-height: 100%;
  }
  .container #commentsLayout, .container #bottomControls {
    display: flex;
  }
}
@media only screen and (max-width: 965px) {
  .container #videoContainer #videoControls .buttons {
    column-gap: 0.5rem; 
  }
  .container #videoContainer #videoControls .buttons button {
    border-radius: 4px;
    padding: 0.5rem 0.7rem;
  }
}

@media only screen and (max-width: 300px) {
  #bottomButtons {
    column-gap: 0.5rem; 
  }
  #bottomButtons button {
    border-radius: 4px;
    padding: 0.5rem 0.7rem;
  }
}

.hidden {
  display: none !important;
}

#commentsLayout {
  display: flex;
  width: 100%;
  flex-flow: column;
  overflow: auto;
  flex: 1;
}

.play-list #bottomControls {
  display: flex;
  justify-content: flex-start;
}
#commentsLayout .comments-form {
  display: flex;
  width: 100%;
  flex: 0;
}
#commentsLayout .comments-container {
  width: 100%;
  row-gap: 0;
  display: flex;
  flex-flow: column;
  overflow: auto;
  flex: 1;
}
#commentsLayout .comments-container .comment {
  display: flex;
  width: 100%;
  flex-flow: column;
  align-items: flex-start;
  justify-content: space-between;
  padding: 0.5rem;
  border-radius: 4px;
  box-sizing: border-box;
}
  #commentsLayout .comments-container .comment:nth-of-type(even) {
    background: #f2f2f286;
  }
  #commentsLayout .comments-container .comment .time {
    font-size: 0.8rem;
    color: gray;
  }

  #commentsLayout .comments-form input {
    padding: 0.5rem;
    background: #ffffff80;
    border-radius: 4px;
    outline: none;
    transition: all 0.2s ease-in-out;
    border: 0px;
  }
  #commentsLayout .comments-form #commentsInput {
    flex: 1;
    border-top-right-radius: 0px;
    border-bottom-right-radius: 0px;
  }
  #commentsLayout .comments-form #commentsButton {
    border-top-left-radius: 0px;
    border-bottom-left-radius: 0px;
  }
  
  </style>
</head>

<body id="pageBody">
  <svg xmlns="http://www.w3.org/2000/svg" class="hidden">
    <!-- PLAY -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="play" viewBox="0 0 16 16">
      <path d="M10.804 8 5 4.633v6.734zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696z"/>
    </symbol>
    <!-- STOP -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="stop" viewBox="0 0 16 16">
      <path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5"/>
    </symbol>
    <!-- CANCEL -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="cancel" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0M5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293z"/>
    </symbol>
    <!-- FULLSCREEN -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="fullscreen" viewBox="0 0 16 16">
      <path d="M5.5 0a.5.5 0 0 1 .5.5v4A1.5 1.5 0 0 1 4.5 6h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5m5 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 10 4.5v-4a.5.5 0 0 1 .5-.5M0 10.5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 6 11.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5m10 1a1.5 1.5 0 0 1 1.5-1.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0z"/>
    </symbol>
    <!-- REWIND -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="rewind" viewBox="0 0 16 16">
      <path d="M9.196 8 15 4.633v6.734zm-.792-.696a.802.802 0 0 0 0 1.392l6.363 3.692c.52.302 1.233-.043 1.233-.696V4.308c0-.653-.713-.998-1.233-.696z"/>
      <path d="M1.196 8 7 4.633v6.734zm-.792-.696a.802.802 0 0 0 0 1.392l6.363 3.692c.52.302 1.233-.043 1.233-.696V4.308c0-.653-.713-.998-1.233-.696z"/>
    </symbol>
    <!-- FORWARD -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="forward" viewBox="0 0 16 16">
      <path d="M6.804 8 1 4.633v6.734zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C.713 12.69 0 12.345 0 11.692V4.308c0-.653.713-.998 1.233-.696z"/>
      <path d="M14.804 8 9 4.633v6.734zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C8.713 12.69 8 12.345 8 11.692V4.308c0-.653.713-.998 1.233-.696z"/>
    </symbol>
    <!-- SETTINGS - GEAR -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="gear" viewBox="0 0 16 16">
      <path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492M5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0"/>
      <path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52zm-2.633.283c.246-.835 1.428-.835 1.674 0l.094.319a1.873 1.873 0 0 0 2.693 1.115l.291-.16c.764-.415 1.6.42 1.184 1.185l-.159.292a1.873 1.873 0 0 0 1.116 2.692l.318.094c.835.246.835 1.428 0 1.674l-.319.094a1.873 1.873 0 0 0-1.115 2.693l.16.291c.415.764-.42 1.6-1.185 1.184l-.291-.159a1.873 1.873 0 0 0-2.693 1.116l-.094.318c-.246.835-1.428.835-1.674 0l-.094-.319a1.873 1.873 0 0 0-2.692-1.115l-.292.16c-.764.415-1.6-.42-1.184-1.185l.159-.291A1.873 1.873 0 0 0 1.945 8.93l-.319-.094c-.835-.246-.835-1.428 0-1.674l.319-.094A1.873 1.873 0 0 0 3.06 4.377l-.16-.292c-.415-.764.42-1.6 1.185-1.184l.292.159a1.873 1.873 0 0 0 2.692-1.115z"/>
    </symbol>
    <!-- LIST CHECK -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="list-check" viewBox="0 0 16 16">
      <path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
      <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
    </symbol>
    <!-- FAVORITE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="favorite" viewBox="0 0 16 16">
      <path d="M8.864.046C7.908-.193 7.02.53 6.956 1.466c-.072 1.051-.23 2.016-.428 2.59-.125.36-.479 1.013-1.04 1.639-.557.623-1.282 1.178-2.131 1.41C2.685 7.288 2 7.87 2 8.72v4.001c0 .845.682 1.464 1.448 1.545 1.07.114 1.564.415 2.068.723l.048.03c.272.165.578.348.97.484.397.136.861.217 1.466.217h3.5c.937 0 1.599-.477 1.934-1.064a1.86 1.86 0 0 0 .254-.912c0-.152-.023-.312-.077-.464.201-.263.38-.578.488-.901.11-.33.172-.762.004-1.149.069-.13.12-.269.159-.403.077-.27.113-.568.113-.857 0-.288-.036-.585-.113-.856a2 2 0 0 0-.138-.362 1.9 1.9 0 0 0 .234-1.734c-.206-.592-.682-1.1-1.2-1.272-.847-.282-1.803-.276-2.516-.211a10 10 0 0 0-.443.05 9.4 9.4 0 0 0-.062-4.509A1.38 1.38 0 0 0 9.125.111zM11.5 14.721H8c-.51 0-.863-.069-1.14-.164-.281-.097-.506-.228-.776-.393l-.04-.024c-.555-.339-1.198-.731-2.49-.868-.333-.036-.554-.29-.554-.55V8.72c0-.254.226-.543.62-.65 1.095-.3 1.977-.996 2.614-1.708.635-.71 1.064-1.475 1.238-1.978.243-.7.407-1.768.482-2.85.025-.362.36-.594.667-.518l.262.066c.16.04.258.143.288.255a8.34 8.34 0 0 1-.145 4.725.5.5 0 0 0 .595.644l.003-.001.014-.003.058-.014a9 9 0 0 1 1.036-.157c.663-.06 1.457-.054 2.11.164.175.058.45.3.57.65.107.308.087.67-.266 1.022l-.353.353.353.354c.043.043.105.141.154.315.048.167.075.37.075.581 0 .212-.027.414-.075.582-.05.174-.111.272-.154.315l-.353.353.353.354c.047.047.109.177.005.488a2.2 2.2 0 0 1-.505.805l-.353.353.353.354c.006.005.041.05.041.17a.9.9 0 0 1-.121.416c-.165.288-.503.56-1.066.56z"/>
    </symbol>
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="unfavorite" viewBox="0 0 16 16">
      <path d="M6.956 1.745C7.021.81 7.908.087 8.864.325l.261.066c.463.116.874.456 1.012.965.22.816.533 2.511.062 4.51a10 10 0 0 1 .443-.051c.713-.065 1.669-.072 2.516.21.518.173.994.681 1.2 1.273.184.532.16 1.162-.234 1.733q.086.18.138.363c.077.27.113.567.113.856s-.036.586-.113.856c-.039.135-.09.273-.16.404.169.387.107.819-.003 1.148a3.2 3.2 0 0 1-.488.901c.054.152.076.312.076.465 0 .305-.089.625-.253.912C13.1 15.522 12.437 16 11.5 16H8c-.605 0-1.07-.081-1.466-.218a4.8 4.8 0 0 1-.97-.484l-.048-.03c-.504-.307-.999-.609-2.068-.722C2.682 14.464 2 13.846 2 13V9c0-.85.685-1.432 1.357-1.615.849-.232 1.574-.787 2.132-1.41.56-.627.914-1.28 1.039-1.639.199-.575.356-1.539.428-2.59z"/>
    </symbol>
    <!-- DISLIKE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="dislike" viewBox="0 0 16 16">
      <path d="M8.864 15.674c-.956.24-1.843-.484-1.908-1.42-.072-1.05-.23-2.015-.428-2.59-.125-.36-.479-1.012-1.04-1.638-.557-.624-1.282-1.179-2.131-1.41C2.685 8.432 2 7.85 2 7V3c0-.845.682-1.464 1.448-1.546 1.07-.113 1.564-.415 2.068-.723l.048-.029c.272-.166.578-.349.97-.484C6.931.08 7.395 0 8 0h3.5c.937 0 1.599.478 1.934 1.064.164.287.254.607.254.913 0 .152-.023.312-.077.464.201.262.38.577.488.9.11.33.172.762.004 1.15.069.13.12.268.159.403.077.27.113.567.113.856s-.036.586-.113.856c-.035.12-.08.244-.138.363.394.571.418 1.2.234 1.733-.206.592-.682 1.1-1.2 1.272-.847.283-1.803.276-2.516.211a10 10 0 0 1-.443-.05 9.36 9.36 0 0 1-.062 4.51c-.138.508-.55.848-1.012.964zM11.5 1H8c-.51 0-.863.068-1.14.163-.281.097-.506.229-.776.393l-.04.025c-.555.338-1.198.73-2.49.868-.333.035-.554.29-.554.55V7c0 .255.226.543.62.65 1.095.3 1.977.997 2.614 1.709.635.71 1.064 1.475 1.238 1.977.243.7.407 1.768.482 2.85.025.362.36.595.667.518l.262-.065c.16-.04.258-.144.288-.255a8.34 8.34 0 0 0-.145-4.726.5.5 0 0 1 .595-.643h.003l.014.004.058.013a9 9 0 0 0 1.036.157c.663.06 1.457.054 2.11-.163.175-.059.45-.301.57-.651.107-.308.087-.67-.266-1.021L12.793 7l.353-.354c.043-.042.105-.14.154-.315.048-.167.075-.37.075-.581s-.027-.414-.075-.581c-.05-.174-.111-.273-.154-.315l-.353-.354.353-.354c.047-.047.109-.176.005-.488a2.2 2.2 0 0 0-.505-.804l-.353-.354.353-.354c.006-.005.041-.05.041-.17a.9.9 0 0 0-.121-.415C12.4 1.272 12.063 1 11.5 1"/>
    </symbol>
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="undislike" viewBox="0 0 16 16">
      <path d="M6.956 14.534c.065.936.952 1.659 1.908 1.42l.261-.065a1.38 1.38 0 0 0 1.012-.965c.22-.816.533-2.512.062-4.51q.205.03.443.051c.713.065 1.669.071 2.516-.211.518-.173.994-.68 1.2-1.272a1.9 1.9 0 0 0-.234-1.734c.058-.118.103-.242.138-.362.077-.27.113-.568.113-.856 0-.29-.036-.586-.113-.857a2 2 0 0 0-.16-.403c.169-.387.107-.82-.003-1.149a3.2 3.2 0 0 0-.488-.9c.054-.153.076-.313.076-.465a1.86 1.86 0 0 0-.253-.912C13.1.757 12.437.28 11.5.28H8c-.605 0-1.07.08-1.466.217a4.8 4.8 0 0 0-.97.485l-.048.029c-.504.308-.999.61-2.068.723C2.682 1.815 2 2.434 2 3.279v4c0 .851.685 1.433 1.357 1.616.849.232 1.574.787 2.132 1.41.56.626.914 1.28 1.039 1.638.199.575.356 1.54.428 2.591"/>
    </symbol>
    <!-- LIST CHECK -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="list" viewBox="0 0 16 16">
      <path d="M12 13c0 1.105-1.12 2-2.5 2S7 14.105 7 13s1.12-2 2.5-2 2.5.895 2.5 2"/>
      <path d="M12 3v10h-1V3z"/>
      <path d="M11 2.82a1 1 0 0 1 .804-.98l3-.6A1 1 0 0 1 16 2.22V4l-5 1z"/>
      <path d="M0 11.5a.5.5 0 0 1 .5-.5H4a.5.5 0 0 1 0 1H.5a.5.5 0 0 1-.5-.5m0-4A.5.5 0 0 1 .5 7H8a.5.5 0 0 1 0 1H.5a.5.5 0 0 1-.5-.5m0-4A.5.5 0 0 1 .5 3H8a.5.5 0 0 1 0 1H.5a.5.5 0 0 1-.5-.5"/>
    </symbol>
    <!-- CLOSE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="close" viewBox="0 0 16 16">
      <path d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0"/>
    </symbol>
    <!-- SEARCH -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="search" viewBox="0 0 16 16">
      <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
    </symbol>
    <!-- RESET -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="reset" viewBox="0 0 16 16">
      <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708"/>
    </symbol>
    <!-- MUTE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="mute" viewBox="0 0 16 16">
      <path d="M9 4a.5.5 0 0 0-.812-.39L5.825 5.5H3.5A.5.5 0 0 0 3 6v4a.5.5 0 0 0 .5.5h2.325l2.363 1.89A.5.5 0 0 0 9 12zM6.312 6.39 8 5.04v5.92L6.312 9.61A.5.5 0 0 0 6 9.5H4v-3h2a.5.5 0 0 0 .312-.11M12.025 8a4.5 4.5 0 0 1-1.318 3.182L10 10.475A3.5 3.5 0 0 0 11.025 8 3.5 3.5 0 0 0 10 5.525l.707-.707A4.5 4.5 0 0 1 12.025 8"/>
    </symbol>
    <!-- UNMUTE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="unmute" viewBox="0 0 16 16">
      <path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06M6 5.04 4.312 6.39A.5.5 0 0 1 4 6.5H2v3h2a.5.5 0 0 1 .312.11L6 10.96zm7.854.606a.5.5 0 0 1 0 .708L12.207 8l1.647 1.646a.5.5 0 0 1-.708.708L11.5 8.707l-1.646 1.647a.5.5 0 0 1-.708-.708L10.793 8 9.146 6.354a.5.5 0 1 1 .708-.708L11.5 7.293l1.646-1.647a.5.5 0 0 1 .708 0"/>
    </symbol>
    <!-- READ FROM URL -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="read-from-url" viewBox="0 0 16 16">
      <path d="M11 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8M6.025 7.5a5 5 0 1 1 0 1H4A1.5 1.5 0 0 1 2.5 10h-1A1.5 1.5 0 0 1 0 8.5v-1A1.5 1.5 0 0 1 1.5 6h1A1.5 1.5 0 0 1 4 7.5zM11 5a.5.5 0 0 1 .5.5v2h2a.5.5 0 0 1 0 1h-2v2a.5.5 0 0 1-1 0v-2h-2a.5.5 0 0 1 0-1h2v-2A.5.5 0 0 1 11 5M1.5 7a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5z"/>
    </symbol>
    <!-- UPDATE FROM URL -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="update-from-url" viewBox="0 0 16 16">
      <path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
      <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
    </symbol>
    <!-- PAUSE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="pause" viewBox="0 0 16 16">
      <path d="M6 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5m4 0a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5"/>
    </symbol>
    <!-- UNPAUSE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="unpause" viewBox="0 0 16 16">
      <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>
      <path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445"/>
    </symbol>
    <!-- PIN -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="pin" viewBox="0 0 16 16">
      <path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5c0 .276-.224 1.5-.5 1.5s-.5-1.224-.5-1.5V10h-4a.5.5 0 0 1-.5-.5c0-.973.64-1.725 1.17-2.189A6 6 0 0 1 5 6.708V2.277a3 3 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354m1.58 1.408-.002-.001zm-.002-.001.002.001A.5.5 0 0 1 6 2v5a.5.5 0 0 1-.276.447h-.002l-.012.007-.054.03a5 5 0 0 0-.827.58c-.318.278-.585.596-.725.936h7.792c-.14-.34-.407-.658-.725-.936a5 5 0 0 0-.881-.61l-.012-.006h-.002A.5.5 0 0 1 10 7V2a.5.5 0 0 1 .295-.458 1.8 1.8 0 0 0 .351-.271c.08-.08.155-.17.214-.271H5.14q.091.15.214.271a1.8 1.8 0 0 0 .37.282"/>
    </symbol>
    <!-- UNPIN -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="unpin" viewBox="0 0 16 16">
      <path d="M9.828.722a.5.5 0 0 1 .354.146l4.95 4.95a.5.5 0 0 1 0 .707c-.48.48-1.072.588-1.503.588-.177 0-.335-.018-.46-.039l-3.134 3.134a6 6 0 0 1 .16 1.013c.046.702-.032 1.687-.72 2.375a.5.5 0 0 1-.707 0l-2.829-2.828-3.182 3.182c-.195.195-1.219.902-1.414.707s.512-1.22.707-1.414l3.182-3.182-2.828-2.829a.5.5 0 0 1 0-.707c.688-.688 1.673-.767 2.375-.72a6 6 0 0 1 1.013.16l3.134-3.133a3 3 0 0 1-.04-.461c0-.43.108-1.022.589-1.503a.5.5 0 0 1 .353-.146m.122 2.112v-.002zm0-.002v.002a.5.5 0 0 1-.122.51L6.293 6.878a.5.5 0 0 1-.511.12H5.78l-.014-.004a5 5 0 0 0-.288-.076 5 5 0 0 0-.765-.116c-.422-.028-.836.008-1.175.15l5.51 5.509c.141-.34.177-.753.149-1.175a5 5 0 0 0-.192-1.054l-.004-.013v-.001a.5.5 0 0 1 .12-.512l3.536-3.535a.5.5 0 0 1 .532-.115l.096.022c.087.017.208.034.344.034q.172.002.343-.04L9.927 2.028q-.042.172-.04.343a1.8 1.8 0 0 0 .062.46z"/>
    </symbol>
    <!-- CHANNEL -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="channel" viewBox="0 0 16 16">
      <path d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5M3.854 2.146a.5.5 0 0 1 0 .708l-1.5 1.5a.5.5 0 0 1-.708 0l-.5-.5a.5.5 0 1 1 .708-.708L2 3.293l1.146-1.147a.5.5 0 0 1 .708 0m0 4a.5.5 0 0 1 0 .708l-1.5 1.5a.5.5 0 0 1-.708 0l-.5-.5a.5.5 0 1 1 .708-.708L2 7.293l1.146-1.147a.5.5 0 0 1 .708 0m0 4a.5.5 0 0 1 0 .708l-1.5 1.5a.5.5 0 0 1-.708 0l-.5-.5a.5.5 0 0 1 .708-.708l.146.147 1.146-1.147a.5.5 0 0 1 .708 0"/>
    </symbol>
  </svg>

  <div class="container" id="pageContainer">
    <div id="m3uInputContainer">
      <div class="box">
        <div class="m3u-controls">
          <input type="url" id="m3uUrlInput" required placeholder="输入 M3U 文件 URL">
          <button id="loadM3uButton"><svg width="20" height="20"><use xlink:href="#read-from-url"/></svg></button>
          <button id="closeM3uButton"><svg width="20" height="20"><use xlink:href="#close"/></svg></button>
        </div>
  
        <div id="m3uList"></div>
  
        <div class="tools">
          <div class="settings-row">
            <label class="label">自动检查可用性</label>
            <label class="switch">
              <input type="checkbox" id="autoCheckCheckbox">
              <span class="slider"></span>
            </label>
          </div>
  
          <div class="settings-row">
            <label class="label">检查缩略图</label>
            <label class="switch">
              <input type="checkbox" id="storeFrameCheckbox">
              <span class="slider"></span>
            </label>
          </div>
  
          <div class="settings-row">
            <label class="label">截图时间 (<span id="screenshotTimeDisplay">0</span>s)</label>
            <input type="range" id="screenshotTime" class="range" min="1" max="300" step="1">
          </div>
  
          <div class="settings-row">
            <label class="label">跳过可用缩略图</label>
            <label class="switch">
              <input type="checkbox" id="onlyCheckBrokenCheckbox">
              <span class="slider"></span>
            </label>
          </div>
  
          <div class="settings-row">
            <label class="label">播放时静音</label>
            <label class="switch">
              <input type="checkbox" id="muteWhenPlayCheckbox">
              <span class="slider"></span>
            </label>
          </div>
  
          <div class="settings-row">
            <label class="label">检查超时 (<span id="checkTimeoutDisplay">0</span>ms)</label>
            <input type="range" id="checkTimeout" class="range" min="5" max="60" step="1">
          </div>
  
          <div class="settings-row settings-usage hidden">
            <label class="label">数据使用情况</label>
            <div id="databaseSize"></div>
          </div>
  
          <div class="settings-row settings-usage hidden">
            <div id="databaseCategories"></div>
          </div>
  
          <div class="settings-row">
            <label class="label">启用日志</label>
            <label class="switch">
              <input type="checkbox" id="enableLoggingCheckbox">
              <span class="slider"></span>
            </label>
          </div>
        </div>
  
        <div id="logContainer" class="tools hidden">
          <div class="debug">
            <button id="logClearButton" class="hidden"><svg width="20" height="20"><use xlink:href="#reset"/></svg></button>
            <code id="debugLogs">&gt; 日志</code>
          </div>
        </div>
  
      </div>
    </div>
    <div class="player-interface">
      <div id="playlistContainer">
        <div class="box">
          <div id="playlistContent">
            <div class="top-buttons">
              <button type="button" id="closeButton"><svg width="20" height="20"><use xlink:href="#close"/></svg></button>
              <button type="button" id="channelButton">请稍候...</button>
              <button id="listCheckButton" data-checking="false"><svg width="20" height="20"><use xlink:href="#list-check"/></svg></button>
            </div>

            <form id="searchContainer">
              <div class="search">
                <input type="text" id="searchInput" required placeholder="搜索...">
                <button type="reset" id="clearButton" class="hidden"><svg width="20" height="20"><use xlink:href="#reset"/></svg></button>
              </div>
              <button type="submit" id="searchButton" class="hidden"><svg width="20" height="20"><use xlink:href="#search"/></svg></button>
            </form>

            <ul id="channelList" class="menu-list hidden"></ul>
            <ul id="playlistItems" class="menu-list"></ul>

            <div class="page-controls">
              <div id="pagination">
                <button id="prevPage" disabled>上页</button>
                <div class="page-information">
                  <input id="pageControl" class="range" min="1" type="range">
                  <div id="pageInfo"></div>
                </div>
                <button id="nextPage" disabled>下页</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="video-container">
        <div class="box">
          <div class="video-wrapper">

            <figure id="videoContainer">
              <video id="videoPlayer" playsinline poster="background.jpeg"></video>
              <div id="videoControls" class="user-controls controls transparent">
                <div class="buttons">
                  <button id="playVideoButton" disabled class="stopped"><svg width="20" height="20"><use xlink:href="#play"/></svg></button>
                  <button id="pauseVideoButton" class="hidden"><svg width="20" height="20"><use xlink:href="#pause"/></svg></button>
                  <div class="divider"></div>
                  <button id="pinButton"><svg width="20" height="20"><use xlink:href="#unpin"/></svg></button>
                  <button id="speakerButton"><svg width="20" height="20"><use xlink:href="#mute"/></svg></button>
                  <button id="fullscreenButton" class="hidden" disabled><svg width="20" height="20"><use xlink:href="#fullscreen"/></svg></button>
                </div>
                <div id="progressBar" class="progress">
                  <span id="currentTimeDisplay" class="time">00:00</span>
                  <input id="progressControl" class="range" type="range" value="0" min="0" max="0">
                  <span id="totalTimeDisplay" class="time">00:00</span>
                </div>
              </div>
            </figure>

            <video id="frameVideo" playsinline muted></video>
          </div>

          <div id="bottomControls" class="bottom-controls">
            <div class="user-controls" id="errorControl">
              <div id="statisticsMessage"></div>
              <div id="errorMessage"></div>
            </div>

            <div id="commentsLayout">
              <div id="commentsList" class="comments-container"></div>
              <form id="commentsForm" class="comments-form">
                <input type="text" id="commentsInput" placeholder="评论" />
                <input type="submit" id="commentsButton" value="发送" disabled />
              </form>
            </div>
          </div>

          <div id="bottomButtons" class="user-controls">
            <button type="button" id="settingsButton"><svg width="20" height="20"><use xlink:href="#gear"/></svg></button>
            <button id="rewindButton" disabled><svg width="20" height="20"><use xlink:href="#rewind"/></svg></button>
            <button id="forwardButton" disabled><svg width="20" height="20"><use xlink:href="#forward"/></svg></button>
            <button id="favoriteButton" disabled><svg width="20" height="20"><use xlink:href="#favorite"/></svg></button>
            <button id="dislikeButton" disabled><svg width="20" height="20"><use xlink:href="#dislike"/></svg></button>
            <button id="reCaptureButton" disabled><svg width="20" height="20"><use xlink:href="#list-check"/></svg></button>
            <button id="playListButton"><svg width="20" height="20"><use xlink:href="#list"/></svg></button>
          </div>

        </div>
      </div>
    </div>
  </div>

<script>
const DB_VERSION = 6;
const UNSAFE_HTTP = 'http://';
const CONSTS = {
  IS_NATIVE: (typeof window.electronAPI !== 'undefined'),
  ICON_PLAY: '<svg width="20" height="20"><use xlink:href="#play"/></svg>',
  ICON_UNPAUSE: '<svg width="20" height="20"><use xlink:href="#unpause"/></svg>',
  ICON_PAUSE: '<svg width="20" height="20"><use xlink:href="#pause"/></svg>',
  ICON_STOP: '<svg width="20" height="20"><use xlink:href="#stop"/></svg>',
  ICON_CANCEL: '<svg width="20" height="20"><use xlink:href="#cancel"/></svg>',
  ICON_FULLSCREEN: '<svg width="20" height="20"><use xlink:href="#fullscreen"/></svg>',
  ICON_UNFAVORITE: '<svg width="20" height="20"><use xlink:href="#unfavorite"/></svg>',
  ICON_FAVORITE: '<svg width="20" height="20"><use xlink:href="#favorite"/></svg>',
  ICON_DISLIKE: '<svg width="20" height="20"><use xlink:href="#dislike"/></svg>',
  ICON_UNDISLIKE: '<svg width="20" height="20"><use xlink:href="#undislike"/></svg>',
  ICON_SPEAKER_ON: '<svg width="20" height="20"><use xlink:href="#unmute"/></svg>',
  ICON_SPEAKER_OFF: '<svg width="20" height="20"><use xlink:href="#mute"/></svg>',
  ICON_READ_FROM_URL: '<svg width="20" height="20"><use xlink:href="#read-from-url"/></svg>',
  ICON_UPDATE_FROM_URL: '<svg width="20" height="20"><use xlink:href="#update-from-url"/></svg>',
  ICON_PINNED: '<svg width="20" height="20"><use xlink:href="#pin"/></svg>',
  ICON_UNPINNED: '<svg width="20" height="20"><use xlink:href="#unpin"/></svg>',
  ICON_CHECK: '<svg width="20" height="20"><use xlink:href="#list-check"/></svg>',
  POSTER: 'background.jpeg',
  KILOBYTE: 1024,
  MEGABYTE: 1048576,
  /** @type {string} **/
  BASE_URL: (typeof window.electronAPI === 'undefined') ? window.location.origin : 'https://mihui.net',
  CONTROL_DISPLAY_TIMEOUT: 1500,
  CODES: {
    NONE: 0,
    LIKE: 1,
    DISLIKE: 2
  },
  CHANNELS: {
    RAW: '原始频道',
    ALL: '所有频道',
    FAVORITE: '收藏频道'
  }
};
const TYPES = { M3U: 'm3u', TXT: 'txt' };
const SOURCES = { URL: 'url', CONTENT: 'content' };
const VARS = {
  CURRENT_TITLE: '', CURRENT_GROUP: '', CURRENT_URL: '', CURRENT_ID: '',
  PING_TIMEOUT: 0, SCREENSHOT_TIME: 3,
  URLS: new Set(),
  /** @type {string} **/
  TRANSACTION: '',
  ALWAYS_ON_TOP: false,
  DISLIKES: [],
  CONTROL_TIMER: 0
};

const database = new Database(DB_VERSION);

function getElementById(idList = []) {
  const domList = [];
  for(const id of idList) {
    domList.push(document.getElementById(id));
  }
  return domList;
}

/** @type {[
 * HTMLBodyElement,
 * HTMLVideoElement, HTMLDivElement, HTMLDivElement, HTMLInputElement, HTMLButtonElement,
 * HTMLButtonElement, HTMLButtonElement, HTMLDivElement, HTMLDivElement, HTMLVideoElement,
 * HTMLButtonElement, HTMLDivElement, HTMLFormElement, HTMLButtonElement, HTMLButtonElement,
 * HTMLButtonElement, HTMLButtonElement, HTMLButtonElement, HTMLButtonElement, HTMLInputElement,
 * HTMLButtonElement, HTMLButtonElement, HTMLButtonElement, HTMLDivElement, HTMLButtonElement,
 * HTMLInputElement, HTMLButtonElement, HTMLButtonElement, HTMLInputElement, HTMLUListElement,
 * HTMLUListElement, HTMLDivElement, HTMLElement, HTMLButtonElement,
 * HTMLDivElement, HTMLButtonElement, HTMLDivElement, HTMLInputElement, HTMLInputElement,
 * HTMLInputElement, HTMLSpanElement, HTMLElement, HTMLVideoElement, HTMLDivElement,
 * HTMLInputElement, HTMLSpanElement, HTMLSpanElement, HTMLDivElement, HTMLButtonElement,
 * HTMLFormElement, HTMLInputElement, HTMLButtonElement, HTMLDivElement, HTMLInputElement,
 * HTMLDivElement, HTMLInputElement, HTMLDivElement, HTMLButtonElement, HTMLInputElement,
 * HTMLSpanElement, HTMLInputElement, HTMLButtonElement, HTMLButtonElement,
 * ]} **/
const [
  pageBody,
  videoPlayer, errorMessage, errorControl, m3uUrlInput, closeM3uButton,
  loadM3uButton, settingsButton, m3uInputContainer, playlistContent, bottomControls,
  playVideoButton, m3uList, searchContainer, speakerButton, channelButton,
  favoriteButton, playListButton, rewindButton, forwardButton, searchInput,
  fullscreenButton, prevButton, nextButton, pageInfo, listCheckButton,
  pageControl, clearButton, closeButton, m3uContentKey, channelList,
  playlistItems, paginationGroup, videoContainer, dislikeButton,
  pageContainer, databaseSize, databaseCategories, storeFrameCheckbox, autoCheckCheckbox,
  checkTimeout, checkTimeoutDisplay, debugLogs, frameVideo, statisticsMessage,
  progressControl, currentTimeDisplay, totalTimeDisplay, videoControls, logClearButton,
  commentsForm, commentsInput, commentsButton, commentsList, onlyCheckBrokenCheckbox,
  progressBar, enableLoggingCheckbox, logContainer, pauseVideoButton, screenshotTime,
  screenshotTimeDisplay, muteWhenPlayCheckbox, reCaptureButton, pinButton,
 ] = 
getElementById([
  'pageBody',
  'videoPlayer', 'errorMessage', 'errorControl', 'm3uUrlInput', 'closeM3uButton',
  'loadM3uButton', 'settingsButton', 'm3uInputContainer', 'playlistContent', 'bottomControls',
  'playVideoButton', 'm3uList', 'searchContainer', 'speakerButton', 'channelButton',
  'favoriteButton', 'playListButton', 'rewindButton', 'forwardButton', 'searchInput',
  'fullscreenButton', 'prevPage', 'nextPage', 'pageInfo', 'listCheckButton',
  'pageControl', 'clearButton', 'closeButton', 'm3uContentKey', 'channelList',
  'playlistItems', 'pagination', 'videoContainer', 'dislikeButton',
  'pageContainer', 'databaseSize', 'databaseCategories', 'storeFrameCheckbox', 'autoCheckCheckbox',
  'checkTimeout', 'checkTimeoutDisplay', 'debugLogs', 'frameVideo', 'statisticsMessage',
  'progressControl', 'currentTimeDisplay', 'totalTimeDisplay', 'videoControls', 'logClearButton',
  'commentsForm', 'commentsInput', 'commentsButton', 'commentsList', 'onlyCheckBrokenCheckbox',
  'progressBar', 'enableLoggingCheckbox', 'logContainer', 'pauseVideoButton', 'screenshotTime',
  'screenshotTimeDisplay', 'muteWhenPlayCheckbox', 'reCaptureButton', 'pinButton',
]);

let itemsPerPage = 15;
/** @type {Array<{ title: string, url: string, group: string }>} **/
let playlistData = [];
let currentPage = 1;
/** @type {Object.<string, Array<{ title: string, group: string, url: string }>>} **/
let categories = {};
/** @type {Array<{ title: string, url: string, group: string }>} **/
let filteredPlaylistData = [];
/** @type {Object.<string, number>} **/
let videoTimestamp = {};
let storeFrame = 'false';
let autoCheck = 'false';
let enableLogging = 'false';
let muteWhenPlay = 'true';
let onlyCheckBroken = 'false';
let stopURL = null;

class AppShell {
  SITE_TITLE = 'Hunhe IPTV';

  currentCategory = CONSTS.CHANNELS.ALL;

  displayPlayerControls(showNativeControls = false, showCustomControls = false) {
    if (document.fullscreenEnabled) {
      if(showCustomControls) {
        videoControls.classList.remove('transparent');
      }
      else if(showNativeControls) {
        videoPlayer.controls = showNativeControls;
      }
      else {
        videoControls.classList.add('transparent');
      }
      return true;
    }
    videoPlayer.controls = true;
    return false;
  }

  initUI() {
    const playListVisible = window.localStorage.getItem('playListVisible') || 'false';
    if(playListVisible === 'false') {
      pageBody.classList.remove('menu');
    }
    else {
      pageBody.classList.add('menu');
    }

    if(this.displayPlayerControls()) {
      fullscreenButton.classList.remove('hidden');
    }
  }

  /**
   * @param {string} url Request URL
   * @param {Object} options Request options
   * @returns {Promise<string>} Returns the response
   */
  async makeRequest(url, options = {}) {
    return new Promise((resolve, reject) => {
      const response = fetch(url, options).then(response => {
        if (response.ok || response.status === 302) {
          response.text().then(data => {
            if (data) {
              resolve(data); 
            }
          }).catch(error => {
            reject(error);
          });
        }
      }).catch(error => {
        reject(error);
      });
    });
  }

  /**
   * Generate a blank frame for the video
   */
  generateBlankFrame() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'darkblue';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    canvas.toBlob(blob => {
      stopURL = URL.createObjectURL(blob);
    }, 'video/mp4');
  }
  /**
   * Convert a timestamp to a time ago string
   * @param {string} timestamp Timestamp
   */
  timeAgo(timestamp) {
    if (typeof timestamp !== 'number' || isNaN(timestamp) || timestamp < 0) {
      return '未知';
    }
    const now = new Date().getTime();
    const secondsPast = Math.floor((now - timestamp) / 1000);
    if (secondsPast < 5) {
      return '刚刚';
    }
    if (secondsPast < 60) {
      return Math.floor(secondsPast) + ' 秒前';
    }
    if (secondsPast < 3600) {
      return Math.floor(secondsPast / 60) + ' 分钟前';
    }
    if (secondsPast < 86400) {
      return Math.floor(secondsPast / 3600) + ' 小时前';
    }
    if (secondsPast < 30 * 86400) { // 30天
      return Math.floor(secondsPast / 86400) + ' 天前';
    }
    if (secondsPast < 365 * 86400) { // 365天
      return Math.floor(secondsPast / (30 * 86400)) + ' 月前';
    }
    return Math.floor(secondsPast / (365 * 86400)) + ' 年前';
  }
  /**
   * Change the title of the page
   * @param {string} title The title to set
   */
  changeTitle(title) { document.title = title; }
  /**
   * Reset title
   */
  resetTitle() {
    this.changeTitle(this.SITE_TITLE);
  }
  /**
   * Put the page on top
   * @param {boolean} isOnTop Whether the page is on top
   */
  putOnTop(isOnTop) {}
  /**
   * Get the cached m3u URL
   * @return {string} The cached m3u URL
   */
  getCachedM3uUrl() {
    return window.localStorage.getItem('cachedM3uUrl') || '';
  }
  /**
   * @param {string} itemCode The item code to fetch
   */
  async fetchFavorites(itemCode = CONSTS.CODES.LIKE) {
    /** @type {{ data: Array<{ id: string, code: string }> }} */
    const { data } = await database.listData(FAV_STORE);
    categories[CONSTS.CHANNELS.FAVORITE] = data.filter(x => x.code === itemCode || typeof x.code === 'undefined');
    return categories[CONSTS.CHANNELS.FAVORITE];
  }
  /**
   * @param {string} itemCode The item code to fetch
   */
   async fetchDislikes(itemCode = CONSTS.CODES.DISLIKE) {
    /** @type {{ data: Array<{ id: string, code: string }> }} */
    const { data } = await database.listData(FAV_STORE);
    VARS.DISLIKES = data.filter(x => x.code === itemCode).map(x => x.id);
  }
  /**
   * Get last played video data
   * @returns {{ url: string, group: string, title: string }?} Returns Play item
   */
  getLastVideoItem() {
    const data = window.localStorage.getItem('lastPlayedItem');
    if(data) {
      return JSON.parse(data);
    }
    return null;
  }

  loadComments(id, title, skip = 0) {
    commentsInput.placeholder = `评论：${title}`;
    axios.get(`${CONSTS.BASE_URL}/api/tv/comments/${id}?skip=${skip}`)
    .catch(error => {
      console.log('load.comments.error->', error);
    })
    .then(response => {
      if(response) {
        const { data } = response;
        const { comments } = data;

        commentsList.innerHTML = '';

        comments.forEach(comment => {
          const commentItem = document.createElement('div');
          const commentContent = document.createElement('div');
          const commentTime = document.createElement('div');
          commentItem.className = 'comment';
          commentContent.className = 'content';
          commentContent.textContent = comment.content;
          commentTime.className = 'time';
          commentTime.textContent = appShell.timeAgo(new Date(comment.created_time).getTime());

          commentItem.append(commentTime);
          commentItem.append(commentContent);

          commentsList.appendChild(commentItem);
        });
      }
    });
  }
  /**
   * If the URL is favorite
   * @param {string} id ID
   * @returns {Promise<number>} Returns true or false
   */
  async fetchPlayItemCode(id) {
    const { data, error } = await database.readData(id, FAV_STORE);
    if(error) {
      printLog('fetchPlayItemCode.error', error.message);
      return CONSTS.CODES.NONE;
    }
    return data ? data.code : CONSTS.CODES.NONE;
  }

  refreshDislikeButton(itemCode) {
    if(itemCode === CONSTS.CODES.DISLIKE) {
      dislikeButton.innerHTML = CONSTS.ICON_UNDISLIKE;
      dislikeButton.dataset['action'] = 'remove';
      dislikeButton.classList.add('remove');
    }
    else {
      dislikeButton.innerHTML = CONSTS.ICON_DISLIKE;
      dislikeButton.dataset['action'] = 'add';
      dislikeButton.classList.remove('remove');
    }
    dislikeButton.disabled = false;
  }
  /**
   * @param {{ title: string, url: string, group: string }} item Play item
   */
  async loadFavorite(item) {
    dislikeButton.dataset['id'] = favoriteButton.dataset['id'] = item.id;
    dislikeButton.dataset['url'] = favoriteButton.dataset['url'] = item.url;
    dislikeButton.dataset['group'] = favoriteButton.dataset['group'] = item.group;
    dislikeButton.dataset['title'] = favoriteButton.dataset['title'] = item.title;

    const itemCode = await this.fetchPlayItemCode(item.id);
    this.refreshFavoriteButton(itemCode);
    this.refreshDislikeButton(itemCode);
  }

  loadReCapture(item) {
    reCaptureButton.disabled = false;
    reCaptureButton.dataset['id'] = item.id;
    reCaptureButton.dataset['url'] = item.url;
    reCaptureButton.dataset['group'] = item.group;
    reCaptureButton.dataset['title'] = item.title;
  }

  muteOrUnmuteVideo(mute) {
    videoPlayer.muted = mute;
    speakerButton.innerHTML = videoPlayer.muted ? CONSTS.ICON_SPEAKER_ON : CONSTS.ICON_SPEAKER_OFF;
  }
  /**
   * @param {{ title: string, url: string, group: string }} playingItem Play item
   * @param {string} duration Duration
   * @param {boolean} isLive Is live
   **/
  async onPlay(playingItem, duration = '0', isLive = false) {
    errorMessage.textContent = '';
    currentTimeDisplay.textContent = this.getMinutes(videoPlayer.currentTime);
    totalTimeDisplay.textContent = this.getMinutes(duration);
    progressControl.max = duration;
    if(isLive) {
      progressBar.classList.add('hidden');
      totalTimeDisplay.classList.add('hidden');
      currentTimeDisplay.classList.add('hidden');
    }
    else {
      progressBar.classList.remove('hidden');
      totalTimeDisplay.classList.remove('hidden');
      currentTimeDisplay.classList.remove('hidden');
      pauseVideoButton.classList.remove('hidden');
    }
    this.saveLastPlayedVideo(playingItem);
  }
  /**
   * 播放视频
   * @param {{ url: string, group: string, title: string }} source Play data source
   * @param {number} duration Duration
   * @param {boolean} isLive Is alive
   */
  playVideSource(source, duration = '0', isLive = false) {
    const lastPlayedTime = videoTimestamp[source.url];
    if (!isNaN(lastPlayedTime)) {
      videoPlayer.currentTime = lastPlayedTime;
    }
    videoPlayer.play().catch(error => {
      errorMessage.textContent = '无法播放所选视频，请尝试其他源或检查网络连接。';
    }).then(() => {
      this.onPlay(source, duration, isLive);
    });
  }

  hlsPlay(source) {
    printLog('hlsPlay');
    try {
      const hls = new Hls();
      hls.loadSource(source.url);
      hls.attachMedia(videoPlayer);
      hls.once(Hls.Events.LEVEL_LOADED, (evt, data) => {
        printLog('Hls.Events.LEVEL_LOADED');
        if (!data?.details) {
          return printLog('Warning: Data details is undefined.');
        }
        const duration = data?.details?.totalduration || 0;
        const isLive = data?.details?.live || false;
        this.playVideSource(source, duration, isLive);
      });
      hls.once(Hls.Events.MANIFEST_PARSED, (evt, data) => {
        const duration = data?.details?.totalduration || 0;
        const isLive = data?.details?.live || false;
        printLog('Hls.Events.MANIFEST_PARSED', 'duration->', duration, 'isLive->', isLive);
      });
      hls.once(Hls.Events.ERROR, (error, data) => {
        printLog('Hls.Events.ERROR', 'data.fatal->', data.fatal, 'data.type->', data.type);
        printLog('Hls.Events.ERROR', JSON.stringify(error));
        if (data.fatal) {
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              printLog('Hls.ErrorTypes.NETWORK_ERROR', '重试网络请求');
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              printLog('Hls.ErrorTypes.MEDIA_ERROR', '处理媒体播放错误');
              if(videoPlayer.src === stopURL || videoPlayer.src === '') {
                printLog('Hls.ErrorTypes.MEDIA_ERROR', '停止视频');
                hls.destroy();
              }
              else if(videoPlayer.src) {
                printLog('Hls.ErrorTypes.MEDIA_ERROR', '重新加载视频');
                hls.recoverMediaError(); 
              }
              break;
            default:
              printLog(data.type, '其他错误类型');
              hls.destroy();
              break;
          }
        }
        else {
          printLog('HLS ERROR unknown');
        }
      });
    }
    catch(error) {
      printLog('HLS ERROR 1', error.message);
    }
  }

  onLoadedMetadata (evt) {
    printLog('videoPlayer.loadedmetadata');
    if (source) {
      this.playVideSource(source, evt.target.duration);
    }
  }

  nativePlay(source) {
    printLog('nativePlay');
    videoPlayer.removeEventListener('loadedmetadata', this.onLoadedMetadata);
    videoPlayer.src = source.url;
    videoPlayer.addEventListener('loadedmetadata', this.onLoadedMetadata);
  }

  refreshFavoriteButton(itemCode) {
    if(itemCode === CONSTS.CODES.LIKE) {
      favoriteButton.innerHTML = CONSTS.ICON_UNFAVORITE;
      favoriteButton.dataset['action'] = 'remove';
      favoriteButton.classList.add('remove');
    }
    else {
      favoriteButton.innerHTML = CONSTS.ICON_FAVORITE;
      favoriteButton.dataset['action'] = 'add';
      favoriteButton.classList.remove('remove');
    }
    favoriteButton.disabled = false;
  }

  getMinutes(duration) {
    // 类型检查和异常处理
    if (typeof duration !== 'number' || isNaN(duration) || Number.isNaN(duration)) {
      return '00:00';
    }

    const dNumber = parseInt(duration, 10);
    const minutes = Math.floor(dNumber / 60);
    const seconds = dNumber % 60;

    // 处理分钟数小于 10 的情况
    const formattedMinutes = minutes < 10 ? `0${minutes}` : minutes.toString();
    const formattedSeconds = seconds < 10 ? `0${seconds}` : seconds.toString();

    // 使用模板字符串拼接结果
    return `${formattedMinutes}:${formattedSeconds}`;
  }

  /**
   * 重置列表样式
   * @param {string} videoUrl 视频地址
   * @param {Array<string>} classList 样式列表
   */
   resetListStyles(videoUrl, classList = []) {
    classList.forEach(style => {
      this.resetListStyle(style);
    });
    playlistItems.childNodes.forEach((li) => {
      if(li.dataset['url'] === videoUrl) {
        classList.forEach(style => {
          li.classList.add(style);
        });
        return;
      }
    });
  }

  /**
   * @param {{ title: string, group: string, url: string }} source Play item
   * @param {boolean} isUserAction If it is controled by user
   */
  playVideo(source, isUserAction = true) {
    if (source) {
      this.changeTitle(source.title);
    } else {
      this.resetTitle();
    }
    if(isUserAction === false) { return; }
    this.loadVideoTimestamp();
    this.loadComments(database.encodeString(source.url), source.title);
    this.loadFavorite(source);
    this.loadReCapture(source);

    window.localStorage.removeItem('lastPlayedItem');
    this.muteOrUnmuteVideo(muteWhenPlay === 'true');

    currentTimeDisplay.textContent = this.getMinutes(0);
    totalTimeDisplay.textContent = this.getMinutes(0);
    progressControl.value = progressControl.max = '0';

    this.resetListStyles(source.url, ['preview', 'active']);

    if (Hls.isSupported() && (source.url.startsWith(UNSAFE_HTTP) === false || CONSTS.IS_NATIVE)) {
      this.hlsPlay(source);
    }
    else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
      this.nativePlay(source);
    }
    else {
      errorMessage.textContent = '您的浏览器不支持 HLS 视频流。';
    }
  }

  playLastVideo(isUserAction = true) {
    const lastPlayedItem = this.getLastVideoItem();
    if (lastPlayedItem) {
      this.playVideo(lastPlayedItem, isUserAction);
    }
  }

  resetListStyle(className, list = playlistItems) {
    for(const node of list.childNodes) {
      node.classList.remove(className);
    }
  }
  /**
   * @param {HTMLLIElement} li List item
   * @param {{ title: string, url: string, group: string }} item Play item
   */
  playNow(li, item) {
    if(li.dataset['broken']) return;
    this.playVideo(item);
  }

  showPlayButton() {
    playVideoButton.innerHTML = CONSTS.ICON_PLAY;
    pauseVideoButton.innerHTML = CONSTS.ICON_UNPAUSE;
    playVideoButton.className = 'stopped';
    this.displayPlayerControls();
    videoPlayer.className = 'paused';
  }

  saveVideoTimestamp() {
    window.localStorage.setItem('videoTimestamp', JSON.stringify(videoTimestamp));
  }

  changePoster(poster) {
    if(poster) {
      videoPlayer.poster = poster;
      pageBody.style.background = `transparent url("${poster}") center center / cover no-repeat`;
    }
  }

  isPlaying() {
    return videoPlayer.paused === false || playVideoButton.className === 'played' || playVideoButton.className === 'playing';
  }

  stopVideo(removePreview = true, isReset = false, poster = CONSTS.POSTER) {
    printLog('stopVideo');
    videoPlayer.pause();
    if(stopURL) videoPlayer.src = stopURL;
    videoPlayer.pause();
    videoPlayer.removeAttribute('src');
    pauseVideoButton.classList.add('hidden');
    currentTimeDisplay.textContent = this.getMinutes(0);
    totalTimeDisplay.textContent = this.getMinutes(0);
    progressControl.value = progressControl.max = '0';

    this.resetTitle();
    this.showPlayButton();
    this.resetControlButtons(false, isReset);
    this.saveVideoTimestamp();
    this.changePoster(poster);
    this.resetListStyle('active');
    if(removePreview) {
      this.resetListStyle('preview');
    }
  }
  /**
   * @param {HTMLLIElement} li List item
   * @param {{ title: string, url: string, group: string }} item Play item
   * @param {string} frame Poster
   */
  async previewNow(li, item, frame) {
    printLog('previewNow');
    this.stopVideo(true, false, frame);
    if(li.dataset['broken']) return;
    li.classList.add('preview');
    this.loadComments(li.dataset['id'], li.title);
    this.loadFavorite(item);
    this.loadReCapture(item);
    this.saveLastPlayedVideo(item);
  }
  /**
   * @param {HTMLLIElement} li List item
   * @param {{ ok: boolean, duration: number, frame: string, latency: number, timeout: boolean }} checkResult List item
   * @param {{ url: string, group: string, title: string }} lastPlayedItem Last played data
   * @param {number} itemCode If it is favorite
   */
  updateListItemStyle(li, checkResult, lastPlayedItem, itemCode) {
    li.className = '';
    if (checkResult.ok) {
      if(checkResult.latency < 500) {
        li.classList.add('good');
      }
      else if (checkResult.latency >= 500 && checkResult.latency <= 1500) {
        li.classList.add('average');
      }
      else {
        li.classList.add('bad');
      }
      if(checkResult.frame) {
        li.dataset['frame'] = URL.createObjectURL(checkResult.frame);
        li.classList.add('frame');
      }
      li.dataset['duration'] = `[${this.getMinutes(checkResult.duration)}]`;
    }
    else {
      if(checkResult.timeout) {
        li.dataset['timeout'] = true;
        li.classList.add('timeout');
      }
      else {
        li.classList.add('broken');
      }
      li.title = `此视频源可能无法播放`;
    }
    if(lastPlayedItem?.url === li.dataset['url']) {
      li.classList.add('preview');
      if(this.isPlaying()) {
        li.classList.add('active');
      }
      if(li.classList.contains('frame')) {
        this.changePoster(li.dataset['frame']);
      }
    }
    if(itemCode === CONSTS.CODES.LIKE) {
      if(this.currentCategory !== CONSTS.CHANNELS.FAVORITE) {
        li.classList.add('favorite'); 
      }
      if(li.classList.contains('timeout')) {
        const deleteButton = document.createElement('span');
        deleteButton.innerHTML = CONSTS.ICON_CANCEL;
        deleteButton.className = 'delete';
        deleteButton.onclick = (evt) => {
          evt.stopPropagation();
          const id = li.dataset['id'];
          this.deleteFavorite(id);
        };
        li.append(deleteButton);
      }
    }
  }
  /**
   * @param {HTMLVideoElement} video Video tag
   * @param {string} url URL
   * @param {Hls?} hls Hls instance
   * @param {boolean} isRandom If the duration is random
   * @returns {Promise<{ frame: string, duration: number }?>} Returns frame URL
   */
  async captureFrame(url, hls = null, isRandom = false) {
    if(storeFrame === 'false') { return null; }
    const canvas = document.createElement('canvas');
    const canvasContext = canvas.getContext('2d');

    /**
     * @type {(videoTag: HTMLVideoElement) => Promise<{ frame: string, duration: number }>} Draw video frame
     */
    const drawVideo = (videoTag) => {
      return new Promise((resolve, reject) => {
        canvas.width = videoTag.videoWidth;
        canvas.height = videoTag.videoHeight;
        canvasContext.drawImage(videoTag, 0, 0, canvas.width, canvas.height);
        canvas.toBlob((blob) => {
          if(videoTag.currentTime > 0) {
            return resolve({ frame: blob, duration: videoTag.duration });
          }
          return reject(null);
        });
      });
    };

    if(isRandom) {
      try {
        return await drawVideo(videoPlayer);
      }
      catch(error) {
        return await this.captureFrame(url, hls, false);
      }
    }
    const frame = await new Promise((resolve) => {
      let timer = 0;

      if(hls) {
        hls.attachMedia(frameVideo);
      }
      else if(url) {
        frameVideo.src = url;
      }
      else {
        return resolve(null);
      }
      const cleanupEvents = (payload) => {
        frameVideo.removeEventListener('seeked', onSeeked);
        frameVideo.removeEventListener('loadedmetadata', onLoadedMetaData);
        clearTimeout(timer);
        resolve(payload);
      };
      const onLoadedMetaData = (evt) => {
        canvas.width = frameVideo.videoWidth;
        canvas.height = frameVideo.videoHeight;
        frameVideo.play().then(() => {
          const captureTime = (isRandom ? Math.ceil(Math.random() * 300) : VARS.SCREENSHOT_TIME);
          frameVideo.currentTime = captureTime;
        }).catch(error => {
          cleanupEvents(null);
        });
      },
      onSeeked = (evt) => {
        drawVideo(frameVideo).then(data => {
          cleanupEvents(data);
        }).catch(error => {
          cleanupEvents(null);
        });
      };

      frameVideo.addEventListener('seeked', onSeeked);
      frameVideo.addEventListener('loadedmetadata', onLoadedMetaData);
      
      timer = setTimeout(() => {
        cleanupEvents(null);
      }, VARS.PING_TIMEOUT - 1000);
    });
    return frame;
  }
  /**
   * 检查视频可播放性
   * @param {string} url URL
   * @returns {{ ok: boolean, duration: number, frame: string, latency: 0, timeout: boolean }}
   **/
  async checkVideoPlayability(url, isRandom = false) {
    const timestamp = new Date().getTime();
    return new Promise((resolve) => {
      let timeoutId = 0;
      if (Hls.isSupported() && (url.startsWith(UNSAFE_HTTP) === false || CONSTS.IS_NATIVE)) {
        try {
          const hls = new Hls();
          const cleanup = () => {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            hls.destroy();
          };

          hls.loadSource(url);
          hls.once(Hls.Events.MANIFEST_PARSED, async (evt, data) => {
            const latency = new Date().getTime() - timestamp;
            const captured = await this.captureFrame(url, hls, isRandom);
            cleanup();
            resolve({ ok: true, duration: captured?.duration, frame: captured?.frame, latency, timeout: false });
          });

          hls.once(Hls.Events.ERROR, () => {
            cleanup();
            resolve({ ok: false, duration: 0, latency: new Date().getTime() - timestamp, timeout: false });
          });

          timeoutId = setTimeout(() => {
            cleanup();
            resolve({ ok: false, duration: 0, latency: new Date().getTime() - timestamp, timeout: true });
          }, VARS.PING_TIMEOUT);
        }
        catch(error) {
          printLog('HLS ERROR 2');
        }
      }
      else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
        const video = document.createElement('video');
        video.src = url;
        const cleanup = () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          video.remove();
        };

        video.onloadedmetadata = async (evt) => {
          const latency = new Date().getTime() - timestamp;
          const captured = await this.captureFrame(url, null, isRandom);
          cleanup();
          resolve({ ok: true, duration: captured?.duration, frame: captured?.frame, latency, timeout: false });
        };

        video.onerror = () => {
          cleanup();
          resolve({ ok: false, duration: 0, latency: new Date().getTime() - timestamp, timeout: false });
        };

        timeoutId = setTimeout(() => {
          cleanup();
          resolve({ ok: false, duration: 0, latency: new Date().getTime() - timestamp, timeout: true });
        }, VARS.PING_TIMEOUT);
      }
      else {
        resolve({ ok: false, duration: 0, latency: new Date().getTime() - timestamp, timeout: false });
      }
    });
  }

  async showCheckButton(isChecking) {
    if(isChecking) {
      listCheckButton.classList.add('checking');
      listCheckButton.innerHTML = CONSTS.ICON_CANCEL;
    }
    else {
      listCheckButton.classList.remove('checking');
      listCheckButton.innerHTML = CONSTS.ICON_CHECK;
    }
  }

  // 显示播放列表页面
  async displayPlaylistPage(page, transaction) {
    playlistItems.innerHTML = '';
    /** @type {Array<{ title: string, url: string, group: string }>} **/
    const itemsToDisplay = filteredPlaylistData || [];
    const startIndex = (page - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const pageItems = itemsToDisplay.slice(startIndex, endIndex);
    const lastPlayedItem = this.getLastVideoItem();

    listCheckButton.disabled = true;
    // Loop list items
    pageItems.forEach(async (item, index) => {
      /** @type {HTMLLIElement} **/
      const li = document.createElement('li');
      /** @type {HTMLDivElement} **/
      const label = document.createElement('label');
      label.className = 'label';
      /** @type {HTMLElement} **/
      const text = document.createElement('i');
      text.textContent = item.group === appShell.currentCategory ? item.title : `[${item.group}] ${item.title}`;
      label.append(text);

      if(item.url.startsWith(UNSAFE_HTTP) && CONSTS.IS_NATIVE === false) {
        li.dataset['http'] = true;
        li.classList.add('http');
        li.classList.add('broken');
      }

      li.dataset['id'] = item.id;
      li.dataset['url'] = item.url;
      li.dataset['group'] = item.group;
      li.dataset['duration'] = '';
      li.title = item.title;

      li.onclick = (evt) => {
        evt.preventDefault();
        const { currentTarget } = evt;
        const frame = currentTarget.dataset['frame'] ? currentTarget.dataset['frame'] : CONSTS.POSTER;
        const isBroken = currentTarget.classList.contains('broken') === false;
        if((videoPlayer.poster === frame || frame === CONSTS.POSTER) && isBroken && !this.isPlaying()) {
          this.playNow(currentTarget, item);
        }
        else {
          this.previewNow(currentTarget, item, frame);
        }
      };

      li.append(label);
      playlistItems.appendChild(li);
    });
    listCheckButton.disabled = false;

    const isAutoCheck = autoCheck === 'true';

    // Update styles
    for (const li of playlistItems.childNodes) {
      const videoUrl = li.dataset['url'];
      const id = li.dataset['id'];

      const itemCode = await this.fetchPlayItemCode(id);
      /** @type {{ data: { result: { ok: boolean, duration: number, frame: string, latency: number, timeout: boolean } }, error: Error }} */
      const { data: playCache, error } = await database.readData(id, STA_STORE);

      if(error) {
        printLog('displayPlaylistPage.error', error.message);
        return;
      }
      if (playCache) {
        this.updateListItemStyle(li, playCache.result, lastPlayedItem, itemCode);
      }
      else if (isAutoCheck && transaction === VARS.TRANSACTION) {
        this.showCheckButton(isAutoCheck);
        // No cache or cleaned
        // Check video playability
        li.className = 'checking';
        const result = await this.checkVideoPlayability(videoUrl);
        await database.addData({ id, result }, STA_STORE);
        this.updateListItemStyle(li, result, lastPlayedItem, itemCode);
      }
    }

    this.showCheckButton(false);
  }

  // 初始化播放列表
  async initializePlaylist() {
    await this.fetchFavorites();
    await this.fetchDislikes();

    filteredPlaylistData = (categories[appShell.currentCategory] || playlistData).filter(x => VARS.DISLIKES.includes(x.id) === false);

    this.displayPlaylistPage(currentPage, VARS.TRANSACTION).catch(error => {
      printLog('initializePlaylist.displayPlaylistPage.error', error.message);
    });
    this.updatePaginationControls();
  }

  // 显示播放列表内容
  showPlaylistContent() {
    printLog('showPlaylistContent');
    pageBody.classList.remove('settings');
    this.displayPlayerControls();
  }

  async processM3uData(type, data, fromCache = false, isBooting = false) {
    await this.initPlayData(type, data);
    this.initializeCategories(isBooting);
    this.initializePlaylist();
    this.showPlaylistContent();
    errorMessage.textContent = '';
  }

  // 更新分页控件
  updatePaginationControls() {
    const itemsToDisplay = filteredPlaylistData || [];
    const totalPages = Math.ceil(itemsToDisplay.length / itemsPerPage);
    const hasData = itemsToDisplay.length > 0;
    pageControl.max = totalPages;

    if(hasData) {
      pageInfo.innerHTML = `第 <span id="pageCurrent">${currentPage}</span>/${totalPages} 页`;
      pageControl.min = 1;
    }
    else {
      pageInfo.textContent = '';
      pageControl.min = 0;
    }
    pageControl.value = currentPage;
    prevButton.disabled = (currentPage === 1 || hasData === false);
    nextButton.disabled = (currentPage === totalPages || hasData === false);
  }

  gotoPage(p) {
    currentPage = p;
    window.localStorage.setItem('currentPage', p);
    this.displayPlaylistPage(currentPage, VARS.TRANSACTION = crypto.randomUUID()).catch(error => {
      printLog('gotoPage.error', error.message);
    });
    this.updatePaginationControls();
  }
  /**
   * List the store
   * @param {string} source The source to list
   */
  async listStore(source) {
    printLog('listStore');
    settingsButton.disabled = true;
    const cachedM3uSource = localStorage.getItem('cachedM3uSource') || SOURCES.URL;
    const cachedM3uUrl = this.getCachedM3uUrl();

    m3uList.innerHTML = '';

    /** @type {{ data: Array<{ key: string, id: string, source: string }> }} **/
    const { data: list } = await database.listData();
    for(const m3uItem of list) {
      const url = database.decodeString(m3uItem.id);
      const isCurrent = cachedM3uUrl.includes(url) || (cachedM3uSource === SOURCES.CONTENT && m3uItem.source === SOURCES.CONTENT && cachedM3uUrl.includes(url));

      const divItem = document.createElement('div');
      const aItem = document.createElement('a');
      const dItem = document.createElement('a');
      const rItem = document.createElement('a');

      dItem.innerText = '删';
      dItem.className = 'delete';
      dItem.dataset['id'] = m3uItem.id;
      dItem.onclick = async (evt) => {
        evt.preventDefault();
        /** @type {HTMLAnchorElement} **/
        const deleteButton = evt.target;
        if(deleteButton.classList.contains('ready')) {
          await database.deleteData(evt.target.dataset['id']);
          this.listStore('click');
        }
        else {
          deleteButton.classList.add('ready');
        }
      };
      rItem.innerText = '刷';
      rItem.className = 'refresh';
      rItem.dataset['id'] = m3uItem.id;
      rItem.onclick = async (evt) => {
        evt.preventDefault();
        const element = evt.target;
        if(element.classList.contains('disabled')) {
          return;
        }

        this.loadM3uUrl({ m3uUrl: url, fromCache: false, isBooting: false, onStart: () => {
          element.classList.add('disabled');
        }, onSuccess: async (type, data, cached, isBooting) => {
          await this.listStore('fetch');
        }, onCompleted: () => {
          element.classList.remove('disabled');
        } });
      };
      aItem.textContent = url;
      aItem.className = 'load';
      aItem.dataset['id'] = m3uItem.id;
      aItem.onclick = async (evt) => {
        /** @type {HTMLAnchorElement} **/
        const element = evt.target;
        /** @type {{ data: { id: string, m3u: string, source: string, type: string, time: number }, error: Error }} */
        const { data, error } = await database.readData(element.dataset['id']);
        if(error) {
          printLog('listStore.error', error.message);
          return;
        }
        if(element.textContent === cachedM3uUrl) {
          return;
        }
        if(data.source === SOURCES.URL) {
          this.setUrlInput(database.decodeString(m3uItem.id));
        }
        this.gotoPage(1);
        await this.processM3uData(data.type || TYPES.M3U, data);
      };
      divItem.title = this.timeAgo(m3uItem.time);
      divItem.append(aItem);
      divItem.append(rItem);
      if(isCurrent) {
        divItem.classList.add('active');
      }
      else {
        divItem.append(dItem);
      }
      m3uList.append(divItem);
    }
    settingsButton.disabled = false;
  }
  /**
   * Save the category to cache
   * @param {string} category Category
   */
  saveCategoryToCache(category) {
    this.currentCategory = category;
    window.localStorage.setItem('currentCategory', category);
  }
  /**
   * Load the current channel
   * @param {boolean} isBooting Is booting
   * @returns {string} Returns the current channel
   */
  loadCurrentChannel(isBooting = false) {
    printLog('loadCurrentChannel');
    this.currentCategory = CONSTS.CHANNELS.ALL;
    if(isBooting) {
      let category = window.localStorage.getItem('currentCategory');
      if(category && category !== this.currentCategory) {
        /** @type {Array<string>} */
        const channels = Object.keys(categories);
        if(channels.includes(category) === false) {
          category = this.currentCategory;
        }
        this.saveCategoryToCache(category);
      }
    }
    return this.currentCategory;
  }

  switchChannel() {
    if(channelList.classList.contains('hidden')) {
      channelList.classList.remove('hidden');
      playlistItems.classList.add('hidden');
      listCheckButton.disabled = true;
    }
    else {
      channelList.classList.add('hidden');
      playlistItems.classList.remove('hidden');
      listCheckButton.disabled = false;
    }
    channelButton.textContent = this.currentCategory;
  }
  /**
   * @param {boolean} isBooting - Whether or not the app is booting
   */
  initializeCategories(isBooting = false) {
    channelList.innerHTML = '';
    const selectedChannel = this.loadCurrentChannel(isBooting);
    channelButton.textContent = selectedChannel;
    for (let category in categories) {
      if(category === CONSTS.CHANNELS.RAW){
        continue;
      }
      /** @type {HTMLLIElement} **/
      const li = document.createElement('li');
      const size = Object.hasOwn(categories, category) ? categories[category].length : 0;

      li.dataset['channel'] = category;
      li.dataset['duration'] = size;
      /** @type {HTMLDivElement} **/
      const label = document.createElement('label');
      label.className = 'label';
      /** @type {HTMLElement} **/
      const text = document.createElement('i');
      text.textContent = category;
      label.append(text);
      li.append(label);
      if(size === 0) {
        li.classList.add('bad');
        li.classList.add('broken');
      }
      else {
        li.onclick = async (evt) => {
          evt.preventDefault();
          const { currentTarget } = evt;
          if(currentTarget.classList.contains('selected') || li.dataset['duration'] === '0') {
            return;
          }
          const { channel = CONSTS.CHANNELS.ALL } = currentTarget.dataset;
          this.resetListStyle('selected', channelList);
          li.classList.add('selected');
          this.saveCategoryToCache(channel);
          // 重置搜索
          searchInput.value = '';
          // 更新当前类别的数据
          if(this.currentCategory === CONSTS.CHANNELS.FAVORITE) {
            filteredPlaylistData = await this.fetchFavorites();
          }
          else {
            filteredPlaylistData = categories[this.currentCategory === CONSTS.CHANNELS.ALL ? CONSTS.CHANNELS.RAW : this.currentCategory];
          }
          this.gotoPage(1);
          this.switchChannel();
        };
      }

      if(selectedChannel === category) {
        li.classList.add('selected');
      }
      channelList.appendChild(li);
    }
  }
  /**
   * @param {string} url URL
   */
  processUrl(url) {
    if(url.includes('#')) {
      return url.substring(0, url.indexOf('#'));
    }
    return url;
  }
  /**
   * 处理 M3U 文件单行
   * @param {string} line Line
   */
  processM3uLine(line) {
    if (line.startsWith('#EXTINF:')) {
      const infoLine = line.substring(8);
      const groupMatch = infoLine.match(/group-title="([^"]+)"/);
      VARS.CURRENT_GROUP = groupMatch ? groupMatch[1] : CONSTS.CHANNELS.ALL;
      VARS.CURRENT_TITLE = infoLine.split(',').pop().trim();
    } else if (line && !line.startsWith('#')) {
      const processedUrl = this.processUrl(line);
      VARS.CURRENT_ID = database.encodeString(processedUrl);
      if(VARS.DISLIKES.includes(VARS.CURRENT_ID)) {
        return;
      }
      if (!VARS.URLS.has(processedUrl)) {
        VARS.URLS.add(processedUrl);
        const item = { id: VARS.CURRENT_ID, title: VARS.CURRENT_TITLE || processedUrl, url: processedUrl, group: VARS.CURRENT_GROUP };
        playlistData.push(item);
        categories[CONSTS.CHANNELS.ALL].push(item);
        if (VARS.CURRENT_GROUP !== CONSTS.CHANNELS.ALL) {
          if (!categories[VARS.CURRENT_GROUP]) {
            categories[VARS.CURRENT_GROUP] = [];
          }
          categories[VARS.CURRENT_GROUP].push(item);
        }
      }
    }
  }
  /**
   * 处理 TXT 文件单行
   * @param {string} line Text line
   */
  async processTxtLine(line) {
    if (line.endsWith('#genre#')) {
      const infoLine = line.replace(',#genre#', '');
      VARS.CURRENT_GROUP = infoLine ? infoLine : CONSTS.CHANNELS.ALL;
    } else if (line && !line.endsWith('#genre#')) {
      const lineArray = line.split(',');
      if(lineArray.length < 2) return;
      VARS.CURRENT_URL = this.processUrl(lineArray.pop().trim());
      VARS.CURRENT_ID = database.encodeString(VARS.CURRENT_URL);
      VARS.CURRENT_TITLE = lineArray.pop().trim();
      if(VARS.DISLIKES.includes(VARS.CURRENT_ID)) {
        return;
      }
      if (!VARS.URLS.has(VARS.CURRENT_URL)) {
        VARS.URLS.add(VARS.CURRENT_URL);
        const group = VARS.CURRENT_GROUP || CONSTS.CHANNELS.ALL;
        const item = { id: VARS.CURRENT_ID, title: VARS.CURRENT_TITLE, url: VARS.CURRENT_URL, group };
        playlistData.push(item);
        categories[CONSTS.CHANNELS.ALL].push(item);
        if (group !== CONSTS.CHANNELS.ALL) {
          if (!categories[group]) {
            categories[group] = [];
          }
          categories[group].push(item);
        }
      }
    }
  }
  /**
   * Initialize the playlist data.
   * @param {string} type The type of data to load.
   * @param {{ m3u: string, time: string }} data The data to load.
   */
  async initPlayData(type, data) {
    // Data for all
    playlistData = [];
    // Data in categories
    categories = { [CONSTS.CHANNELS.ALL]: [], [CONSTS.CHANNELS.FAVORITE]: [] };
    VARS.URLS.clear();

    await this.fetchDislikes();

    const lines = data.m3u.split('\n');

    for(const item of lines) {
      const line = item.trim();
      // [M3U] Start - Process data
      if(type === TYPES.M3U) {
        this.processM3uLine(line);
      }
      else if (type === TYPES.TXT) {
        this.processTxtLine(line);
      }
      // [M3U] End - Process data
    }
    categories[CONSTS.CHANNELS.RAW] = [...categories[CONSTS.CHANNELS.ALL]];
    statisticsMessage.textContent = `{ ${playlistData.length}条，(${this.timeAgo(data.time)}) }`;
  }
  /**
   * 设置URL输入框
   * @param {string} url URL
   * @param {string} label Label
   */
  setUrlInput(url, label = CONSTS.ICON_UPDATE_FROM_URL) {
    m3uUrlInput.value = url;
    loadM3uButton.innerHTML = label;
    window.localStorage.setItem('cachedM3uUrl', url);
  }

  async loadM3uFile(fromCache = false, isBooting = false) {
    printLog('loadM3uFile');
    /** @type {string} **/
    const m3uUrl = m3uUrlInput.value.trim();
    this.loadM3uUrl({ m3uUrl, fromCache, isBooting, onStart: () => {
      
    }, onSuccess: async (type, data, cached, isBooting) => {
      await this.processM3uData(type, data, cached, false, isBooting);
      await this.listStore('fetch');
      this.gotoPage(1);
    }, onCompleted: () => {
    } });
  }
  /**
   * Show m3u input box
   */
  async showM3uInput() {
    if(pageBody.classList.contains('settings')) {
      this.showPlaylistContent();
    }
    else {
      await this.listStore('showM3uInput');
      pageBody.classList.add('settings');
      this.displayPlayerControls(true, true);
    }

    const { totalSize, storeSize } = await database.totalSize();
    databaseSize.textContent = this.toSize(totalSize);
    databaseCategories.innerHTML = '';

    document.querySelectorAll('.settings-usage').forEach(item => item.classList.remove('hidden'));

    const labels = { [FAV_STORE]: '收藏', [M3U_STORE]: '频道', [STA_STORE]: '缓存' };
    for(const item in storeSize) {
      /** @type {HTMLButtonElement} */
      const button = document.createElement('button');
      button.textContent = `${labels[item]}: ${this.toSize(storeSize[item])}`;
      button.ondblclick = async () => {
        await database.purgeData(item);
        window.location.reload();
      };
      databaseCategories.append(button);
    }
  }

  loadVideoTimestamp() {
    const videoTimestampData = window.localStorage.getItem('videoTimestamp');
    videoTimestamp = videoTimestampData ? JSON.parse(videoTimestampData) : {};
  }

  async loadLocalCache() {
    const cachedM3uUrl = window.localStorage.getItem('cachedM3uUrl') || '';
    if (cachedM3uUrl) {
      this.setUrlInput(cachedM3uUrl);
      await this.loadM3uFile(true, true); // 添加一个参数来表示这是从缓存加载
    }
    else {
      await this.showM3uInput();
    }
    this.loadVideoTimestamp();

    currentPage = parseInt(window.localStorage.getItem('currentPage')) || 1;

    storeFrame = window.localStorage.getItem('storeFrame') === 'true' ? 'true' : 'false';
    storeFrameCheckbox.checked = storeFrame === 'true';
    screenshotTime.disabled = !storeFrameCheckbox.checked;

    autoCheck = window.localStorage.getItem('autoCheck') === 'true' ? 'true' : 'false';
    autoCheckCheckbox.checked = autoCheck === 'true';

    enableLogging = window.localStorage.getItem('enableLogging') === 'true' ? 'true' : 'false';
    enableLoggingCheckbox.checked = enableLogging === 'true';

    if(enableLogging === 'true') {
      logContainer.classList.remove('hidden');
    }

    onlyCheckBroken = window.localStorage.getItem('onlyCheckBroken') === 'true' ? 'true' : 'false';
    onlyCheckBrokenCheckbox.checked = onlyCheckBroken === 'true';

    VARS.PING_TIMEOUT = parseInt(window.localStorage.getItem('PING_TIMEOUT')) || 10000;
    checkTimeout.value = Math.round(VARS.PING_TIMEOUT / 1000);
    checkTimeoutDisplay.textContent = checkTimeout.value;

    VARS.SCREENSHOT_TIME = parseInt(window.localStorage.getItem('screenshotTime')) || 3;
    screenshotTime.value = VARS.SCREENSHOT_TIME;
    screenshotTimeDisplay.textContent = screenshotTime.value;
    
    muteWhenPlay = window.localStorage.getItem('muteWhenPlay') === 'false' ? 'false' : 'true';
    muteWhenPlayCheckbox.checked = muteWhenPlay === 'true';
  }
  /**
   * 将字节转换为合适的单位大小
   * @param {number} val 字节数
   * @returns {string} 转换后的大小字符串
   */
  toSize(val) {
    // 类型检查
    if (typeof val !== 'number' || val < 0) {
      return val;
    }
    // 转换逻辑
    if (val < CONSTS.KILOBYTE) {
      return `${val} B`;
    } else if (val < CONSTS.MEGABYTE) {
      return (val / CONSTS.KILOBYTE).toFixed(2) + ' KB';
    } else {
      return (val / CONSTS.MEGABYTE).toFixed(2) + ' MB';
    }
  }

  onStopped() {
    this.showPlayButton();
    this.resetTitle();
    this.saveVideoTimestamp();
    this.displayPlayerControls(false, true);
  }

  setVideoTimestamp(timestamp) {
    const lastPlayedItem = this.getLastVideoItem();
    videoTimestamp[lastPlayedItem.url] = timestamp;
  }

  saveLastPlayedVideo(playingItem) {
    window.localStorage.setItem('lastPlayedItem', JSON.stringify(playingItem));
  }

  seekVideo(time) {
    videoPlayer.currentTime += time;
  }

  detectM3uUrl() {
    loadM3uButton.disabled = !m3uUrlInput.checkValidity();
    const cachedM3uUrl = this.getCachedM3uUrl();
    if(cachedM3uUrl === m3uUrlInput.value) {
      loadM3uButton.innerHTML = CONSTS.ICON_UPDATE_FROM_URL;
    }
    else {
      loadM3uButton.innerHTML = CONSTS.ICON_READ_FROM_URL;
    }
  }

  resetControlButtons(isPlaying, isReset = false) {
    if(isPlaying) {
      rewindButton.disabled = forwardButton.disabled = false;
    }
    else {
      rewindButton.disabled = forwardButton.disabled = true;
    }
    reCaptureButton.disabled = isReset;
    playVideoButton.disabled = dislikeButton.disabled = favoriteButton.disabled = isReset || false;
  }

  onPlaying() {
    playVideoButton.innerHTML = CONSTS.ICON_STOP;
    pauseVideoButton.innerHTML = CONSTS.ICON_PAUSE;
    fullscreenButton.disabled = false;
    playVideoButton.className = 'played';
    errorMessage.textContent = '';
    videoPlayer.className = '';
    this.resetControlButtons(true);
    clearTimeout(VARS.CONTROL_TIMER);
    VARS.CONTROL_TIMER = setTimeout(this.displayPlayerControls, CONSTS.CONTROL_DISPLAY_TIMEOUT);
  }

  setFullscreenData(state) {
    videoContainer.dataset['fullscreen'] = !!state;
  }
  /**
   * Reset poster
   * @param {Event} evt Node
   */
  resetPoster(evt) {
    /** @type {HTMLElement} **/
    const node = evt.target;
    const nodeName = node.tagName.toLowerCase();
    switch(nodeName) {
      case 'input':
      case 'button':
        break;
      case 'video':
        if(this.isPlaying()) videoPlayer.requestFullscreen();
        break;
      default:
        {
          evt.preventDefault();
          evt.stopPropagation();
          }
    }
    if(node.poster !== CONSTS.POSTER) {
      window.localStorage.removeItem('lastPlayedItem');
      this.stopVideo(true, true, node.poster);
    }
  }

  gotoNextPage() {
    const itemsToDisplay = filteredPlaylistData || [];
    if (currentPage < Math.ceil(itemsToDisplay.length / itemsPerPage)) {
      currentPage++;
      this.gotoPage(currentPage);
    }
  }

  gotoPrevPage() {
    if (currentPage > 1) {
      currentPage--;
      this.gotoPage(currentPage);
    }
  }
  /**
   * @param {string} id ID
   * @param {boolean} payload Data
   * @param {{ m3uUrl: string, fromCache: boolean, isBooting: boolean, onStart: () => void, onSuccess: (type: string, data: { id: string, m3u: string, source: string, type: string, time: number }, cached: boolean, isBooting: boolean) => Promise<void>, onCompleted: () => void }} options 参数对象
   */
  async fetchM3u(id, payload, options) {
    printLog('fetchM3u');
    options.onStart();
    m3uUrlInput.disabled = loadM3uButton.disabled = true;
    const { m3uUrl, fromCache = false, isBooting = false } = options;
    const type = (m3uUrl.endsWith('m3u') || m3uUrl.endsWith('m3u8')) ? TYPES.M3U : m3uUrl.endsWith('txt') ? TYPES.TXT : '';

    const safeUrl = (m3uUrl.startsWith(UNSAFE_HTTP) && CONSTS.IS_NATIVE === false) ? new URL(`${window.location.origin}/api/fetch?url=${encodeURIComponent(m3uUrl)}`).href : m3uUrl;
    try {
      const data = await this.makeRequest(safeUrl, { cache: 'no-store' });
      if (data) {
        const time = new Date().getTime();
        const x = { id, m3u: data, source: SOURCES.URL, type, time };
        if (payload) {
          await database.updateData(x);
        } else {
          await database.addData(x);
        }
        await options.onSuccess(type, x, fromCache, isBooting);
      }
      else {
        errorMessage.textContent = '加载 M3U 文件时出错，请检查 URL 是否正确。';
        this.showM3uInput();
      }
    } catch (error) {
      errorMessage.textContent = `加载 M3U 文件时出错，请检查 URL 是否正确。${error.message}`;
      this.showM3uInput();
    }
    finally {
      m3uUrlInput.disabled = loadM3uButton.disabled = false;
      options.onCompleted();
    }
  }
  /**
   * 加载 M3U 文件
   * @param {{ m3uUrl: string, fromCache: boolean, isBooting: boolean, onStart: () => void, onSuccess: (type: string, data: { id: string, m3u: string, source: string, type: string, time: number }, cached: boolean, isBooting: boolean) => Promise<void>, onCompleted: () => void }} options 参数对象
   */
  async loadM3uUrl(opts) {
    printLog('loadM3uUrl');
    /** @type {{ m3uUrl: string, fromCache: boolean, isBooting: boolean, onStart: () => void, onSuccess: (type: string, data: { id: string, m3u: string, source: string, type: string, time: number }, cached: boolean, isBooting: boolean) => Promise<void>, onCompleted: () => void }} **/
    const options = Object.assign({}, {
      m3uUrl: '', fromCache: false, isBooting: false,
      onStart: () => { },
      /**
       * @param {string} type Type
       * @param {{ id: string, m3u: string, source: string, type: string, time: number }} data Data
       * @param {boolean} cached Cached
       * @param {boolean} isBooting Is booting
       */
      onSuccess: (type, data, cached, isBooting) => { },
      onCompleted: () => { }
    }, opts);
    const { m3uUrl, fromCache = false, isBooting = false } = options;
    const type = (m3uUrl.endsWith('m3u') || m3uUrl.endsWith('m3u8')) ? TYPES.M3U : m3uUrl.endsWith('txt') ? TYPES.TXT : '';

    if (type && m3uUrlInput.checkValidity()) {
      const id = database.encodeString(m3uUrl);
      const { data: payload, error } = await database.readData(id);
      if(error) {
        errorMessage.textContent = '请输入有效的 M3U 文件 URL。';
        printLog('loadM3uFile.fetchDataAndProcess.error', error.message);
        return;
      }
      if (payload && payload.m3u && fromCache) {
        await this.processM3uData(type, payload, true, isBooting, false);
      } else {
        this.fetchM3u(id, payload, options);
      }
    }
    else {
      errorMessage.textContent = '请输入有效的 M3U 文件 URL。';
    }
  }

  // 执行搜索
  performSearch() {
    printLog('performSearch');
    const searchTerm = searchInput.value.toLowerCase();
    if (this.currentCategory === CONSTS.CHANNELS.ALL || this.currentCategory === CONSTS.CHANNELS.RAW) {
      filteredPlaylistData = categories[CONSTS.CHANNELS.RAW].filter(item => 
        item.title.toLowerCase().includes(searchTerm)
      );
    }
    else {
      filteredPlaylistData = categories[this.currentCategory].filter(item => 
        item.title.toLowerCase().includes(searchTerm)
      );
    }
    this.gotoPage(1);
  }

  // 刷新当前页面
  async refreshCurrentPage(transaction, isChecking = false) {
    if(isChecking) {
      //
    }
    else {
      appShell.showCheckButton(true);
      const lastPlayedItem = appShell.getLastVideoItem();

      const items = playlistItems.childNodes;
      for (let i = 0; i < items.length; i++) {
        /** @type {HTMLLIElement} */
        const li = items[i];
        if(li.classList.contains('frame') && onlyCheckBroken === 'true') {
          continue;
        }
        li.className = '';
      }

      for (let i = 0; i < items.length; i++) {
        /** @type {HTMLLIElement} */
        const li = items[i];
        if(li.classList.contains('frame') && onlyCheckBroken === 'true') {
          continue;
        }
        li.className = 'checking';
        const itemUrl = li.dataset['url'];
        const itemId = li.dataset['id'];

        if (itemUrl) {
          if(transaction === VARS.TRANSACTION) {
            const result = await this.checkVideoPlayability(itemUrl);
            const itemCode = await this.fetchPlayItemCode(itemId);
            const id = li.dataset['id'];
            await database.updateData({ id, result }, STA_STORE);
            this.updateListItemStyle(li, result, lastPlayedItem, itemCode);
          }
          else {
            li.className = '';
          }
        }
        else {
          li.classList.add('broken');
        }
      }
    }
    this.showCheckButton(false);
  }

  // 加载缓存的数据
  async startup() {
    await this.loadLocalCache();
    this.gotoPage(currentPage);
    this.playLastVideo(false);

    this.listStore('startup');
    this.initUI();

    this.generateBlankFrame();
    this.resetTitle();
  }

  displaySideMenu(show = false) {
    // Hide playlist
    if(show) {
      this.showPlaylistContent();
      pageBody.classList.add('menu');
    }
    // Show playlist
    else {
      pageBody.classList.remove('menu');
      this.displayPlayerControls();
    }
    window.localStorage.setItem('playListVisible', show ? 'true' : 'false');
  }

  async addFavorite(id, url, title, group, code = CONSTS.CODES.LIKE) {
    await database.addData({ id, url, title, group, code }, FAV_STORE);
    this.refreshFavoriteButton(code);
    this.refreshDislikeButton(code);
    this.initializePlaylist();
  }

  async deleteFavorite(id) {
    const { data, error } = await database.deleteData(id, FAV_STORE);
    if(error) {
      printLog('deleteFavorite.error', error);
    }
    this.refreshFavoriteButton(CONSTS.CODES.NONE);
    this.refreshDislikeButton(CONSTS.CODES.NONE);
    this.initializePlaylist();
  }

} // End of class

class WebShell extends AppShell {
  initUI() {
    super.initUI();
    pinButton.remove();
  }
}

class ElectronShell extends AppShell {
  SITE_TITLE = 'Hunhe IPTV | v1.0';
  async makeRequest(url, options = {}) {
    return new Promise((resolve, reject) => {
      const response = window['electronAPI'].makeRequest(url, options);
      if(response.error) {
        reject(response.error);
      }
      else if(response.data) {
        resolve(response.data);
      }
      else {
        reject({});
      }
    });
  }

  changeTitle(title) {
    window['electronAPI'].changeTitle(title);
  }
  putOnTop(isOnTop) {
    window['electronAPI'].putOnTop(isOnTop);
  }
}

/** @type {AppShell} **/
const appShell = CONSTS.IS_NATIVE ? new ElectronShell() : new WebShell();

appShell.initUI();

/**
 * @param {Array<any>} args Arguments
 */
function printLog(...args) {
  if(enableLogging === 'true') {
    debugLogs.innerHTML = `$ ${args.join(' ')}\n`.concat(debugLogs.innerHTML);
    logClearButton.classList.remove('hidden');
  }
}

favoriteButton.addEventListener('click', async (evt) => {
  const id = favoriteButton.dataset['id'];
  const url = favoriteButton.dataset['url'];
  const group = favoriteButton.dataset['group'];
  const title = favoriteButton.dataset['title'];
  const isAddingData = favoriteButton.dataset['action'] === 'add';
  const isDeletingData = favoriteButton.dataset['action'] === 'remove';
  if(isAddingData) {
    appShell.addFavorite(id, url, title, group, CONSTS.CODES.LIKE);
  }
  else if(isDeletingData) {
    appShell.deleteFavorite(id);
  }
});

dislikeButton.addEventListener('click', async (evt) => {
  const id = dislikeButton.dataset['id'];
  const url = dislikeButton.dataset['url'];
  const group = dislikeButton.dataset['group'];
  const title = dislikeButton.dataset['title'];
  const isAddingData = dislikeButton.dataset['action'] === 'add';
  const isDeletingData = dislikeButton.dataset['action'] === 'remove';
  if(isAddingData) {
    appShell.addFavorite(id, url, title, group, CONSTS.CODES.DISLIKE);
  }
  else if(isDeletingData) {
    appShell.deleteFavorite(id);
  }
});

reCaptureButton.addEventListener('click', async (evt) => {
  const url = reCaptureButton.dataset['url'];
  const group = favoriteButton.dataset['group'];
  const title = favoriteButton.dataset['title'];
  const id = favoriteButton.dataset['id'];

  reCaptureButton.disabled = true;
  const result = await appShell.checkVideoPlayability(url, true);
  await database.updateData({ id, result }, STA_STORE);
  const itemCode = await appShell.fetchPlayItemCode(id);
  for(const node of playlistItems.childNodes) {
    if(node.dataset['url'] === url) {
      appShell.updateListItemStyle(node, result, null, itemCode);
      appShell.changePoster(node.dataset['frame']);
      break; 
    }
  }
  reCaptureButton.disabled = false;
});

pinButton.addEventListener('click', async (evt) => {
  VARS.ALWAYS_ON_TOP = !VARS.ALWAYS_ON_TOP;
  appShell.putOnTop(VARS.ALWAYS_ON_TOP);
  if(VARS.ALWAYS_ON_TOP) {
    pinButton.innerHTML = CONSTS.ICON_PINNED;
    pinButton.classList.add('pinned');
  }
  else {
    pinButton.innerHTML = CONSTS.ICON_UNPINNED;
    pinButton.classList.remove('pinned');
  }
});

loadM3uButton.addEventListener('click', (evt) => {
  appShell.loadM3uFile(false);
});

closeM3uButton.addEventListener('click', (evt) => {
  appShell.showM3uInput();
});

settingsButton.addEventListener('click', (evt) => {
  appShell.showM3uInput();
  appShell.muteOrUnmuteVideo(true);
});

prevButton.addEventListener('click', (evt) => {
  evt.preventDefault();
  appShell.gotoPrevPage();
});
prevButton.addEventListener('dblclick', (evt) => {
  evt.preventDefault();
  appShell.gotoPrevPage();
});

nextButton.addEventListener('click', (evt) => {
  evt.preventDefault();
  appShell.gotoNextPage();
});
nextButton.addEventListener('dblclick', (evt) => {
  evt.preventDefault();
  appShell.gotoNextPage();
});

pageControl.addEventListener('change', (evt) => {
  appShell.gotoPage(parseInt(evt.target.value));
  document.getElementById('pageCurrent').textContent = currentPage;
});
pageControl.addEventListener('input', (evt) => {
  document.getElementById('pageCurrent').textContent = parseInt(evt.target.value);
});

searchContainer.addEventListener('submit', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  if(searchContainer.checkValidity())
    appShell.performSearch();
});

searchInput.addEventListener('keyup', (evt) => {
  if(evt.target.value === '') {
    clearButton.classList.add('hidden');
  }
  else {
    clearButton.classList.remove('hidden');
  }
});

searchInput.addEventListener('input', function() {
  if (this.value === '') {
    // 清空搜索关键字后，恢复到当前类别的播放列表
    filteredPlaylistData = categories[appShell.currentCategory === CONSTS.CHANNELS.ALL ? CONSTS.CHANNELS.RAW : appShell.currentCategory];
    appShell.gotoPage(1);
  }
  searchInput.dispatchEvent(new Event('keyup'));
});

m3uUrlInput.addEventListener('blur', (evt) => {
  appShell.detectM3uUrl();
});
m3uUrlInput.addEventListener('keyup', (evt) => {
  appShell.detectM3uUrl();
});
m3uUrlInput.addEventListener('input', (evt) => {
  appShell.detectM3uUrl();
});

clearButton.addEventListener('click', (evt) => {
  evt.preventDefault();
  searchInput.value = '';
  appShell.performSearch();
  searchInput.dispatchEvent(new Event('keyup'));
});

closeButton.addEventListener('click', (evt) => {
  playListButton.dispatchEvent(new Event('click'));
});
m3uInputContainer.addEventListener('click', (evt) => {
  if(evt.target.id === 'm3uInputContainer') {
    closeM3uButton.dispatchEvent(new Event('click'));
  }
});

m3uInputContainer.addEventListener('dblclick', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
});

listCheckButton.addEventListener('click', (evt) => {
  appShell.refreshCurrentPage(VARS.TRANSACTION = crypto.randomUUID(), listCheckButton.classList.contains('checking'));
});

videoPlayer.addEventListener('timeupdate', (evt) => {
  if(videoPlayer.src === stopURL) { return; }

  const lastPlayedItem = appShell.getLastVideoItem();
  if(lastPlayedItem) {
    /** @type {HTMLVideoElement} **/
    const player = evt.target;
    progressControl.value = player.currentTime;
    appShell.setVideoTimestamp(player.currentTime);
    if (progressControl.max === '0' && player.duration) {
      progressControl.max = player.duration;
      totalTimeDisplay.textContent = appShell.getMinutes(player.duration);
    }
    currentTimeDisplay.textContent = appShell.getMinutes(player.currentTime);
  }
});
videoPlayer.addEventListener('pause', (evt) => {
  printLog('videoPlayer.pause');
  appShell.onStopped();
});

videoPlayer.addEventListener('seeked', (evt) => {
  const lastPlayedItem = appShell.getLastVideoItem();
  printLog('videoPlayer.seeked', videoPlayer.currentTime, evt.target.currentTime);
  if(lastPlayedItem) {
    printLog('lastPlayedItem.seeked', videoPlayer.currentTime, evt.target.currentTime);
    appShell.setVideoTimestamp(videoPlayer.currentTime);
  }
});
videoPlayer.addEventListener('canplay', (evt) => {
  printLog('videoPlayer.canplay');
});
videoPlayer.addEventListener('play', (evt) => {
  printLog('videoPlayer.play');
  appShell.onPlaying();
});
videoPlayer.addEventListener('loadeddata', (evt) => {
  printLog(`videoPlayer.loadeddata - ${videoPlayer.readyState}`);
  if(videoPlayer.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA)
    appShell.displayPlayerControls(true, true);
});
videoPlayer.addEventListener('playing', (evt) => {
  printLog(`videoPlayer.playing - ${videoPlayer.networkState}`);
});
videoPlayer.addEventListener('emptied', (evt) => {
  printLog('videoPlayer.emptied');
});
videoPlayer.addEventListener("stalled", (evt) => {
  /** @type {HTMLVideoElement} */
  const player = evt.target;
  printLog('videoPlayer.stalled', player.paused);
  if(player.paused) {
    appShell.onStopped();
  }
});

videoPlayer.addEventListener("suspend", (evt) => {
  printLog('videoPlayer.suspend');
});

videoPlayer.addEventListener('waiting', (evt) => {
  printLog('videoPlayer.waiting');
  playVideoButton.className = 'playing';
  playVideoButton.innerHTML = CONSTS.ICON_CANCEL;
  playVideoButton.disabled = false;
});
videoPlayer.addEventListener('canplaythrough', (evt) => {
  printLog('videoPlayer.canplaythrough');
  appShell.onPlaying();
});
videoPlayer.addEventListener('ended', (evt) => {
  printLog('videoPlayer.ended');
  appShell.onStopped(true);
});
videoPlayer.addEventListener('error', (evt) => {
  printLog('videoPlayer.error');
  if(videoPlayer.src === stopURL) {
    appShell.showPlayButton();
    return;
  }
  errorMessage.textContent = '加载视频时出错，请尝试其他源或检查网络连接。';
});
['mouseover', 'touchstart'].forEach(eventType => {
  [videoPlayer, videoControls].forEach(element => {
    element.addEventListener(eventType, () => {
      clearTimeout(VARS.CONTROL_TIMER);
      appShell.displayPlayerControls(true, true);
    }, { passive: true });
  });
});
['mouseout', 'touchend'].forEach(eventType => {
  [videoPlayer, videoControls].forEach(element => {
    element.addEventListener(eventType, () => {
      clearTimeout(VARS.CONTROL_TIMER);
      VARS.CONTROL_TIMER = setTimeout(appShell.displayPlayerControls, CONSTS.CONTROL_DISPLAY_TIMEOUT);
    });
  });
});
[videoPlayer, videoControls].forEach(element => {
  element.addEventListener('touchcancel', () => {
    clearTimeout(VARS.CONTROL_TIMER);
    VARS.CONTROL_TIMER = setTimeout(appShell.displayPlayerControls, CONSTS.CONTROL_DISPLAY_TIMEOUT);
  });
});
videoPlayer.addEventListener('click', (evt) => {
  clearTimeout(VARS.CONTROL_TIMER);
  if(videoControls.classList.contains('transparent')) {
    appShell.displayPlayerControls(true, true);
  }
  else {
    appShell.displayPlayerControls();
  }
});

videoPlayer.addEventListener('dblclick', (evt) => {
  appShell.resetPoster(evt);
});

progressControl.addEventListener('change', (evt) => {
  const value = evt.target.value;
  const currentTime = parseFloat(value);
  printLog('progressControl.change', currentTime);
});

progressControl.addEventListener('input', (evt) => {
  const value = evt.target.value;
  try {
    const currentTime = parseFloat(value);
    currentTimeDisplay.textContent = appShell.getMinutes(currentTime);
    if (!isNaN(currentTime) && !Number.isNaN(currentTime)) {
      videoPlayer.currentTime = currentTime;
    }
  } catch (error) {}
});

playVideoButton.addEventListener('click', (evt) => {
  if(appShell.isPlaying()) {
    appShell.stopVideo(false);
  }
  else {
    appShell.playLastVideo();
  }
});

pauseVideoButton.addEventListener('click', (evt) => {
  if(videoPlayer.paused) {
    videoPlayer.play().then(() => {
      
    }).catch(error => {
      
    });
  }
  else {
    videoPlayer.pause();
  }
});

speakerButton.addEventListener('click', (evt) => {
  appShell.muteOrUnmuteVideo(!videoPlayer.muted);
});

fullscreenButton.addEventListener('click', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();

  if (document.fullscreenElement === null && document.fullscreenEnabled) {
    // The document is not in fullscreen mode
    videoPlayer.requestFullscreen();
    appShell.setFullscreenData(true);
  } else {
    // The document is in fullscreen mode
    document.exitFullscreen();
    appShell.setFullscreenData(false);
  }
});

rewindButton.addEventListener('click', (evt) => {
  appShell.seekVideo(-30);
});

forwardButton.addEventListener('click', (evt) => {
  appShell.seekVideo(30);
});

playListButton.addEventListener('click', (evt) => {
  appShell.displaySideMenu(pageBody.classList.contains('menu') === false);
});

storeFrameCheckbox.addEventListener('change', (evt) => {
  storeFrame = evt.target.checked ? 'true' : 'false';
  window.localStorage.setItem('storeFrame', storeFrame);
  screenshotTime.disabled = !evt.target.checked;
});
autoCheckCheckbox.addEventListener('change', (evt) => {
  autoCheck = evt.target.checked ? 'true' : 'false';
  window.localStorage.setItem('autoCheck', autoCheck);
});
checkTimeout.addEventListener('input', (evt) => {
  VARS.PING_TIMEOUT = parseInt(evt.target.value) * 1000;
  checkTimeoutDisplay.textContent = evt.target.value;
  window.localStorage.setItem('PING_TIMEOUT', VARS.PING_TIMEOUT);
});

screenshotTime.addEventListener('input', (evt) => {
  VARS.SCREENSHOT_TIME = parseInt(evt.target.value);
  screenshotTimeDisplay.textContent = evt.target.value;
  window.localStorage.setItem('screenshotTime', VARS.SCREENSHOT_TIME);
});

onlyCheckBrokenCheckbox.addEventListener('change', (evt) => {
  onlyCheckBroken = evt.target.checked ? 'true' : 'false';
  window.localStorage.setItem('onlyCheckBroken', onlyCheckBroken);
});

enableLoggingCheckbox.addEventListener('change', (evt) => {
  enableLogging = evt.target.checked ? 'true' : 'false';
  window.localStorage.setItem('enableLogging', enableLogging);
  if(enableLogging === 'true') {
    logContainer.classList.remove('hidden');
  }
  else {
    logContainer.classList.add('hidden');
  }
});

muteWhenPlayCheckbox.addEventListener('change', (evt) => {
  muteWhenPlay = evt.target.checked ? 'true' : 'false';
  window.localStorage.setItem('muteWhenPlay', muteWhenPlay);
});

logClearButton.addEventListener('click', (evt) => {
  logClearButton.classList.add('hidden');
  debugLogs.innerHTML = '> 日志';
});

commentsForm.addEventListener('submit', async (evt) => {
  evt.preventDefault();
  const lastPlayedItem = appShell.getLastVideoItem();
  if(lastPlayedItem) {
    const id = database.encodeString(lastPlayedItem.url);
    axios.post(`${CONSTS.BASE_URL}/api/tv/comments/${id}`, {
      content: commentsInput.value
    })
    .catch(error => {
      printLog('comments.error->', error.message);
    })
    .then(response => {
      commentsInput.value = '';
      commentsInput.focus();
      commentsInput.dispatchEvent(new Event('input'));
      appShell.loadComments(id, lastPlayedItem.title);
    });
  }
});

commentsInput.addEventListener('input', (evt) => {
  const isOK =  evt.target.value.length > 0;
  commentsButton.disabled = isOK ? false : true;
});

channelButton.addEventListener('click', (evt) => {
  appShell.switchChannel();
});

[bottomControls, paginationGroup].forEach(element => {
  window.swipe(element).on('swipeLeft', (evt) => {
    appShell.displaySideMenu(false);
  });
})

window.swipe(bottomControls).on('swipeRight', (evt) => {
  appShell.displaySideMenu(true);
});

window.swipe(videoPlayer).on('swipeRight', (evt) => {
  appShell.seekVideo(30);
});

window.swipe(videoPlayer).on('swipeLeft', (evt) => {
  appShell.seekVideo(-30);
});

let isGloballyHidden = false;
document.addEventListener('keydown', function (event) {
  if (event.key === 'Escape' || event.keyCode === 27) {
    event.preventDefault();
    if(isGloballyHidden) {
      pageContainer.className = 'container';
    }
    else {
      pageContainer.className = 'hidden';
      appShell.muteOrUnmuteVideo(true);
      videoPlayer.pause();
    }
    isGloballyHidden = !isGloballyHidden;
  }
  else if(event.key === 'ArrowLeft' || event.keyCode === 37) {
    event.preventDefault();
    appShell.seekVideo(-30);
  }
  else if(event.key === 'ArrowRight' || event.keyCode === 39) {
    event.preventDefault();
    appShell.seekVideo(30);
  }
  else if (event.key === 'ArrowUp' || event.keyCode === 38) {
    event.preventDefault();
    appShell.seekVideo(60);
  }
  else if (event.key === 'ArrowDown' || event.keyCode === 40) {
    event.preventDefault();
    appShell.seekVideo(-60);
  }
});
document.addEventListener('dblclick', (evt) => {
  appShell.resetPoster(evt);
});
window.addEventListener('beforeunload', (evt) => {
  appShell.saveVideoTimestamp();
});

// 初始化
window.addEventListener('DOMContentLoaded', (evt) => {
  appShell.startup();
});

</script>
</body>
</html>
