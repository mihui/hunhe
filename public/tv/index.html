<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <title>Hunhe TV</title>
<style>
html {
  background: url(background.jpeg) no-repeat center center;
}
html, body {
  width: 100%;
  height: 100%;
}
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0;
  background: transparent;
  color: #333;
  margin: 0;
  position: relative;
  overflow: hidden;
  align-items: center;
  background-size: cover;
}
  .container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-flow: row;
    align-items: flex-start;
    margin: 0px;
    position: relative;
  }
  .container .video-container {
    flex: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    min-width: 300px;
    width: 100%;
    height: 100%;
  }
    .container .video-container .video-wrapper {
      box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      width: 100%;
      max-height: 100%;
      min-width: 300px;
      height: auto;
      background-color: #333;
    }
    .container .video-container #videoPlayer {
      width: 100%;
      max-height: 100%;
      height: auto;
    }
    .container .video-container .video-control {
      flex: 1;
      align-items: flex-start;
      display: flex;
      column-gap: 1rem;
      justify-content: space-between;
      width: 100%;
      flex-flow: column;
      row-gap: 0.5rem;
    }

    .container .video-container .video-control .controls {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-flow: row;
      column-gap: 1rem;
    }

    .container #pagination {
      display: flex;
      justify-content: space-between;
      align-items: center;
      column-gap: 1rem;
      flex: 0;
      width: 100%;
      margin-top: 14px;
    }

    .container #playlistContainer {
      min-width: 300px;
      width: 100%;
      flex: 1;
      height: 100%;
      display: flex;
      /* position: absolute; */
      z-index: 10;
    }
    .container #playlistContainer.settings {
      flex: 3;
    }

textarea, #categorySelect, #searchInput, #searchButton, #clearButton, #closeButton, #m3uInput, #loadM3uButton, #closeM3uButton, #loadContentuButton, #m3uContentKey {
  width: 100%;
  padding: 12px;
  margin-bottom: 15px;
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: 16px;
  -webkit-appearance: none;
  box-sizing: border-box;
}

#searchContainer {
  display: flex;
}

#searchInput {
  flex-grow: 1;
  border-right: none;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

textarea:focus-visible,
input:focus-visible,
select:focus-visible {
  outline: 1px solid #ddd;
}

#searchButton {
  border-radius: 0px;
}

#searchButton, #clearButton, #closeButton {
  width: auto;
  background-color: #3498db;
  color: white;
  border: none;
  cursor: pointer;
  white-space: nowrap;
}

#clearButton {
  border-radius: 0px;
  background-color: #39db34;
}
#closeButton {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
  background-color: #db6634;
}

#playlistItems {
  list-style-type: none;
  padding: 0px;
  margin: 0px;
  display: flex;
  flex-flow: column;
  flex: 1;
  row-gap: 0.3rem;
  justify-content: space-evenly;
  overflow: auto;
}

#playlistItems li {
  cursor: pointer;
  background-color: #f1f1f1;
  border-radius: 8px;
  padding: 0.5rem 0.9rem;
  height: 100%;
  min-height: 1rem;
  transition: background-color 0.2s;
  white-space: nowrap;
  overflow: auto;
  overflow-y: hidden;
  text-overflow: ellipsis;
  display: flex;
  align-items: center;
  scrollbar-width: none;
  border-left: 3px solid gray;
  user-select: none;
}
  #playlistItems li:nth-of-type(even) {
    background-color: transparent;
  }

  #playlistItems li:hover {
    background-color: #e9ecef;
  }
  #playlistItems li::-webkit-scrollbar { 
    display: none;
  }
  #playlistItems li.good {
    border-left: 3px solid green;
  }
  #playlistItems li.average {
    border-left: 3px solid orange;
  }

  #playlistItems li.bad {
    border-left: 3px solid red;
  }
  #playlistItems li.active {
    font-weight: bold;
  }
  #playlistItems li div {
    width: 100%;
  }

button {
  user-select: none;
  padding: 10px 20px;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  white-space: nowrap;
}

#pagination button, .controls button {
  flex: 1;
}
#pagination button {
  font-size: 16px;
  border-radius: 4px;
  flex: 0;
  background-color: darkgreen;
}

#pagination button:disabled,
#clearButton:disabled, #loadM3uButton:disabled,
#favoriteButton:disabled, #refreshPage:disabled,
#fullscreenButton:disabled {
  background-color: #bdc3c7;
}

#pageInfo {
  font-size: 16px;
  white-space: nowrap;
  width: 100%;
  flex: 0;
  text-align: center;
}

#errorMessage {
  color: #e74c3c;
  text-align: center;
  flex: 1;
  width: 100%;
}

@media (min-width: 768px) {
  #videoPlayer {
    width: 640px;
  }

  #playlistContainer {
    width: 640px;
  }
}

#loadM3uButton {
  background-color: #3498db;
  color: white;
  border: none;
  cursor: pointer;
}

#reloadM3uButton {
  background-color: #2ecc71;
}
#favoriteButton {
  background-color: #952ecc;
}
#sideButton {
  background-color: #2e6bcc;
}
#fullscreenButton {
  background-color: darkblue;
}
#refreshPage {
  background-color: orange;
}
#playVideoButton {
  background-color: blueviolet;
}
#playVideoButton.playing {
  background-color: darkmagenta;
}
#playVideoButton.played {
  background-color: #e74c3c;
}

#m3uList {
  display: flex;
  column-gap: 1rem;
  flex-flow: column;
}

#m3uList div {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 4px;
}
  #m3uList div.active {
    background-color: #fff;
  }
#m3uList div a {
  cursor: pointer;
  padding: 0.5rem 0.8rem;
  border-radius: 4px;
}
  #m3uList div a:hover {
    background-color: #eee;
  }
  #m3uList div a.load {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 0.9rem;
  }
  #m3uList div a.delete {
    color: #e74c3c;
    opacity: 0.6;
    transition: all 1s;
  }
  #m3uList div a.delete:hover {
    background-color: #fbe3e3;
    opacity: 1;
  }
#m3uContentKey {
  margin-top: 1rem;
}
#m3uContent {
  resize: vertical;
}

#playlistContent {
  display: flex;
  flex-flow: column;
  display: none;
  height: 100%;
}

.hidden {
  display: none !important;
}
.box {
  display: flex;
  flex-flow: column;
  width: 100%;
  flex: 1;
  position: relative;
  background-color: rgba(237, 237, 237, 0.85);
  border-radius: 0px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  box-sizing: border-box;
  overflow: auto;
  padding: 0.5rem;
  column-gap: 0.6rem;
  row-gap: 0.6rem;
}

#pageControl {
  -webkit-appearance: none;
  width: 100%;
  height: 15px;
  border-radius: 5px;  
  background: #b5b5b5;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

/* Mouse-over effects */
#pageControl:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
#pageControl::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 25px;
  height: 25px;
  border-radius: 50%; 
  background: darkgreen;
  cursor: pointer;
}

#pageControl::-moz-range-thumb {
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #04AA6D;
  cursor: pointer;
}
.m3u-controls {
  display: flex;
  column-gap: 1rem;
  flex-flow: row;
}
  .m3u-controls #closeM3uButton {
    background-color: #db6634;
  }
.page-information {
  flex: 1;
}
</style>
</head>

<body>
  <div class="container" id="pageContainer">
    <div id="playlistContainer" class="hidden">
      <div class="box">
        <div id="m3uInputContainer" style="display: none;">
          <input type="url" id="m3uInput" placeholder="输入 M3U 文件 URL">
          <div class="m3u-controls">
            <button id="loadM3uButton">加载播放列表</button>
            <button id="closeM3uButton">关闭</button>
          </div>

          <div id="m3uList"></div>

          <input type="text" id="m3uContentKey" placeholder="Key" value="Content">
          <textarea id="m3uContent"></textarea>
          <button id="loadContentuButton">读取内容</button>
        </div>
        <div id="playlistContent">
          <form id="searchContainer">
            <input type="text" id="searchInput" placeholder="搜索...">
            <button type="submit" id="searchButton">搜索</button>
            <button type="reset" id="clearButton" disabled>重置</button>
            <button type="button" id="closeButton">关闭</button>
          </form>
          <select id="categorySelect"></select>
          <ul id="playlistItems"></ul>
          <div class="controls">
            <div id="pagination">
              <button id="prevPage" disabled>上一页</button>
              <div class="page-information">
                <input id="pageControl" min="1" type="range" />
                <div id="pageInfo"></div>
              </div>
              <button id="nextPage" disabled>下一页</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="video-container">
      <div class="box">
        <div class="video-wrapper"><video id="videoPlayer" playsinline></video></div>
        <div class="video-control">
          <div class="controls">
            <button id="playVideoButton" class="stopped">播放</button>
            <button id="fullscreenButton" disabled>全屏</button>
            <button id="rewindButton">后退</button>
            <button id="forwardButton">前进</button>
          </div>

          <div class="controls" id="errorControl">
            <div id="errorMessage"></div>
          </div>

          <div class="controls">
            <button id="reloadM3uButton">设置</button>
            <button id="refreshPage">检测</button>
            <button id="favoriteButton" disabled>收藏</button>
            <button id="sideButton">列表</button>
          </div>
        </div>
        
      </div>
    </div>
  </div>
<script>
const DB_VERSION = 4;
const SITE_TITLE = 'Hunhe IPTV';
// M3U list store
const M3U_STORE = 'm3u-store';
// Favorites
const FAV_STORE = 'fav-store';
// The status cache of the playlist item
const STA_STORE = 'sta-store';

const UNSAFE_HTTP = 'http://';
const TYPES = {
  M3U: 'm3u', TXT: 'txt'
};
const SOURCES = {
  URL: 'url', CONTENT: 'content'
};

const database = {
  openDB: (dbName = 'm3u') => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(dbName, DB_VERSION);
      request.onblocked = (event) => {
        // If some other tab is loaded with the database, then it needs to be closed
        // before we can proceed.
      };

      request.onupgradeneeded = (event) => {
        /** @type {IDBDatabase} **/
        const db = event.target.result;
        try {
          db.createObjectStore(M3U_STORE, { keyPath: "id" });
        }
        catch(error) {}

        try {
          db.createObjectStore(FAV_STORE, { keyPath: "id" });
        }
        catch(error) {}

        try {
          db.createObjectStore(STA_STORE, { keyPath: "id" });
        }
        catch(error) {}

        db.onversionchange = (event) => {
          db.close();
        };
      };

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        reject(event.target.error);
      };
    });
  },
  addData: async (data, storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readwrite");
    const store = transaction.objectStore(storeName);
    const request = store.add(data);

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  readData: async (id, storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readonly");
    const store = transaction.objectStore(storeName);
    const request = store.get(id);

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  updateData: async (data, storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readwrite");
    const store = transaction.objectStore(storeName);
    const request = store.put(data);

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  deleteData: async (id, storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readwrite");
    const store = transaction.objectStore(storeName);
    const request = store.delete(id);

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  listData: async (storeName = M3U_STORE) => {
    const db = await database.openDB();
    const transaction = db.transaction(storeName, "readonly");
    const store = transaction.objectStore(storeName);
    let request = store.openCursor();
    const list = [];
    return new Promise((resolve, reject) => {
      request.onsuccess = (evt) => {
        const cursor = evt.target.result;
        if(cursor) {
          // const path = database.decodeString(cursor.key);
          // const pathSegments = path.split('/');
          // const fileName = pathSegments[pathSegments.length - 1];
          list.push(cursor.value);
          cursor.continue();
        }
        else {
          resolve(list);
        }
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  },
  encodeString: (plainText) => {
    const base64Encoded = btoa(unescape(encodeURIComponent(plainText)));
    return base64Encoded;
  },
  decodeString: (encodedText) => {
    const decodedText = decodeURIComponent(escape(atob(encodedText)));
    return decodedText;
  }
};

const allChannels = '所有频道';
const originalChannels = '原始所有频道';
const favoriteChannels = '收藏频道';
/** @type {HTMLVideoElement} **/
const videoPlayer = document.getElementById('videoPlayer');
/** @type {HTMLDivElement} **/
const errorMessage = document.getElementById('errorMessage');
/** @type {HTMLDivElement} **/
const errorControl = document.getElementById('errorControl');
const m3uInput = document.getElementById('m3uInput');
/** @type {HTMLButtonElement} **/
const closeM3uButton = document.getElementById('closeM3uButton');
/** @type {HTMLButtonElement} **/
const loadM3uButton = document.getElementById('loadM3uButton');
const reloadM3uButton = document.getElementById('reloadM3uButton');
const m3uInputContainer = document.getElementById('m3uInputContainer');
const playlistContent = document.getElementById('playlistContent');
const playlistContainer = document.getElementById("playlistContainer");
/** @type {HTMLButtonElement} **/
const playVideoButton = document.getElementById("playVideoButton");
const m3uList = document.getElementById('m3uList');
const searchContainer = document.getElementById('searchContainer');
/** @type {HTMLButtonElement} **/
const favoriteButton = document.getElementById('favoriteButton');
/** @type {HTMLButtonElement} **/
const sideButton  = document.getElementById('sideButton');

/** @type {HTMLButtonElement} **/
const rewindButton = document.getElementById('rewindButton');
/** @type {HTMLButtonElement} **/
const forwardButton = document.getElementById('forwardButton');

/** @type {HTMLInputElement} **/
const searchInput = document.getElementById('searchInput');
const fullscreenButton = document.getElementById('fullscreenButton');

const prevButton = document.getElementById('prevPage');
const nextButton = document.getElementById('nextPage');
const pageInfo = document.getElementById('pageInfo');

/** @type {HTMLInputElement} **/
const pageControl = document.getElementById('pageControl');

/** @type {HTMLButtonElement} **/
const clearButton = document.getElementById('clearButton');
/** @type {HTMLButtonElement} **/
const closeButton = document.getElementById('closeButton');
/** @type {HTMLTextAreaElement} **/
const m3uContent = document.getElementById('m3uContent');
/** @type {HTMLInputElement} **/
const m3uContentKey = document.getElementById('m3uContentKey');
const loadContentuButton = document.getElementById('loadContentuButton');
/** @type {HTMLSelectElement} **/
const categorySelect = document.getElementById('categorySelect');
/** @type {HTMLUListElement} **/
const playlistItems = document.getElementById('playlistItems');
/** @type {HTMLDivElement} **/
const paginationGroup = document.getElementById('pagination');

/** @type {Array<{ title: string, url: string, group: string }>} **/
let playlistData = [];
let currentPage = 1;
const itemsPerPage = 15;
/** @type {Object.<string, Array<{ title: string, group: string, url: string }>>} **/
let categories = {};
let currentCategory = allChannels;
let filteredPlaylistData = [];

const stopURL = URL.createObjectURL(new Blob());

async function listStore(source) {

  const cachedM3uSource = localStorage.getItem('cachedM3uSource') || SOURCES.URL;
  const cachedM3uUrl = localStorage.getItem('cachedM3uUrl') || '';

  m3uList.innerHTML = '';

  /** @type {Array<{ key: string, id: string, source: string }>} */
  const list = await database.listData();
  for(const m3uItem of list) {
    const url = database.decodeString(m3uItem.id);
    const isCurrent = cachedM3uUrl.includes(url) || (cachedM3uSource === SOURCES.CONTENT && m3uItem.source === SOURCES.CONTENT && cachedM3uUrl.includes(url));

    const divItem = document.createElement('div');
    const aItem = document.createElement('a');
    const dItem = document.createElement('a');
    dItem.innerText = '删';
    dItem.className = 'delete';
    dItem.dataset['id'] = m3uItem.id;
    dItem.ondblclick = async (evt) => {
      evt.preventDefault();
      await database.deleteData(evt.target.dataset['id']);
      listStore('click');
    };
    aItem.innerText = url;
    aItem.className = 'load';
    aItem.dataset['id'] = m3uItem.id;
    aItem.onclick = async (evt) => {
      const element = evt.target;
      const data = await database.readData(element.dataset['id']);
      if(data.source === SOURCES.CONTENT) {
        m3uInput.value = '';
        m3uContent.value = data.m3u;
      }
      else if(data.source === SOURCES.URL) {
        m3uInput.value = database.decodeString(m3uItem.id);
      }
      gotoPage(1);
      processM3uData(data.type || TYPES.M3U, data.m3u);
      refreshPage.disabled = false;
    };
    divItem.append(aItem);
    if(isCurrent) {
      divItem.classList.add('active');
    }
    else {
      divItem.append(dItem);
    }
    m3uList.append(divItem);
  }

}

async function loadPlayabilityCache() {
}

// 加载缓存的数据
async function loadCachedData() {
  const cachedM3uUrl = localStorage.getItem('cachedM3uUrl') || '';
  if (cachedM3uUrl) {
    m3uInput.value = cachedM3uUrl;
    await loadM3uFile(true); // 添加一个参数来表示这是从缓存加载
  } else {
    await showM3uInput();
  }

  await loadPlayabilityCache();

  currentPage = parseInt(localStorage.getItem('currentPage')) || 1;
  currentCategory = localStorage.getItem('currentCategory') || allChannels;
  gotoPage(currentPage);

  playLastVideo(false);

  listStore('loadCachedData');
}

function playLastVideo(isUserAction = true) {
  const lastPlayedUrl = localStorage.getItem('lastPlayedUrl');
  const lastPlayedTime = parseFloat(localStorage.getItem('lastPlayedTime'));
  if (lastPlayedUrl) {
    playVideo(lastPlayedUrl, isUserAction);
    if (!isNaN(lastPlayedTime)) {
      videoPlayer.currentTime = lastPlayedTime;
    }
  }
}

// 保存数据到缓存
function saveDataToCache() {
  localStorage.setItem('cachedM3uUrl', m3uInput.value);
  localStorage.setItem('currentPage', currentPage);
  localStorage.setItem('currentCategory', currentCategory);
}

// 显示播放列表内容
function showPlaylistContent() {
  m3uInputContainer.style.display = 'none';
  playlistContent.style.display = 'flex';
  playlistContainer.className = '';
}

// 显示 M3U 输入界面
async function showM3uInput() {
  errorControl.classList.remove('hidden');
  window.localStorage.setItem('playListVisible', 'true');

  if(m3uInputContainer.style.display === 'block') {
    m3uInputContainer.style.display = 'none';
    playlistContent.style.display = 'flex';
    refreshPage.disabled = false;
    playlistContainer.className = '';
  }
  else {
    m3uInputContainer.style.display = 'block';
    playlistContent.style.display = 'none';
    refreshPage.disabled = true;
    await listStore('showM3uInput');
    playlistContainer.className = 'settings';
  }
}

function processM3uData (type, data, fromCache = false) {
  initPlayData(type, data);
  initializeCategories();
  initializePlaylist();
  showPlaylistContent();
  if (!fromCache) {
    saveDataToCache();
  }
  errorMessage.textContent = '';
}

// 加载 M3U 文件
async function loadM3uFile(fromCache = false) {
  /** @type {string} **/
  const m3uUrl = m3uInput.value.trim();
  const type = m3uUrl.endsWith('m3u') || m3uUrl.endsWith('m3u8') ? TYPES.M3U : m3uUrl.endsWith('txt') ? TYPES.TXT : '';

  if (type) {
    const id = database.encodeString(m3uUrl);
    const payload = await database.readData(id);
    if(payload && payload.m3u && fromCache) {
      processM3uData(type, payload.m3u, true);
    }
    else {
      loadM3uButton.disabled = true;
      const url = m3uUrl.startsWith(UNSAFE_HTTP) ? `/api/fetch?url=${m3uUrl}` : m3uUrl;
      fetch(url).then(response => {
        if(response.status === 200 || response.status === 202 || response.status === 302) {
          return response.text();
        }
        return null;
      })
      .then(async data => {
        loadM3uButton.disabled = false;
        if(data) {
          if(payload) {
            await database.updateData({ id, m3u: data, source: SOURCES.URL, type });
          }
          else {
            await database.addData({ id, m3u: data, source: SOURCES.URL, type });
          }
          processM3uData(type, data, fromCache);
          listStore('fetch');
          gotoPage(1);
        }
        else {
          errorMessage.textContent = '加载 M3U 文件时出错，请检查 URL 是否正确。';
          showM3uInput();  
        }
      })
      .catch(error => {
        errorMessage.textContent = '加载 M3U 文件时出错，请检查 URL 是否正确。';
        showM3uInput();
        loadM3uButton.disabled = false;
      });
    }
  } else {
    errorMessage.textContent = '请输入有效的 M3U 文件 URL。';
  }
}

async function loadM3uContent() {
  if(m3uContent.value.includes('#EXTINF:')) {
    const id = database.encodeString(m3uContentKey.value);
    const payload = await database.readData(id);
    const data = { id, m3u: m3uContent.value, source: SOURCES.CONTENT, type: TYPES.M3U }; // m3u only
    if(payload) {
      await database.updateData(data);
    }
    else {
      await database.addData(data);
    }
    processM3uData(TYPES.M3U, data.m3u, true);
  }
}

const uniqueUrls = new Set();
const VARS = {
  CURRENT_TITLE: '', CURRENT_GROUP: '', CURRENT_URL: ''
};

/**
 * @param {string} line Line
 */
function processM3uLine(line) { 
  if (line.startsWith('#EXTINF:')) {
    const infoLine = line.substring(8);
    const groupMatch = infoLine.match(/group-title="([^"]+)"/);
    VARS.CURRENT_GROUP = groupMatch ? groupMatch[1] : allChannels;
    VARS.CURRENT_TITLE = infoLine.split(',').pop().trim();
  } else if (line && !line.startsWith('#')) {
    if (!uniqueUrls.has(line)) {
      uniqueUrls.add(line);

      if(line.startsWith(UNSAFE_HTTP)) {
        line = `${window.location.origin}/api/fetch?url=${line}`;
      }

      const item = { title: VARS.CURRENT_TITLE || line, url: line, group: VARS.CURRENT_GROUP };
      playlistData.push(item);
      categories[allChannels].push(item);
      if (VARS.CURRENT_GROUP !== allChannels) {
        if (!categories[VARS.CURRENT_GROUP]) {
          categories[VARS.CURRENT_GROUP] = [];
        }
        categories[VARS.CURRENT_GROUP].push(item);
      }
    }
  }
}

/**
 * @param {string} line Text line
 */
function processTxtLine(line) {
  if (line.endsWith('#genre#')) {
    const infoLine = line.replace(',#genre#', '');
    VARS.CURRENT_GROUP = infoLine ? infoLine : allChannels;
  } else if (line && !line.endsWith('#genre#')) {
    const lineArray = line.split(',');
    if(lineArray.length < 2) return;

    VARS.CURRENT_URL = lineArray.pop().trim();

    if(VARS.CURRENT_URL.startsWith(UNSAFE_HTTP)) {
      VARS.CURRENT_URL = `${window.location.origin}/api/fetch?url=${VARS.CURRENT_URL}`;
    }

    VARS.CURRENT_TITLE = lineArray.pop().trim();

    if (!uniqueUrls.has(VARS.CURRENT_URL)) {
      uniqueUrls.add(VARS.CURRENT_URL);
      const group = VARS.CURRENT_GROUP || allChannels;
      const item = { title: VARS.CURRENT_TITLE, url: VARS.CURRENT_URL, group };
      playlistData.push(item);
      categories[allChannels].push(item);
      if (group !== allChannels) {
        if (!categories[group]) {
          categories[group] = [];
        }
        categories[group].push(item);
      }
    }
  }
}

// 解析 M3U 数据
function initPlayData(type, data) {
  // Data for all
  playlistData = [];
  // Data in categories
  categories = { [allChannels]: [], [favoriteChannels]: [] };
  uniqueUrls.clear();

  const lines = data.split('\n');

  for(const item of lines) {
    const line = item.trim();
    // [M3U] Start - Process data
    if(type === TYPES.M3U) {
      processM3uLine(line);
    }
    else if (type === TYPES.TXT) {
      processTxtLine(line);
    }
    // [M3U] End - Process data
  }
  categories[originalChannels] = [...categories[allChannels]];
}

// 初始化分类
function initializeCategories() {
  categorySelect.innerHTML = '';
  for (let category in categories) {
    if(category === originalChannels){
      continue;
    }
    const option = document.createElement('option');
    option.value = category;
    option.textContent = category;
    categorySelect.appendChild(option);
  }

  categorySelect.value = currentCategory = allChannels;;
}

categorySelect.addEventListener('change', async (e) => {
  currentCategory = e.target.value;
  // 重置搜索
  searchInput.value = '';
  // 更新当前类别的数据
  if(currentCategory === favoriteChannels) {
    filteredPlaylistData = await database.listData(FAV_STORE);
  }
  else {
    filteredPlaylistData = categories[currentCategory === allChannels ? originalChannels : currentCategory];
  }
  gotoPage(1);
});

function resetListStyle() {
  for(const node of playlistItems.childNodes) {
    node.classList.remove('active');
  }
}

// 显示播放列表页面
function displayPlaylistPage(page) {
  playlistItems.innerHTML = '';
  const itemsToDisplay = filteredPlaylistData || [];
  const startIndex = (page - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const pageItems = itemsToDisplay.slice(startIndex, endIndex);
  const lastPlayedUrl = localStorage.getItem('lastPlayedUrl');
  let hasCacheUpdates = false;

  pageItems.forEach(item => {
    const li = document.createElement('li');
    const div = document.createElement('div');
    div.className = 'label';
    div.textContent = item.group === allChannels ? item.title : `[${item.group}] ${item.title}`;
    li.setAttribute('data-url', item.url);
    li.setAttribute('title', item.title);
    li.onclick = () => {
      resetListStyle();
      li.classList.add('active');
      playVideo(item.url);
    };
    li.append(div);
    playlistItems.appendChild(li);
  });

  pageItems.forEach(async (item, index) => {
    /** @type {HTMLLIElement} **/
    const li = playlistItems.children[index];
    li.dataset['url'] = item.url;
    li.dataset['proxy'] = false;
    const id = database.encodeString(item.url);
    const playCache = await database.readData(id, STA_STORE);
    if (playCache) {
      updateListItemStyle(li, playCache.result, lastPlayedUrl);
    } else {
      const result = await checkVideoPlayability(item.url);
      await database.addData({ id, result }, STA_STORE);
      updateListItemStyle(li, result, lastPlayedUrl);
      hasCacheUpdates = true;
    }
  });
  // Save
  if(hasCacheUpdates) saveDataToCache();
}

// 更新列表项样式
async function updateListItemStyle(li, checkResult, currentUrl) {
  if (!checkResult.ok) {
    li.style.color = 'gray';
    li.style.textDecoration = 'line-through';
    li.title = `此视频源可能无法播放`;
    const url = li.dataset['url'];
    if(url.startsWith(UNSAFE_HTTP)) {
      const finalResult = await checkVideoPlayability(`${window.location.origin}/api/fetch?url=${li.dataset['url']}`);
      if(finalResult.ok) {
        li.style.textDecoration = 'none';
        li.dataset['proxy'] = true;
      }
    }
  }
  else {
    if(checkResult.duration < 300) {
      li.className = 'good';
    }
    else if (checkResult.duration >= 300 && checkResult.duration <= 1000) {
      li.className = 'average';
    }
    else {
      li.className = 'bad';
    }
  }
  if(currentUrl === li.dataset['url']) {
    li.classList.add('active');
  }
}

// 更新分页控件
function updatePaginationControls() {
  const itemsToDisplay = filteredPlaylistData || [];
  const totalPages = Math.ceil(itemsToDisplay.length / itemsPerPage);
  const hasData = itemsToDisplay.length > 0;
  pageControl.max = totalPages;

  if(hasData) {
    pageInfo.innerHTML = `第 <span id="pageCurrent">${currentPage}</span>/${totalPages} 页`;
    pageControl.min = 1;
  }
  else {
    pageInfo.textContent = '';
    pageControl.min = 0;
  }
  prevButton.disabled = (currentPage === 1 || hasData === false);
  nextButton.disabled = (currentPage === totalPages || hasData === false);
}

// 初始化播放列表
function initializePlaylist() {
  filteredPlaylistData = categories[currentCategory] || playlistData;
  displayPlaylistPage(currentPage);
  updatePaginationControls();
}

// 执行搜索
function performSearch() {
  const searchTerm = searchInput.value.toLowerCase();

  if (currentCategory === allChannels || currentCategory === originalChannels) {
    filteredPlaylistData = categories[originalChannels].filter(item => 
      item.title.toLowerCase().includes(searchTerm)
    );
  } else {
    filteredPlaylistData = categories[currentCategory].filter(item => 
      item.title.toLowerCase().includes(searchTerm)
    );
  }
  gotoPage(1);
}

// 刷新当前页面
async function refreshCurrentPage() {
  const lastPlayedUrl = localStorage.getItem('lastPlayedUrl');
  const playlistItems = document.getElementById('playlistItems');
  const items = playlistItems.children;

  for (let i = 0; i < items.length; i++) {
    const li = items[i];
    li.style.color = '';
    li.style.textDecoration = '';
    li.title = '';
  }

  for (let i = 0; i < items.length; i++) {
    const li = items[i];
    const itemUrl = li.getAttribute('data-url');
    if (itemUrl) {
      const id = database.encodeString(itemUrl);
      const result = await checkVideoPlayability(itemUrl);
      await database.updateData({ id, result }, STA_STORE);
      updateListItemStyle(li, result, lastPlayedUrl);
    }
  }

  saveDataToCache();
}

function nativePlay(playingItem) {
  videoPlayer.src = playingItem.url;
  videoPlayer.addEventListener('loadedmetadata', function () {
    videoPlayer.play().catch(error => {
      errorMessage.textContent = '无法播放所选视频，请尝试其他源或检查网络连接。';
    }).then(() => {
      onPlay(playingItem);
    });
  });
}

function refreshFavoriteButton(hasFavorite) {
  if(hasFavorite) {
    favoriteButton.textContent = '移除';
    favoriteButton.dataset['action'] = 'remove';
  }
  else {
    favoriteButton.textContent = '收藏';
    favoriteButton.dataset['action'] = 'add';
  }
}

/**
 * @param {{ title: string, url: string, group: string }} playingItem Play item
 **/
async function onPlay(playingItem) {
  videoPlayer.controls = true;
  errorMessage.textContent = '';
  favoriteButton.disabled = false;
  const id = database.encodeString(playingItem.url);
  const data = await database.readData(id, FAV_STORE);

  favoriteButton.dataset['id'] = id;
  favoriteButton.dataset['url'] = playingItem.url;
  favoriteButton.dataset['group'] = playingItem.group;
  favoriteButton.dataset['title'] = playingItem.title;

  // playVideoButton.className = 'played';
  refreshFavoriteButton(data ? true : false);
}
function onPlaying() {
  playVideoButton.textContent = '停止';
  fullscreenButton.disabled = false;
  playVideoButton.className = 'played';
  videoPlayer.controls = true;
  errorMessage.textContent = '';
  videoPlayer.className = '';
  rewindButton.disabled = forwardButton.disabled = false;
}
function onStopped() {
  // 显示播放
  showPlayButton(true);
  document.title = SITE_TITLE;
  rewindButton.disabled = forwardButton.disabled = false;
}

favoriteButton.addEventListener('click', async (evt) => {
  const id = favoriteButton.dataset['id'];
  const url = favoriteButton.dataset['url'];
  const group = favoriteButton.dataset['group'];
  const title = favoriteButton.dataset['title'];
  const isAddingData = favoriteButton.dataset['action'] === 'add';
  const isDeletingData = favoriteButton.dataset['action'] === 'remove';
  if(isAddingData) {
    await database.addData({ id, url, title, group }, FAV_STORE);
  }
  else if(isDeletingData) {
    await database.deleteData(id, FAV_STORE);
  }
  refreshFavoriteButton(isAddingData);
  categories[favoriteChannels] = await database.listData(FAV_STORE);
  initializePlaylist();
});

// 播放视频
function playVideo(source, isUserAction = true) {
  /** @type {{ title: string, url: string, group: string }} **/
  const playingItem = playlistData.find(item => item.url === source);
  favoriteButton.disabled = true;

  if (playingItem) {
    document.title = playingItem.title;
  } else {
    document.title = SITE_TITLE;
  }

  if(isUserAction === false) {
    return;
  }

  videoPlayer.muted = true;
  if (Hls.isSupported()) {
    try {
      const hls = new Hls();
      hls.loadSource(source);
      hls.attachMedia(videoPlayer);
      hls.on(Hls.Events.MANIFEST_PARSED, function () {
        videoPlayer.play().catch(error => {
          errorMessage.textContent = '无法播放所选视频，请尝试其他源或检查网络连接。';
        }).then(() => {
          onPlay(playingItem);
        });
      });
      hls.on(Hls.Events.ERROR, function (error) {});
    }
    catch(error) {
      console.log('hls error 1');
    }
  } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
    nativePlay(playingItem);
  } else {
    errorMessage.textContent = '您的浏览器不支持 HLS 视频流。';
  }

  localStorage.setItem('lastPlayedUrl', source);
}

/**
 * 检查视频可播放性
 * @param {string} url URL
 * @returns {{ ok: boolean, duration: number }}
 **/
async function checkVideoPlayability(url) {
  const timestamp = new Date().getTime();
  return new Promise((resolve) => {
    if (Hls.isSupported()) {
      try {
        const hls = new Hls();
        let timeoutId;

        const cleanup = () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          hls.destroy();
        };

        hls.loadSource(url);
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          cleanup();
          resolve({ ok: true, duration: new Date().getTime() - timestamp });
        });

        hls.on(Hls.Events.ERROR, () => {
          cleanup();
          resolve({ ok: false, duration: new Date().getTime() - timestamp });
        });

        timeoutId = setTimeout(() => {
          cleanup();
          resolve({ ok: false, duration: new Date().getTime() - timestamp });
        }, 5000);
      }
      catch(error) {
        console.log('hls error 2');
      }
    } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
      const video = document.createElement('video');
      video.src = url;

      let timeoutId;

      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        video.remove();
      };

      video.onloadedmetadata = () => {
        cleanup();
        resolve({ ok: true, duration: new Date().getTime() - timestamp });
      };

      video.onerror = () => {
        cleanup();
        resolve({ ok: false, duration: new Date().getTime() - timestamp });
      };

      timeoutId = setTimeout(() => {
        cleanup();
        resolve({ ok: false, duration: new Date().getTime() - timestamp });
      }, 5000);
    } else {
      resolve({ ok: false, duration: new Date().getTime() - timestamp });
    }
  });
}

function gotoPage(p) {
  currentPage = p;
  pageControl.value = p;
  displayPlaylistPage(currentPage);
  updatePaginationControls();
  saveDataToCache();
}

// 事件监听器
loadM3uButton.addEventListener('click', () => loadM3uFile(false));
loadContentuButton.addEventListener('click', () => loadM3uContent());
closeM3uButton.addEventListener('click', (evt) => {
  showM3uInput();
});

reloadM3uButton.addEventListener('click', showM3uInput);

function gotoPrevPage(evt) {
  evt.preventDefault();
  if (currentPage > 1) {
    currentPage--;
    gotoPage(currentPage);
  }
}
prevButton.addEventListener('click', gotoPrevPage);
prevButton.addEventListener('dblclick', gotoPrevPage);
document.addEventListener('dblclick', (evt) => {
  /** @type {HTMLElement} **/
  const node = evt.target;
  switch(node.tagName) {
    case 'input':
      break;
    case 'video':
      videoPlayer.requestFullscreen();
      break;
    default:
      evt.preventDefault();
      evt.stopPropagation();
  }
});

function gotoNextPage(evt) {
  evt.preventDefault();
  const itemsToDisplay = filteredPlaylistData || [];
  if (currentPage < Math.ceil(itemsToDisplay.length / itemsPerPage)) {
    currentPage++;
    gotoPage(currentPage);
  }
}

nextButton.addEventListener('click', gotoNextPage);
nextButton.addEventListener('dblclick', gotoNextPage);

pageControl.addEventListener('change', (evt) => {
  gotoPage(parseInt(evt.target.value));
  document.getElementById('pageCurrent').textContent = currentPage;
});
pageControl.addEventListener('input', (evt) => {
  document.getElementById('pageCurrent').textContent = parseInt(evt.target.value);
});

searchContainer.addEventListener('submit', (evt) => {
  evt.preventDefault();
  evt.stopImmediatePropagation();
  performSearch();
});

searchInput.addEventListener('keyup', (evt) => {
  clearButton.disabled = evt.target.value === '';
});

searchInput.addEventListener('input', function() {
  if (this.value === '') {
    // 清空搜索关键字后，恢复到当前类别的播放列表
    filteredPlaylistData = categories[currentCategory === allChannels ? originalChannels : currentCategory];
    gotoPage(1);
  }
  searchInput.dispatchEvent(new Event('keyup'));
});

clearButton.addEventListener('click', (evt) => {
  evt.preventDefault();
  searchInput.value = '';
  performSearch();
  gotoPage(1);
  searchInput.dispatchEvent(new Event('keyup'));
});

closeButton.addEventListener('click', (evt) => {
  sideButton.dispatchEvent(new Event('click'));
});

document.getElementById('refreshPage').addEventListener('click', (evt) => {
  refreshCurrentPage();
});

videoPlayer.addEventListener('error', (e) => {
  if(videoPlayer.src === stopURL) {
    showPlayButton();
    return;
  }
  errorMessage.textContent = '加载视频时出错，请尝试其他源或检查网络连接。';
});

function showPlayButton(showControls = false) {
  playVideoButton.textContent = '播放';
  fullscreenButton.disabled = true;
  playVideoButton.className = 'stopped';
  videoPlayer.controls = showControls;
  videoPlayer.className = 'paused';
}

videoPlayer.addEventListener('timeupdate', (evt) => {
  if(videoPlayer.src === stopURL) {
    return;
  }
  localStorage.setItem('lastPlayedTime', videoPlayer.currentTime);
});

videoPlayer.addEventListener('pause', (evt) => {
  onStopped();
});

videoPlayer.addEventListener('play', (evt) => {
  onPlaying();
});

videoPlayer.addEventListener('waiting', (evt) => {
  playVideoButton.className = 'playing';
  playVideoButton.textContent = '取消';
});

videoPlayer.addEventListener('canplaythrough', (evt) => {
  onPlaying();
});

videoPlayer.addEventListener('end', (evt) => {
  onStopped();
});

playVideoButton.addEventListener('click', () => {
  if(playVideoButton.className === 'played' || playVideoButton.className === 'playing') {
    videoPlayer.src = stopURL;
    videoPlayer.pause();
    videoPlayer.currentTime = 0;
    showPlayButton(false);
  }
  else {
    playLastVideo();
  }
});
fullscreenButton.addEventListener('click', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  videoPlayer.requestFullscreen();
});

rewindButton.addEventListener('click', (evt) => {
  videoPlayer.currentTime -= 30;
  localStorage.setItem('lastPlayedTime', videoPlayer.currentTime);
});
forwardButton.addEventListener('click', (evt) => {
  videoPlayer.currentTime += 30;
  localStorage.setItem('lastPlayedTime', videoPlayer.currentTime);
});

function initSideMenu() {
  const playListVisible = window.localStorage.getItem('playListVisible') || 'false';
  if(playListVisible === 'false') {
    playlistContainer.className = 'hidden';
    errorControl.classList.add('hidden');
    refreshPage.disabled = true;
  }
  else {
    playlistContainer.className = '';
    errorControl.classList.remove('hidden');
    refreshPage.disabled = false;
  }
}

sideButton.addEventListener('click', (evt) => {
  let playListVisible = window.localStorage.getItem('playListVisible') || 'false';
  if(playListVisible === 'true') {
    playlistContainer.className = 'hidden';
    errorControl.classList.add('hidden');
    playListVisible = 'false';
    refreshPage.disabled = true;
  }
  else {
    playlistContainer.className = '';
    errorControl.classList.remove('hidden');
    playListVisible = 'true';
    refreshPage.disabled = false;
  }
  window.localStorage.setItem('playListVisible', playListVisible);
});

initSideMenu();

let muted = true, isHidden = false;
const pageContainer = document.getElementById('pageContainer');
document.addEventListener('keydown', function (event) {
  if (event.key === 'Escape' || event.keyCode === 27) {
    event.preventDefault();
    if(isHidden) {
      pageContainer.className = 'container';
    }
    else {
      pageContainer.className = 'hidden';
      muted = videoPlayer.muted;
      //
      videoPlayer.muted = true;
      videoPlayer.pause();
    }
    isHidden = !isHidden;
  }
});

// 初始化
loadCachedData();

</script>

</body>

</html>
