<!DOCTYPE html>
<html lang="en-US">
<head>
  <title>Hunhe IPTV</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="format-detection" content="telephone=no">
  <meta name="msapplication-tap-highlight" content="no">
  <meta name="referrer" content="no-referrer">
  <script src="js/hls.js"></script>
  <script src="js/main.js"></script>
  <script>
// M3U list store
const M3U_STORE = 'm3u-store';
// Favorites
const FAV_STORE = 'fav-store';
// The status cache of the playlist item
const STA_STORE = 'sta-store';
/**
 * 数据库类，封装了IndexedDB的操作
 */
class Database {
  /** @type {IDBDatabase} */
  db;
  /** @type {IDBOpenDBRequest} */
  request;
  /** @type {string} */
  dbName;
  /** @type {number} */
  dbVersion;
  /** @type {number} */
  retries = 0;
  /**
   * 构造函数，初始化数据库版本和名称
   * @param {number} dbVersion - 数据库版本，默认为1
   * @param {string} dbName - 数据库名称，默认为'm3u'
   */
  constructor(dbVersion = 1, dbName = 'm3u') {
    this.dbName = dbName; // 数据库名称
    this.dbVersion = dbVersion; // 数据库版本
    this.db = null; // 数据库实例
  }

  closeDB() {
    try {
      this.db?.close();
      this.db = null;
    }
    catch(error) {}
  }

  async reconnect() {
    for (; this.retries < 3; this.retries++) {
      this.closeDB();
      this.retries++;
      const result = await this.openDB();
      if(result.db) {
        this.db = result.db;
        return { error: null, db: this.db };
      }
    }
    if(this.db === null) {
      window.location.reload();
    }
    return { error: new Error('重连失败'), db: this.db };
  }

  /**
   * 打开数据库方法
   * @returns {Promise<{ db: IDBDatabase, error: Error }>} - 返回一个Promise对象，解析为数据库实例
   */
  async openDB() {
    return new Promise((resolve, reject) => {
      if(this.db === null) {
        this.request = window.indexedDB.open(this.dbName, this.dbVersion);

        this.request.onblocked = async (event) => {
          this.closeDB();
          const { error, db } = await this.reconnect();
          resolve({ error, db });
        };

        this.request.onupgradeneeded = async (event) => {
          printLog('Database version upgraded from', event.oldVersion, 'to ', event.newVersion);
          /** @type {IDBDatabase} */
          const db = event.target.result;
          
          /**
           * 创建对象存储
           * @param {string} storeName - 存储对象名称
           * @param {string} keyPath - 主键路径
           * @param {Array<{ name: string, keyPath: string, options?: IDBIndexParameters }>} indexes - 索引数组
           * @param {Array<string>} deleteIndexes - 需要删除的索引名称数组
           * @returns {Promise<IDBObjectStore>} - 返回一个Promise对象，解析为对象存储实例
           * @throws {Error} - 如果存储对象名称无效
           */
          const createObjectStore = async (storeName, keyPath, indexes = [], deleteIndexes = []) => {
            let store = null;
            try {
              if (!storeName || typeof storeName !== 'string') {
                throw new Error(`Invalid store name: ${storeName}`);
              }
              if (db.objectStoreNames.contains(storeName)) {
                console.log(`Object store '${storeName}' already exists.`);
                /** @type {IDBTransaction} */
                const transaction = event.target.transaction;
                /** @type {IDBObjectStore} */
                store = transaction.objectStore(storeName);
                for(const index of indexes) {
                  if (!store.indexNames.contains(index.name)) {
                    store.createIndex(index.name, index.keyPath, index.options);
                    console.log(`Index '${index.name}' created in object store '${storeName}'.`);
                  }
                  else {
                    console.log(`Index '${index.name}' already exists in object store '${storeName}'.`);
                  }
                }

                for(const index of deleteIndexes) {
                  if (store.indexNames.contains(index)) {
                    store.deleteIndex(index);
                    console.log(`Index '${index}' deleted from object store '${storeName}'.`);
                  }
                }
                return store;
              }
              /** @type {IDBObjectStore} */
              store = db.createObjectStore(storeName, { keyPath });
              console.info(`Object store '${storeName}' created successfully.`);
              for(const index of indexes) {
                store.createIndex(index.name, index.keyPath, index.options);
                console.info(`Index '${index.name}' created in object store '${storeName}'.`);
              }
              return store;
            }
            catch (error) {
              console.error(`Failed to create or modify object store '${storeName}':`, error);
            }
          };

          await createObjectStore(M3U_STORE, "id");
          await createObjectStore(FAV_STORE, "id");
          const staStore = await createObjectStore(STA_STORE, "id", [
            { name: 'staStatusOK', keyPath: 'result.status', options: { unique: false } },
          ]);
          staStore.openCursor().onsuccess = function (event) {
            const cursor = event.target.result;
            if (cursor) {
              /** @type {{ result: { status: number, ok: boolean } }} */
              const value = cursor.value;
              value.result.status = value.result.ok ? CONSTS.STATUS.OK : CONSTS.STATUS.BAD;
              delete value.result.ok;
              cursor.update(value);
              cursor.continue();
            }
          };

          db.onversionchange = (event) => {
            printLog('The version of this database has changed');
            db.close();
          };
        };
        this.request.onsuccess = (event) => {
          this.db = event.target.result;
          this.db.onclose = (evt) => {
            printLog('The database has been closed');
            this.db = null;
          };
          resolve({ db: this.db });
        };

        this.request.onerror = async (event) => {
          const { error, db } = await this.reconnect();
          resolve({ error, db });
        };
      }
      else {
        resolve({ db: this.db });
      }
    });
  }

  /**
   * 添加数据到数据库
   * @param {Object} data - 要添加的数据对象
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise} - 返回一个Promise对象，解析为添加操作的结果
   */
  async addData(data, storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }

    const transaction = db.transaction(storeName, "readwrite"); // 创建事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.add(data); // 添加数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 读取数据库中的数据
   * @param {number} id - 数据的ID
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise<{ data: any, error: Error }>} - 返回一个Promise对象，解析为读取到的数据对象
   */
  async readData(id, storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readonly"); // 创建只读事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.get(id); // 获取数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 更新数据库中的数据
   * @param {Object} data - 要更新的数据对象
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise<{ data: any, error: Error }>} - 返回一个Promise对象，解析为更新操作的结果
   */
  async updateData(data, storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readwrite"); // 创建事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.put(data); // 更新数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 从数据库中删除数据
   * @param {number} id - 要删除的数据的ID
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise<{ data: any, error: Error }>} - 返回一个Promise对象，解析为删除操作的结果
   */
  async deleteData(id, storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readwrite"); // 创建事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.delete(id); // 删除数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 列出存储对象中的所有数据
   * @param {string} storeName - 存储对象名称，默认为M3U_STORE
   * @returns {Promise<{ data: [], error: Error }>} - 返回一个Promise对象，解析为数据列表
   */
  async listData(storeName = M3U_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readonly"); // 创建只读事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    let request = store.openCursor(); // 打开游标
    const list = []; // 保存数据列表
    return new Promise((resolve, reject) => {
      request.onsuccess = (evt) => {
        const cursor = evt.target.result; // 获取游标
        if (cursor) {
          list.push(cursor.value); // 将数据添加到列表中
          cursor.continue(); // 继续遍历
        } else {
          resolve({ data: list }); // 在遍历完成后，解析Promise为列表
        }
      };
      request.onerror = () => {
        resolve({ data: [], error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  async queryData(storeName = STA_STORE, indexName, query = null) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readonly"); // 创建只读事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.index(indexName).getAll(query); // 查询数据
    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      }
      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      }
    });
  }

  /**
   * 清空存储对象中的所有数据
   * @param {string} storeName - 存储对象名称，默认为FAV_STORE
   * @returns {Promise} - 返回一个Promise对象，解析为清空操作的结果
   */
  async purgeData(storeName = FAV_STORE) {
    const { db, error } = await this.openDB();
    if(error) { return { error }; }
    const transaction = db.transaction(storeName, "readwrite"); // 创建事务
    const store = transaction.objectStore(storeName); // 获取存储对象
    const request = store.clear(); // 清空数据

    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        resolve({ data: request.result }); // 在成功时，解析Promise为结果
      };

      request.onerror = () => {
        resolve({ error: request.error }); // 在错误时，拒绝Promise为错误
      };
    });
  }

  /**
   * 计算数据库中所有数据的总大小
   * @returns {Promise<{ totalSize: number, storeSize: Object.<string, number> }>} - 返回一个Promise对象，解析为包含总大小和各存储对象大小的对象
   */
  async totalSize() {
    let totalSize = 0; // 总大小
    let storeSize = {}; // 各存储对象大小
    try {
      const { db, error } = await this.openDB();
      if(db) {
        const transaction = db.transaction(db.objectStoreNames, "readonly"); // 创建只读事务
        const promises = [];
        for (const objectStoreName of db.objectStoreNames) { // 遍历所有存储对象
          const objectStore = transaction.objectStore(objectStoreName); // 获取存储对象
          storeSize[objectStoreName] = 0; // 初始化存储对象大小

          const getAllRequest = objectStore.getAll(); // 获取所有数据的请求
          promises.push(new Promise((resolve) => {
            getAllRequest.onsuccess = (event) => {
              const items = event.target.result; // 获取所有数据
              for (const item of items) {
                const size = new Blob([JSON.stringify(item)]).size; // 计算数据大小
                totalSize += size; // 累加到总大小
                storeSize[objectStoreName] += size; // 累加到存储对象大小
              }
              resolve();
            };
            getAllRequest.onerror = (event) => {
              resolve();
            };
          }));
        }
        await Promise.all(promises);
      }
    }
    catch(error) { }

    return { totalSize, storeSize };
  }

  /**
   * 将字符串编码为Base64格式
   * @param {string} plainText - 明文字符串
   * @returns {string} - Base64编码后的字符串
   */
  encodeString(plainText) {
    const base64Encoded = btoa(unescape(encodeURIComponent(plainText))); // 进行Base64编码
    return base64Encoded; // 返回编码后的字符串
  }

  /**
   * 将Base64编码的字符串解码为原始字符串
   * @param {string} encodedText - Base64编码的字符串
   * @returns {string} - 解码后的原始字符串
   */
  decodeString(encodedText) {
    const decodedText = decodeURIComponent(escape(atob(encodedText))); // 进行Base64解码
    return decodedText; // 返回解码后的字符串
  }
}

  </script>
  <style>
:root {
  --background-color: #ffffffcf;
  --foreground-color: #333;
  --foreground-color-secondary: #555;

  --primary-background-color-button: #2e6bcc;
  --primary-background-color-button-disabled: #363839;
  --primary-color-button: white;
  --primary-color-button-disabled: #888;

  --primary-color-input: black;
  --primary-color-input-border:  light-dark(rgb(118, 118, 118, 0.5), rgb(133, 133, 133, 0.5));

  --background-color-list-item-even: rgba(255, 255, 255, 0.50);
  --background-color-list-item-odd: #cccccc50;

  /* Background images */
  --background-image-list-item-selected: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E');
  --background-image-list-item-checking: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%23666%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M2%201.5a.5.5%200%200%201%20.5-.5h11a.5.5%200%200%201%200%201h-1v1a4.5%204.5%200%200%201-2.557%204.06c-.29.139-.443.377-.443.59v.7c0%20.213.154.451.443.59A4.5%204.5%200%200%201%2012.5%2013v1h1a.5.5%200%200%201%200%201h-11a.5.5%200%201%201%200-1h1v-1a4.5%204.5%200%200%201%202.557-4.06c.29-.139.443-.377.443-.59v-.7c0-.213-.154-.451-.443-.59A4.5%204.5%200%200%201%203.5%203V2h-1a.5.5%200%200%201-.5-.5m2.5.5v1a3.5%203.5%200%200%200%201.989%203.158c.533.256%201.011.791%201.011%201.491v.702c0%20.7-.478%201.235-1.011%201.491A3.5%203.5%200%200%200%204.5%2013v1h7v-1a3.5%203.5%200%200%200-1.989-3.158C8.978%209.586%208.5%209.052%208.5%208.351v-.702c0-.7.478-1.235%201.011-1.491A3.5%203.5%200%200%200%2011.5%203V2z%22%2F%3E%3C%2Fsvg%3E');
  --background-image-list-item-frame: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M6.002%205.5a1.5%201.5%200%201%201-3%200%201.5%201.5%200%200%201%203%200%22%2F%3E%3Cpath%20d%3D%22M2.002%201a2%202%200%200%200-2%202v10a2%202%200%200%200%202%202h12a2%202%200%200%200%202-2V3a2%202%200%200%200-2-2zm12%201a1%201%200%200%201%201%201v6.5l-3.777-1.947a.5.5%200%200%200-.577.093l-3.71%203.71-2.66-1.772a.5.5%200%200%200-.63.062L1.002%2012V3a1%201%200%200%201%201-1z%22%2F%3E%3C%2Fsvg%3E');
  --background-image-list-item-frame-average: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%23806600%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M6.002%205.5a1.5%201.5%200%201%201-3%200%201.5%201.5%200%200%201%203%200%22%2F%3E%3Cpath%20d%3D%22M2.002%201a2%202%200%200%200-2%202v10a2%202%200%200%200%202%202h12a2%202%200%200%200%202-2V3a2%202%200%200%200-2-2zm12%201a1%201%200%200%201%201%201v6.5l-3.777-1.947a.5.5%200%200%200-.577.093l-3.71%203.71-2.66-1.772a.5.5%200%200%200-.63.062L1.002%2012V3a1%201%200%200%201%201-1z%22%2F%3E%3C%2Fsvg%3E');
  --background-image-list-item-frame-bad: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkred%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M6.002%205.5a1.5%201.5%200%201%201-3%200%201.5%201.5%200%200%201%203%200%22%2F%3E%3Cpath%20d%3D%22M2.002%201a2%202%200%200%200-2%202v10a2%202%200%200%200%202%202h12a2%202%200%200%200%202-2V3a2%202%200%200%200-2-2zm12%201a1%201%200%200%201%201%201v6.5l-3.777-1.947a.5.5%200%200%200-.577.093l-3.71%203.71-2.66-1.772a.5.5%200%200%200-.63.062L1.002%2012V3a1%201%200%200%201%201-1z%22%2F%3E%3C%2Fsvg%3E');
  --background-image-list-item-preview: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E');
  --background-image-list-item-preview-average: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%23806600%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E');
  --background-image-list-item-preview-bad: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkred%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E');
  --background-image-list-item-preview-broken: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22gray%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E');
  --background-image-list-item-preview-active: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22green%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22m11.596%208.697-6.363%203.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01%201.233-.696l6.363%203.692a.802.802%200%200%201%200%201.393%22%2F%3E%3C%2Fsvg%3E');
  --background-image-list-item-active-average: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%23806600%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22m11.596%208.697-6.363%203.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01%201.233-.696l6.363%203.692a.802.802%200%200%201%200%201.393%22%2F%3E%3C%2Fsvg%3E');
  --background-image-list-item-active-bad: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkred%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22m11.596%208.697-6.363%203.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01%201.233-.696l6.363%203.692a.802.802%200%200%201%200%201.393%22%2F%3E%3C%2Fsvg%3E');
  --background-image-list-item-broken: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkred%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M0%2010.5a.5.5%200%200%201%20.5-.5h15a.5.5%200%200%201%200%201H.5a.5.5%200%200%201-.5-.5M12%200H4a2%202%200%200%200-2%202v7h1V2a1%201%200%200%201%201-1h8a1%201%200%200%201%201%201v7h1V2a2%202%200%200%200-2-2m2%2012h-1v2a1%201%200%200%201-1%201H4a1%201%200%200%201-1-1v-2H2v2a2%202%200%200%200%202%202h8a2%202%200%200%200%202-2z%22%2F%3E%3C%2Fsvg%3E');
  --background-image-list-item-timeout: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22gray%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%203.5a.5.5%200%200%200-1%200V9a.5.5%200%200%200%20.252.434l3.5%202a.5.5%200%200%200%20.496-.868L8%208.71z%22%2F%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016m7-8A7%207%200%201%201%201%208a7%207%200%200%201%2014%200%22%2F%3E%3C%2Fsvg%3E');

  /* List item colors */
  --foreground-color-list-item-selected: darkgreen;
  --background-color-list-item-badge-selected: #606060;
  --background-color-list-item-selected: #ffffff99;
  --border-color-list-item-good: green;
  --border-color-list-item-average: #806600;
  --border-color-list-item-bad: darkred;
  --border-color-list-item-favorite: gray;
  --border-color-list-item-broken: #888;
  --background-color-list-item-highlighted: #fff;
  /* Special CSS */
  --primary-background-color-button-disabled-contrast: inherit;
  --primary-color-button-disabled-contrast: inherit;
  --background-color-list-item-highlighted: inherit;
  --background-color-list-item-badge: #606060;

  --border-radius-button: 8px;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background-color: #000000cf;
    --foreground-color: #ddd;
    --foreground-color-secondary: #bbb;

    --primary-background-color-button: black;
    --primary-background-color-button-disabled: #282828;
    --primary-color-button: #c5c5c5;
    --primary-color-button-disabled: #c5c5c5;

    --primary-color-input: #c5c5c5;
    --primary-color-input-border: light-dark(rgb(118, 118, 118), rgb(133, 133, 133));

    /* Background images */
    --background-image-list-item-selected: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22lightgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E');
    --background-image-list-item-checking: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkgray%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M2%201.5a.5.5%200%200%201%20.5-.5h11a.5.5%200%200%201%200%201h-1v1a4.5%204.5%200%200%201-2.557%204.06c-.29.139-.443.377-.443.59v.7c0%20.213.154.451.443.59A4.5%204.5%200%200%201%2012.5%2013v1h1a.5.5%200%200%201%200%201h-11a.5.5%200%201%201%200-1h1v-1a4.5%204.5%200%200%201%202.557-4.06c.29-.139.443-.377.443-.59v-.7c0-.213-.154-.451-.443-.59A4.5%204.5%200%200%201%203.5%203V2h-1a.5.5%200%200%201-.5-.5m2.5.5v1a3.5%203.5%200%200%200%201.989%203.158c.533.256%201.011.791%201.011%201.491v.702c0%20.7-.478%201.235-1.011%201.491A3.5%203.5%200%200%200%204.5%2013v1h7v-1a3.5%203.5%200%200%200-1.989-3.158C8.978%209.586%208.5%209.052%208.5%208.351v-.702c0-.7.478-1.235%201.011-1.491A3.5%203.5%200%200%200%2011.5%203V2z%22%2F%3E%3C%2Fsvg%3E');
    --background-image-list-item-frame: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22lightgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M6.002%205.5a1.5%201.5%200%201%201-3%200%201.5%201.5%200%200%201%203%200%22%2F%3E%3Cpath%20d%3D%22M2.002%201a2%202%200%200%200-2%202v10a2%202%200%200%200%202%202h12a2%202%200%200%200%202-2V3a2%202%200%200%200-2-2zm12%201a1%201%200%200%201%201%201v6.5l-3.777-1.947a.5.5%200%200%200-.577.093l-3.71%203.71-2.66-1.772a.5.5%200%200%200-.63.062L1.002%2012V3a1%201%200%200%201%201-1z%22%2F%3E%3C%2Fsvg%3E');
    --background-image-list-item-frame-average: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22orange%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M6.002%205.5a1.5%201.5%200%201%201-3%200%201.5%201.5%200%200%201%203%200%22%2F%3E%3Cpath%20d%3D%22M2.002%201a2%202%200%200%200-2%202v10a2%202%200%200%200%202%202h12a2%202%200%200%200%202-2V3a2%202%200%200%200-2-2zm12%201a1%201%200%200%201%201%201v6.5l-3.777-1.947a.5.5%200%200%200-.577.093l-3.71%203.71-2.66-1.772a.5.5%200%200%200-.63.062L1.002%2012V3a1%201%200%200%201%201-1z%22%2F%3E%3C%2Fsvg%3E');
    /* --background-image-list-item-frame-bad: inherit; */
    --background-image-list-item-preview: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22lightgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E');
    --background-image-list-item-preview-average: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22orange%22%20viewBox%3D%220%200%2016%2016%22%3E%0A%20%20%3Cpath%20d%3D%22M6.5%204.482c1.664-1.673%205.825%201.254%200%205.018-5.825-3.764-1.664-6.69%200-5.018%22%2F%3E%0A%20%20%3Cpath%20d%3D%22M13%206.5a6.47%206.47%200%200%201-1.258%203.844q.06.044.115.098l3.85%203.85a1%201%200%200%201-1.414%201.415l-3.85-3.85a1%201%200%200%201-.1-.115h.002A6.5%206.5%200%201%201%2013%206.5M6.5%2012a5.5%205.5%200%201%200%200-11%205.5%205.5%200%200%200%200%2011%22%2F%3E%0A%3C%2Fsvg%3E');
    /* --background-image-list-item-preview-bad: inherit; */
    /* --background-image-list-item-preview-broken: inherit; */
    --background-image-list-item-preview-active: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22lightgreen%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22m11.596%208.697-6.363%203.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01%201.233-.696l6.363%203.692a.802.802%200%200%201%200%201.393%22%2F%3E%3C%2Fsvg%3E');
    --background-image-list-item-active-average: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22orange%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22m11.596%208.697-6.363%203.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01%201.233-.696l6.363%203.692a.802.802%200%200%201%200%201.393%22%2F%3E%3C%2Fsvg%3E');
    /* --background-image-list-item-active-bad: inherit; */
    /* --background-image-list-item-broken: inherit; */
    --background-image-list-item-timeout: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22darkgray%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%203.5a.5.5%200%200%200-1%200V9a.5.5%200%200%200%20.252.434l3.5%202a.5.5%200%200%200%20.496-.868L8%208.71z%22%2F%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016m7-8A7%207%200%201%201%201%208a7%207%200%200%201%2014%200%22%2F%3E%3C%2Fsvg%3E');

    /* List item colors */
    --foreground-color-list-item-selected: lightgreen;
    --background-color-list-item-badge-selected: darkgreen;
    --background-color-list-item-selected: black;
    --border-color-list-item-good: lightgreen;
    --border-color-list-item-average: orange;
    --border-color-list-item-bad: inherit;
    --border-color-list-item-favorite: white;
    --border-color-list-item-broken: #bbb;
    /* Special CSS */
    --primary-background-color-button-disabled-contrast: #282828;
    --primary-color-button-disabled-contrast: #a3a3a3;
    --background-color-list-item-highlighted: #393939;
    --background-color-list-item-badge: #3a3a3a;
  }
}

html, body {
  width: 100%;
  height: 100%;
  zoom: 1;
  touch-action: manipulation;
}
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0;
  color: var(--foreground-color);
  margin: 0;
  position: relative;
  overflow: hidden;
  align-items: center;
  background: url(background.jpeg) center center / cover no-repeat;
}
  .container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-flow: row;
    align-items: flex-start;
    margin: 0px;
    position: relative;
  }
  .container .video-container {
    flex: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    min-width: 300px;
    width: 100%;
    height: 100%;
    user-select: none;
    -webkit-user-select: none;
    will-change: flex-grow, min-width, max-width, width;
  }
    .container .video-container .video-wrapper {
      align-items: center;
      box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.5);
      border-radius: var(--border-radius-button);
      overflow: hidden;
      display: flex;
      width: 100%;
      max-height: 100%;
      min-width: 300px;
      height: auto;
      background-color: transparent;
      position: relative;
      flex: 1;
    }
    .play-list .container .video-container .video-wrapper {
      max-height: calc(100vh - 4rem);
    }
      .container #videoContainer {
        display: flex;
        width: 100%;
        height: 100%;
        flex: 1;
        margin: 0px;
        padding: 0px;
        will-change: flex-grow, min-width, max-width;
      }
      .container #videoContainer #videoPlayer {
        width: 100%;
        max-height: 100%;
        height: auto;
        z-index: 10;
      }
      .container .video-container .video-wrapper #frameVideo {
        width: 100%;
        max-height: 100%;
        height: auto;
        position: absolute;
        z-index: -1;
      }
    .container .video-container .user-controls {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-flow: row;
      column-gap: 0.5rem;
      flex: 0 0;
    }
    .container #videoContainer #videoControls {
      position: absolute;
      bottom: 0px;
      left: 0px;
      width: 100%;
      background-color: rgba(0, 0, 0, 0.3);
      z-index: 20;
      box-sizing: border-box;
      opacity: 1;
      pointer-events: auto;
      transition: opacity 0.5s;
      flex-flow: column;
      will-change: opacity;
      padding-top: 0.5rem;
    }
      .container #videoContainer #videoControls.transparent {
        opacity: 0;
        pointer-events: none;
      }
      .container #videoContainer #videoControls button {
        flex: 0;
      }
      .container #videoContainer #videoControls .buttons {
        width: 100%;
        display: flex;
        justify-content: space-between;
        box-sizing: border-box;
        position: relative;
        padding: 0px 1px;
        column-gap: 0.5rem;
      }
      .container #videoContainer #videoControls .buttons .group {
        display: flex;
        flex: 1;
        justify-content: flex-end;
      }
      .container #videoContainer #videoControls .buttons .divider {
        flex: 1;
      }
      .container #videoContainer #videoControls .progress {
        flex: 1;
        width: 100%;
        display: flex;
        column-gap: 0.3rem;
        align-items: center;
        justify-content: space-between;
        box-sizing: border-box;
        padding: 0.5rem 0.5rem 0px;
      }
      .container #videoContainer #videoControls .progress #progressControl {
        width: 100%;
        flex: 1;
        height: 0.7rem;
      }
      .container #videoContainer #videoControls .progress #progressControl::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: #eee;
        cursor: ew-resize;
      }
      .container #videoContainer #videoControls .progress #progressControl::-moz-range-thumb {
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: #eee;
        cursor: ew-resize;
      }
      .container #videoContainer #videoControls .progress .time {
        color: #eee;
        text-align: center;
      }
      #pageBody.settings #videoContainer #videoControls {
        opacity: 0;
        pointer-events: none;
      }
    .container #playlistContainer {
      width: 100%;
      height: 100%;
      display: flex;
      z-index: 10;
      overflow: hidden;
      flex: 0 0;
      min-width: 0px;
      transition: flex 0.2s ease, min-width 0.3s ease;
      will-change: flex, min-width;
    }
    #pageBody.menu .container #playlistContainer {
      flex: 1;
      min-width: 300px;
      background: var(--background-color);
    }
      #pageBody .container .player-interface {
        display: flex;
        flex: 1;
        width: 100%;
        height: 100%;
        z-index: 10;
      }
      #pageBody .container #m3uInputContainer {
        width: 100%;
        height: 100%;
        position: absolute;
        left: 0px;
        top: 0px;
        overflow: hidden;
        justify-content: center;
        display: flex;
        align-items: center;
        transition: background-color 0.2s ease, width 0.2s ease, z-index 0.2s ease;
        z-index: -1;
      }
        #pageBody .container #m3uInputContainer .box {
          justify-content: flex-start;
          margin: 0px auto;
          max-height: 100%;
          flex: 0 0 100%;
          scale: 0.78;
          box-shadow: 0px 0px 4px #999;
          transition: opacity 0.2s ease, scale 0.2s ease;
          opacity: 0;
          border-radius: 6px;
        }

      #pageBody.settings .container #m3uInputContainer {
        width: 100%;
        z-index: 40;
        background-color: var(--background-color);
      }
        #pageBody.settings .container #m3uInputContainer .box {
          opacity: 1;
          scale: 0.9;
        }

textarea, #searchInput, #searchButton, #clearButton, #closeButton, #m3uUrlInput,
#m3uContentKey, #settingsButton,
.m3u-controls #loadM3uButton, .m3u-controls #closeM3uButton {
  width: 100%;
  border: 1px solid #ddd;
  border-radius: var(--border-radius-button);
  font-size: 16px;
  appearance: none;
  box-sizing: border-box;
}
#m3uUrlInput {
  border-top-right-radius: 0px;
  border-bottom-right-radius: 0px;
  font-size: 14px;
  border: 0px;
}
#searchContainer, #playlistContent .top-buttons {
  margin-bottom: 10px;
}
#searchContainer {
  display: flex;
}
  #searchContainer .search {
    position: relative;
    flex: 1;
    display: flex;
  }
  #searchContainer #clearButton {
    position: absolute;
    right: 0px;
    top: 0px;
    background-color: transparent;
    width: auto;
    color: #999;
    flex: 1;
    padding: 0px 0.5rem;
    height: 100%;
    -webkit-appearance: none;
    appearance: none;
    border: 0px solid transparent;
    z-index: 10;
    border-radius: 0px;
  }
  #searchContainer #clearButton svg {
    background-color: transparent;
  }
#searchInput, #m3uUrlInput {
  padding: 12px;
}
#searchInput {
  flex-grow: 1;
  background-color: var(--background-color);
  color: var(--primary-color-input);
  border-color: var(--primary-color-input-border);
}
textarea:focus-visible,
input:focus-visible,
select:focus-visible {
  outline: 1px solid #ddd;
}
#searchButton {
  border-radius: 0px;
}
#searchButton, #closeButton, #settingsButton {
  width: auto;
  background-color: var(--primary-background-color-button);
  color: var(--primary-color-button);
  border: none;
  cursor: pointer;
  white-space: nowrap;
}
#closeButton {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
#playlistContent .top-buttons #listCheckButton {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
ul.menu-list {
  list-style-type: none;
  padding: 0px;
  margin: 0px;
  display: flex;
  flex-flow: column;
  flex: 1;
  row-gap: 0px;
  justify-content: flex-start;
  overflow: auto;
  scrollbar-width: none;
  -ms-overflow-style: none;
  backface-visibility: hidden;
  will-change: transform, opacity;
}
  ul.menu-list::-webkit-scrollbar { 
    display: none;
  }
ul.menu-list li {
  will-change: transform;
  cursor: pointer;
  background-color: var(--background-color-list-item-odd);
  border-radius: 0px;
  padding: 0px 0px 0px 0.5rem;
  height: 100%;
  min-height: 1.9rem;
  white-space: nowrap;
  overflow: hidden;
  overflow-y: hidden;
  text-overflow: ellipsis;
  display: flex;
  align-items: center;
  scrollbar-width: none;
  -ms-overflow-style: none;
  border-left: 3px solid gray;
  transition: 0.3s background-position-x ease, 0.3s border-bottom-color ease, 0.3s background-image ease, 0.3s background-color ease;
  will-change: background-position-x, border-bottom-color, background-image, background-color;
  border-bottom: 2px solid transparent;
  user-select: none;
  -webkit-user-select: none;
  position: relative;
  background-position: -1rem center;
  background-repeat: no-repeat;
  padding: 0px;
  font-size: 0.85rem;
}
  ul.menu-list li:nth-of-type(even) {
    background-color: var(--background-color-list-item-even);
  }
  ul.menu-list li::after {
    content: attr(data-duration);
    display: flex;
    font-size: 0.6rem;
    color: var(--foreground-color-secondary);
    text-align: right;
    justify-content: end;
    flex: 0;
    padding: 0.5rem;
    border-radius: 4px;
    width: auto;
  }
  ul.menu-list li.favorite::after {
    padding: 0.3rem;
  }
  ul.menu-list li::-webkit-scrollbar,
  ul.menu-list li label::-webkit-scrollbar {
    display: none;
  }
  ul.menu-list li.selected {
    background-image: var(--background-image-list-item-selected);
    background-position-x: 0.5rem;
    border-left: 3px solid var(--border-color-list-item-good);
    border-bottom-color: var(--border-color-list-item-good);
    color: var(--foreground-color-list-item-selected);
  }
  ul.menu-list li.good {
    border-left: 3px solid var(--border-color-list-item-good);
  }
  ul.menu-list li.good.preview,
  ul.menu-list li.good:hover {
    border-bottom-color: var(--border-color-list-item-good);
  }
  ul.menu-list li.average {
    border-left: 3px solid var(--border-color-list-item-average);
  }
  ul.menu-list li.average.preview,
  ul.menu-list li.average:hover {
    border-bottom-color: var(--border-color-list-item-average);
  }
  ul.menu-list li.bad {
    border-left-color: var(--border-color-list-item-bad);
  }
  ul.menu-list li.bad.preview,
  ul.menu-list li.bad:hover {
    border-bottom-color: var(--border-color-list-item-bad);
  }
  ul.menu-list li.favorite {
    box-shadow: inset -2px 0 1px 0px var(--border-color-list-item-favorite);
  }
  ul.menu-list li.broken {
    font-style: italic;
    color: var(--border-color-list-item-broken);
    font-size: small;
    background-image: var(--background-image-list-item-broken);
    background-position-x: 0.5rem;
  }
  ul.menu-list li.timeout {
    color: var(--border-color-list-item-broken);
    font-size: small;
    background-image: var(--background-image-list-item-timeout);
    background-position-x: 0.5rem;
  }
  ul.menu-list li.timeout:hover {
    border-bottom-color: gray;
  }
  ul.menu-list li.broken:hover {
    border-bottom-color: black;
  }
  ul.menu-list li.frame {
    background-image: var(--background-image-list-item-frame);
    background-position-x: 0.5rem;
  }
  ul.menu-list li.average.frame {
    background-image: var(--background-image-list-item-frame-average);
  }
  ul.menu-list li.bad.frame {
    background-image: var(--background-image-list-item-frame-bad);
  }
  ul.menu-list li.preview {
    background-image: var(--background-image-list-item-preview);
    background-position-x: 0.5rem;
  }
  ul.menu-list li.average.preview {
    background-image: var(--background-image-list-item-preview-average);
  }
  ul.menu-list li.bad.preview {
    background-image: var(--background-image-list-item-preview-bad);
  }
  ul.menu-list li.broken.preview {
    background-image: var(--background-image-list-item-preview-broken);
  }
  ul.menu-list li.active,
  ul.menu-list li.preview.active {
    font-weight: bold;
    background-image: var(--background-image-list-item-preview-active);
    color: inherit;
  }
  ul.menu-list li.average.active {
    background-image: var(--background-image-list-item-active-average);
  }
  ul.menu-list li.bad.active {
    background-image: var(--background-image-list-item-active-bad);
  }
  ul.menu-list li.checking {
    color: var(--border-color-list-item-broken);
    border-left-color: #000;
    font-size: 0.8rem;
    background-image: var(--background-image-list-item-checking);
    background-position-x: 0.5rem;
  }
  ul#channelList.menu-list {
    row-gap: 0px;
    flex-flow: wrap;
  }
  ul#channelList.menu-list li {
    border-left: 0px none;
    border-bottom: 1px solid #ccc;
    width: 50%;
    height: auto;
    font-size: 0.9rem;
  }
  ul.menu-list li:nth-of-type(even) {
    background-color: #ffffff50;
  }
  ul#channelList.menu-list li.selected {
    background-color: var(--background-color-list-item-selected);
    border-bottom-color: var(--foreground-color-list-item-selected);
  }
  ul#channelList.menu-list li:nth-of-type(odd) {
    width: calc(50% - 1px);
    max-width: calc(50% - 0.5px);
    border-right: 1px solid #ccc;
  }
  ul#channelList.menu-list li:nth-of-type(even) {
    width: calc(50% - 1px);
    max-width: calc(50% - 1px);
  }
  ul#channelList.menu-list li::after {
    background: var(--background-color-list-item-badge);
    color: white;
    padding: 0.25rem;
    margin-right: 0.5rem;
  }
  ul#channelList.menu-list li.selected::after {
    background: var(--background-color-list-item-badge-selected);
  }

  ul.menu-list li.frame:hover,
  ul.menu-list li:hover {
    background-color: #cceeee5c;
  }
  ul.menu-list li label {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    flex: 1;
    overflow: auto;
    margin: 0px 0.5rem;
    cursor: pointer;
    transition: 0.5s all;
  }
  ul.menu-list li.selected label,
  ul.menu-list li.timeout label,
  ul.menu-list li.broken label,
  ul.menu-list li.checking label,
  ul.menu-list li.frame label,
  ul.menu-list li.preview label {
    margin: 0px 0.3rem 0px 2rem;
  }
  ul.menu-list li label i {
    font-style: normal;
    width: 100%;
    user-select: none;
    -webkit-user-select: none;
  }
  ul.menu-list li .delete {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: absolute;
    right: 0;
    width: 3rem;
    flex: 0;
    height: 100%;
  }

button {
  user-select: none;
  -webkit-user-select: none;
  padding: 10px 20px;
  background-color: var(--primary-background-color-button);
  color: var(--primary-color-button);
  border: none;
  border-radius: var(--border-radius-button);
  cursor: pointer;
  font-size: 16px;
  white-space: nowrap;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: filter 0.3s ease;
}
svg,
button svg {
  pointer-events: auto;
}
button:disabled {
  background-color: var(--primary-background-color-button-disabled);
  color: var(--primary-color-button-disabled);
}
  button:disabled svg {
    filter: invert(1);
  }

button:not(:disabled):active,
button:not(:disabled):focus-visible {
  filter: brightness(0.9);
}

#playlistContent button:disabled {
  background-color: var(--primary-background-color-button-disabled-contrast);
  color: var(--primary-color-button-disabled-contrast);
}

#settingsButton {
  background-color: #606060;
}

#reCaptureButton.recapture {
  background-color: darkorchid;
}
  #favoriteButton.remove {
    background-color: #cc2e68;
  }
  #dislikeButton.remove {
    background-color: #cc2e68;
  }

#playListButton {
  background-color: #2e6bcc;
}
#fullscreenButton {
  background-color: darkslateblue;
}
#playVideoButton {
  background-color: blueviolet;
}
#pipButton:disabled,
#playVideoButton:disabled,
#fullscreenButton:disabled {
  background-color: inherit;
}
#speakerButton {
  background-color: rgb(43, 89, 226);
}
#playVideoButton.playing {
  background-color: darkmagenta;
}
#playVideoButton.played {
  background-color: #e74c3c;
}
#pinButton.pinned {
  background-color: orange;
}

#m3uList {
  display: flex;
  column-gap: 1rem;
  flex-flow: column;
  padding: 0.5rem 0.8rem;
  scrollbar-width: none;
  -ms-overflow-style: none;
}
#m3uList::-webkit-scrollbar {
  display: none;
}

#m3uList div {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-top: 1px solid #ccc;
}
  #m3uList div.active {
    background-color: var(--background-color-list-item-highlighted);
  }
#m3uList div a {
  cursor: pointer;
  padding: 0.5rem 0.8rem;
  border-radius: 4px;
  cursor: pointer;
    padding: 0.5rem 0.8rem;
    border-radius: 4px;
    display: flex;
    height: 100%;
    align-items: center;
    box-sizing: border-box;
    justify-content: flex-start;
    margin: 2px 0px;
}
  #m3uList div a:hover {
    background-color: var(--background-color-list-item-highlighted);
  }
  #m3uList div a.load {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 0.85rem;
  }
    #m3uList div::before {
      content: attr(title);
      font-size: 0.75rem;
      padding: 0.5rem 0.8rem;
      width: 4rem;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }
  #m3uList div a.delete {
    color: #e74c3c;
    opacity: 0.6;
    transition: all 1s;
  }
  #m3uList div a.refresh {
    transition: all 1s;
  }
  #m3uList div a.refresh:hover {
    background: #5c5c5c;
    color: white;
  }
  #m3uList div a.refresh.disabled {
    opacity: 0.2;
  }
  #m3uList div a.ready,
  #m3uList div a.delete:hover {
    background-color: #e74c3c;
    color: white;
    opacity: 1;
  }
#m3uContentKey {
  margin-top: 1rem;
}

#playlistContent {
  display: flex;
  flex-flow: column;
  height: 100%;
}
#playlistContent .top-buttons {
  display: flex;
  justify-content: space-between;
  flex: 0;
}
#playlistContent .top-buttons #channelButton {
  flex: 1;
  border-radius: 0;
  justify-content: center;
  border-left: 1px solid var(--primary-color-button);
  border-right: 1px solid var(--primary-color-button);
}
#playlistContent .top-buttons #searchFormButton {
  border-radius: 0;
}
  #playlistContent .top-buttons #searchFormButton svg {
    zoom: 0.8;
  }
  #playlistContent .top-buttons.channel .channel-hidden {
    display: none;
  }
  #playlistContent .top-buttons.channel button {
    --primary-background-color-button: #333;
  }
  #playlistContent .top-buttons.channel #channelButton {
    padding-left: 0px;
    justify-content: flex-start;
    border-left: 0px;
    border-top-right-radius: var(--border-radius-button);
    border-bottom-right-radius: var(--border-radius-button);
  }
#playlistContent .top-buttons button {
  transition: background-color 0.5s ease-in-out, padding-left 0.5s ease-in-out;
}

  #playlistContent .top-buttons #listCheckButton.checking {
    background-color: #db6634;
  }
  #playlistContent .page-controls {
    flex: 0 0;
    user-select: none;
    -webkit-user-select: none;
  }
  #playlistContent .page-controls #pagination {
    display: flex;
    justify-content: space-between;
    align-items: center;
    column-gap: 1rem;
    flex: 0;
    width: 100%;
    margin-top: 0.5rem;
  }
  #playlistContent .page-controls #pagination button {
    font-size: 16px;
    flex: 0;
  }
  #playlistContent .page-controls #pagination button, .user-controls button {
    box-shadow: 0px 0px 2px var(--foreground-color-secondary);  
  }
    .user-controls button {
      transition: transform 0.1s ease, background-color 0.2s ease;
      flex: 1;
    }
  #playlistContent .page-controls #pagination #pageInfo {
    font-size: 12px;
    white-space: nowrap;
    width: 100%;
    text-align: center;
    padding-top: 3px;
  }

.box {
  display: flex;
  flex-flow: column;
  width: 100%;
  flex: 1;
  position: relative;
  border-radius: 0px;
  box-sizing: border-box;
  overflow: auto;
  padding: 0.5rem;
  column-gap: 0.6rem;
  row-gap: 0.6rem;
  scrollbar-width: none;
  -ms-overflow-style: none;
  height: 100%;
  justify-content: space-between;
}
.box::-webkit-scrollbar { 
  display: none;
}
.container .video-container .box {
  background-color: rgba(0, 0, 0, 0.85);
}
.container .video-container .box-video {
  height: 100%;
}
.container .video-container .box-controls {
  flex: none;
  height: auto;
  padding-top: 1px;
}
.range {
  appearance: none;
  width: 100%;
  height: 15px;
  border-radius: 5px;  
  background: #b5b5b5;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

/* Mouse-over effects */
.range:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.range::-webkit-slider-thumb {
  appearance: none;
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #4682b4;
  cursor: pointer;
}

.range::-moz-range-thumb {
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #04AA6D;
  cursor: pointer;
}

.m3u-controls {
  display: flex;
  flex-flow: row;
  align-items: center;
  justify-content: flex-end;
  padding: 0.5rem;
}
  .m3u-controls #closeM3uButton {
    background-color: #db6634;
    border-top-left-radius: 0px;
    border-bottom-left-radius: 0px;
  }
  .m3u-controls #loadM3uButton,
  .m3u-controls #closeM3uButton {
    width: auto;
    border: 0px;
  }

  .m3u-controls #loadM3uButton {
    background-color: #3498db;
    border: 0px;
    cursor: pointer;
    border-radius: 0px;
    font-size: 14px;
  }
  .m3u-controls #loadM3uButton:disabled,
  .m3u-controls #closeM3uButton:disabled {
    background-color: inherit;
  }

.page-information {
  flex: 1;
}

.tools {
  display: flex;
  padding: 0.5rem 0.8rem;
  align-items: flex-start;
  justify-content: center;
  flex-flow: column;
  user-select: none;
}

  .tools #databaseSize {
    border-radius: 4px;
  }
  .tools #databaseCategories {
    display: flex;
    column-gap: 0.5rem;
    row-gap: 0.5rem;
    justify-content: space-evenly;
    align-items: center;
    width: 100%;
    flex: 1;
    flex-wrap: wrap;
  }
  .tools #databaseCategories button {
    flex: 1;
    background-color: darkred;
    font-size: 0.9rem;
  }
  .tools .debug {
    border: 1px solid #ccc;
    flex: 1;
    display: flex;
    box-sizing: border-box;
    width: 100%;
    padding: 0.5rem;
    position: relative;
    user-select: all;
  }
  .tools .debug #debugLogs {
    width: 100%;
    resize: vertical;
    flex: 1;
    white-space: pre-wrap;
    line-height: 1.2;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  .tools .debug #debugLogs::-webkit-scrollbar {
    display: none;
  }
  .tools .debug #logClearButton {
    position: absolute;
    right: 0.5rem;
    top: 0.5rem;
    background-color: #e74c3c;
    padding: 0.2rem;
    border-radius: 4px;
    cursor: pointer;
    opacity: 0.6;
  }
.settings-usage {
  row-gap: 0.5rem;
}

.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 0.5rem 0px;
  column-gap: 1rem;
  border-bottom: 1px solid #777;
  margin-top: -1px;
  border-top: 1px solid #777;
}
.settings-row .label {
  width: 100%;
  flex: 1;
  white-space: nowrap;
  align-items: center;
  display: flex;
  height: 34px;
}
/* The switch - the box around the slider */
.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

/* Hide default HTML checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* The slider */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(26px);
  -ms-transform: translateX(26px);
  transform: translateX(26px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}

@media (min-width: 768px) {
  #videoPlayer {
    width: 640px;
  }

  #playlistContainer {
    width: 640px;
  }
}

/* iPhone Portrait */
@media only screen and (max-width: 812px) and (orientation: portrait)
{
  .menu .container #playlistContainer {
    position: absolute;
    z-index: 30;
    top: 0px;
    left: 0px;
  }
  #pageBody.settings .container #m3uInputContainer .box {
    flex: 1;
    max-height: 100%;
  }
  .container .video-container .user-controls button#favoriteButton,
  .container .video-container .user-controls button#dislikeButton,
  .container .video-container .user-controls button#reCaptureButton {
    display: none;
  }
}
@media only screen and (max-width: 965px) {
  .container #videoContainer #videoControls .buttons button {
    border-radius: 4px;
    padding: 0.5rem 0.7rem;
  }
}

@media only screen and (max-width: 300px) {
  #bottomButtons {
    column-gap: 0.5rem; 
  }
  #bottomButtons button {
    border-radius: 4px;
    padding: 0.5rem 0.7rem;
  }
}

.hidden {
  display: none !important;
}

  </style>
</head>

<body id="pageBody">
  <svg xmlns="http://www.w3.org/2000/svg" class="hidden">
    <!-- PLAY -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="play" viewBox="0 0 16 16">
      <path d="M10.804 8 5 4.633v6.734zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696z"/>
    </symbol>
    <!-- STOP -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="stop" viewBox="0 0 16 16">
      <path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5"/>
    </symbol>
    <!-- CANCEL -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="cancel" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0M5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293z"/>
    </symbol>
    <!-- CLOSE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="close" viewBox="0 0 16 16">
      <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708"/>
    </symbol>
    <!-- FULLSCREEN -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="fullscreen" viewBox="0 0 16 16">
      <path d="M5.5 0a.5.5 0 0 1 .5.5v4A1.5 1.5 0 0 1 4.5 6h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5m5 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 10 4.5v-4a.5.5 0 0 1 .5-.5M0 10.5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 6 11.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5m10 1a1.5 1.5 0 0 1 1.5-1.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0z"/>
    </symbol>
    <!-- REWIND -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="rewind" viewBox="0 0 16 16">
      <path d="M9.196 8 15 4.633v6.734zm-.792-.696a.802.802 0 0 0 0 1.392l6.363 3.692c.52.302 1.233-.043 1.233-.696V4.308c0-.653-.713-.998-1.233-.696z"/>
      <path d="M1.196 8 7 4.633v6.734zm-.792-.696a.802.802 0 0 0 0 1.392l6.363 3.692c.52.302 1.233-.043 1.233-.696V4.308c0-.653-.713-.998-1.233-.696z"/>
    </symbol>
    <!-- FORWARD -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="forward" viewBox="0 0 16 16">
      <path d="M6.804 8 1 4.633v6.734zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C.713 12.69 0 12.345 0 11.692V4.308c0-.653.713-.998 1.233-.696z"/>
      <path d="M14.804 8 9 4.633v6.734zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C8.713 12.69 8 12.345 8 11.692V4.308c0-.653.713-.998 1.233-.696z"/>
    </symbol>
    <!-- SETTINGS - GEAR -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="gear" viewBox="0 0 16 16">
      <path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492M5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0"/>
      <path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52zm-2.633.283c.246-.835 1.428-.835 1.674 0l.094.319a1.873 1.873 0 0 0 2.693 1.115l.291-.16c.764-.415 1.6.42 1.184 1.185l-.159.292a1.873 1.873 0 0 0 1.116 2.692l.318.094c.835.246.835 1.428 0 1.674l-.319.094a1.873 1.873 0 0 0-1.115 2.693l.16.291c.415.764-.42 1.6-1.185 1.184l-.291-.159a1.873 1.873 0 0 0-2.693 1.116l-.094.318c-.246.835-1.428.835-1.674 0l-.094-.319a1.873 1.873 0 0 0-2.692-1.115l-.292.16c-.764.415-1.6-.42-1.184-1.185l.159-.291A1.873 1.873 0 0 0 1.945 8.93l-.319-.094c-.835-.246-.835-1.428 0-1.674l.319-.094A1.873 1.873 0 0 0 3.06 4.377l-.16-.292c-.415-.764.42-1.6 1.185-1.184l.292.159a1.873 1.873 0 0 0 2.692-1.115z"/>
    </symbol>
    <!-- LIST CHECK -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="list-check" viewBox="0 0 16 16">
      <path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
      <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
    </symbol>
    <!-- FAVORITE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="favorite" viewBox="0 0 16 16">
      <path d="M8.864.046C7.908-.193 7.02.53 6.956 1.466c-.072 1.051-.23 2.016-.428 2.59-.125.36-.479 1.013-1.04 1.639-.557.623-1.282 1.178-2.131 1.41C2.685 7.288 2 7.87 2 8.72v4.001c0 .845.682 1.464 1.448 1.545 1.07.114 1.564.415 2.068.723l.048.03c.272.165.578.348.97.484.397.136.861.217 1.466.217h3.5c.937 0 1.599-.477 1.934-1.064a1.86 1.86 0 0 0 .254-.912c0-.152-.023-.312-.077-.464.201-.263.38-.578.488-.901.11-.33.172-.762.004-1.149.069-.13.12-.269.159-.403.077-.27.113-.568.113-.857 0-.288-.036-.585-.113-.856a2 2 0 0 0-.138-.362 1.9 1.9 0 0 0 .234-1.734c-.206-.592-.682-1.1-1.2-1.272-.847-.282-1.803-.276-2.516-.211a10 10 0 0 0-.443.05 9.4 9.4 0 0 0-.062-4.509A1.38 1.38 0 0 0 9.125.111zM11.5 14.721H8c-.51 0-.863-.069-1.14-.164-.281-.097-.506-.228-.776-.393l-.04-.024c-.555-.339-1.198-.731-2.49-.868-.333-.036-.554-.29-.554-.55V8.72c0-.254.226-.543.62-.65 1.095-.3 1.977-.996 2.614-1.708.635-.71 1.064-1.475 1.238-1.978.243-.7.407-1.768.482-2.85.025-.362.36-.594.667-.518l.262.066c.16.04.258.143.288.255a8.34 8.34 0 0 1-.145 4.725.5.5 0 0 0 .595.644l.003-.001.014-.003.058-.014a9 9 0 0 1 1.036-.157c.663-.06 1.457-.054 2.11.164.175.058.45.3.57.65.107.308.087.67-.266 1.022l-.353.353.353.354c.043.043.105.141.154.315.048.167.075.37.075.581 0 .212-.027.414-.075.582-.05.174-.111.272-.154.315l-.353.353.353.354c.047.047.109.177.005.488a2.2 2.2 0 0 1-.505.805l-.353.353.353.354c.006.005.041.05.041.17a.9.9 0 0 1-.121.416c-.165.288-.503.56-1.066.56z"/>
    </symbol>
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="unfavorite" viewBox="0 0 16 16">
      <path d="M6.956 1.745C7.021.81 7.908.087 8.864.325l.261.066c.463.116.874.456 1.012.965.22.816.533 2.511.062 4.51a10 10 0 0 1 .443-.051c.713-.065 1.669-.072 2.516.21.518.173.994.681 1.2 1.273.184.532.16 1.162-.234 1.733q.086.18.138.363c.077.27.113.567.113.856s-.036.586-.113.856c-.039.135-.09.273-.16.404.169.387.107.819-.003 1.148a3.2 3.2 0 0 1-.488.901c.054.152.076.312.076.465 0 .305-.089.625-.253.912C13.1 15.522 12.437 16 11.5 16H8c-.605 0-1.07-.081-1.466-.218a4.8 4.8 0 0 1-.97-.484l-.048-.03c-.504-.307-.999-.609-2.068-.722C2.682 14.464 2 13.846 2 13V9c0-.85.685-1.432 1.357-1.615.849-.232 1.574-.787 2.132-1.41.56-.627.914-1.28 1.039-1.639.199-.575.356-1.539.428-2.59z"/>
    </symbol>
    <!-- DISLIKE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="dislike" viewBox="0 0 16 16">
      <path d="M8.864 15.674c-.956.24-1.843-.484-1.908-1.42-.072-1.05-.23-2.015-.428-2.59-.125-.36-.479-1.012-1.04-1.638-.557-.624-1.282-1.179-2.131-1.41C2.685 8.432 2 7.85 2 7V3c0-.845.682-1.464 1.448-1.546 1.07-.113 1.564-.415 2.068-.723l.048-.029c.272-.166.578-.349.97-.484C6.931.08 7.395 0 8 0h3.5c.937 0 1.599.478 1.934 1.064.164.287.254.607.254.913 0 .152-.023.312-.077.464.201.262.38.577.488.9.11.33.172.762.004 1.15.069.13.12.268.159.403.077.27.113.567.113.856s-.036.586-.113.856c-.035.12-.08.244-.138.363.394.571.418 1.2.234 1.733-.206.592-.682 1.1-1.2 1.272-.847.283-1.803.276-2.516.211a10 10 0 0 1-.443-.05 9.36 9.36 0 0 1-.062 4.51c-.138.508-.55.848-1.012.964zM11.5 1H8c-.51 0-.863.068-1.14.163-.281.097-.506.229-.776.393l-.04.025c-.555.338-1.198.73-2.49.868-.333.035-.554.29-.554.55V7c0 .255.226.543.62.65 1.095.3 1.977.997 2.614 1.709.635.71 1.064 1.475 1.238 1.977.243.7.407 1.768.482 2.85.025.362.36.595.667.518l.262-.065c.16-.04.258-.144.288-.255a8.34 8.34 0 0 0-.145-4.726.5.5 0 0 1 .595-.643h.003l.014.004.058.013a9 9 0 0 0 1.036.157c.663.06 1.457.054 2.11-.163.175-.059.45-.301.57-.651.107-.308.087-.67-.266-1.021L12.793 7l.353-.354c.043-.042.105-.14.154-.315.048-.167.075-.37.075-.581s-.027-.414-.075-.581c-.05-.174-.111-.273-.154-.315l-.353-.354.353-.354c.047-.047.109-.176.005-.488a2.2 2.2 0 0 0-.505-.804l-.353-.354.353-.354c.006-.005.041-.05.041-.17a.9.9 0 0 0-.121-.415C12.4 1.272 12.063 1 11.5 1"/>
    </symbol>
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="undislike" viewBox="0 0 16 16">
      <path d="M6.956 14.534c.065.936.952 1.659 1.908 1.42l.261-.065a1.38 1.38 0 0 0 1.012-.965c.22-.816.533-2.512.062-4.51q.205.03.443.051c.713.065 1.669.071 2.516-.211.518-.173.994-.68 1.2-1.272a1.9 1.9 0 0 0-.234-1.734c.058-.118.103-.242.138-.362.077-.27.113-.568.113-.856 0-.29-.036-.586-.113-.857a2 2 0 0 0-.16-.403c.169-.387.107-.82-.003-1.149a3.2 3.2 0 0 0-.488-.9c.054-.153.076-.313.076-.465a1.86 1.86 0 0 0-.253-.912C13.1.757 12.437.28 11.5.28H8c-.605 0-1.07.08-1.466.217a4.8 4.8 0 0 0-.97.485l-.048.029c-.504.308-.999.61-2.068.723C2.682 1.815 2 2.434 2 3.279v4c0 .851.685 1.433 1.357 1.616.849.232 1.574.787 2.132 1.41.56.626.914 1.28 1.039 1.638.199.575.356 1.54.428 2.591"/>
    </symbol>
    <!-- LIST CHECK -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="list" viewBox="0 0 16 16">
      <path d="M12 13c0 1.105-1.12 2-2.5 2S7 14.105 7 13s1.12-2 2.5-2 2.5.895 2.5 2"/>
      <path d="M12 3v10h-1V3z"/>
      <path d="M11 2.82a1 1 0 0 1 .804-.98l3-.6A1 1 0 0 1 16 2.22V4l-5 1z"/>
      <path d="M0 11.5a.5.5 0 0 1 .5-.5H4a.5.5 0 0 1 0 1H.5a.5.5 0 0 1-.5-.5m0-4A.5.5 0 0 1 .5 7H8a.5.5 0 0 1 0 1H.5a.5.5 0 0 1-.5-.5m0-4A.5.5 0 0 1 .5 3H8a.5.5 0 0 1 0 1H.5a.5.5 0 0 1-.5-.5"/>
    </symbol>
    <!-- BACK -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="back" viewBox="0 0 16 16">
      <path d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0"/>
    </symbol>
    <!-- SEARCH -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="search" viewBox="0 0 16 16">
      <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
    </symbol>
    <!-- RESET -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="reset" viewBox="0 0 16 16">
      <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708"/>
    </symbol>
    <!-- MUTE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="mute" viewBox="0 0 16 16">
      <path d="M9 4a.5.5 0 0 0-.812-.39L5.825 5.5H3.5A.5.5 0 0 0 3 6v4a.5.5 0 0 0 .5.5h2.325l2.363 1.89A.5.5 0 0 0 9 12zM6.312 6.39 8 5.04v5.92L6.312 9.61A.5.5 0 0 0 6 9.5H4v-3h2a.5.5 0 0 0 .312-.11M12.025 8a4.5 4.5 0 0 1-1.318 3.182L10 10.475A3.5 3.5 0 0 0 11.025 8 3.5 3.5 0 0 0 10 5.525l.707-.707A4.5 4.5 0 0 1 12.025 8"/>
    </symbol>
    <!-- UNMUTE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="unmute" viewBox="0 0 16 16">
      <path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06M6 5.04 4.312 6.39A.5.5 0 0 1 4 6.5H2v3h2a.5.5 0 0 1 .312.11L6 10.96zm7.854.606a.5.5 0 0 1 0 .708L12.207 8l1.647 1.646a.5.5 0 0 1-.708.708L11.5 8.707l-1.646 1.647a.5.5 0 0 1-.708-.708L10.793 8 9.146 6.354a.5.5 0 1 1 .708-.708L11.5 7.293l1.646-1.647a.5.5 0 0 1 .708 0"/>
    </symbol>
    <!-- READ FROM URL -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="read-from-url" viewBox="0 0 16 16">
      <path d="M11 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8M6.025 7.5a5 5 0 1 1 0 1H4A1.5 1.5 0 0 1 2.5 10h-1A1.5 1.5 0 0 1 0 8.5v-1A1.5 1.5 0 0 1 1.5 6h1A1.5 1.5 0 0 1 4 7.5zM11 5a.5.5 0 0 1 .5.5v2h2a.5.5 0 0 1 0 1h-2v2a.5.5 0 0 1-1 0v-2h-2a.5.5 0 0 1 0-1h2v-2A.5.5 0 0 1 11 5M1.5 7a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5z"/>
    </symbol>
    <!-- UPDATE FROM URL -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="update-from-url" viewBox="0 0 16 16">
      <path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
      <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
    </symbol>
    <!-- PAUSE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="pause" viewBox="0 0 16 16">
      <path d="M6 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5m4 0a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5"/>
    </symbol>
    <!-- UNPAUSE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="unpause" viewBox="0 0 16 16">
      <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>
      <path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445"/>
    </symbol>
    <!-- PIN -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="pin" viewBox="0 0 16 16">
      <path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5c0 .276-.224 1.5-.5 1.5s-.5-1.224-.5-1.5V10h-4a.5.5 0 0 1-.5-.5c0-.973.64-1.725 1.17-2.189A6 6 0 0 1 5 6.708V2.277a3 3 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354m1.58 1.408-.002-.001zm-.002-.001.002.001A.5.5 0 0 1 6 2v5a.5.5 0 0 1-.276.447h-.002l-.012.007-.054.03a5 5 0 0 0-.827.58c-.318.278-.585.596-.725.936h7.792c-.14-.34-.407-.658-.725-.936a5 5 0 0 0-.881-.61l-.012-.006h-.002A.5.5 0 0 1 10 7V2a.5.5 0 0 1 .295-.458 1.8 1.8 0 0 0 .351-.271c.08-.08.155-.17.214-.271H5.14q.091.15.214.271a1.8 1.8 0 0 0 .37.282"/>
    </symbol>
    <!-- UNPIN -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="unpin" viewBox="0 0 16 16">
      <path d="M9.828.722a.5.5 0 0 1 .354.146l4.95 4.95a.5.5 0 0 1 0 .707c-.48.48-1.072.588-1.503.588-.177 0-.335-.018-.46-.039l-3.134 3.134a6 6 0 0 1 .16 1.013c.046.702-.032 1.687-.72 2.375a.5.5 0 0 1-.707 0l-2.829-2.828-3.182 3.182c-.195.195-1.219.902-1.414.707s.512-1.22.707-1.414l3.182-3.182-2.828-2.829a.5.5 0 0 1 0-.707c.688-.688 1.673-.767 2.375-.72a6 6 0 0 1 1.013.16l3.134-3.133a3 3 0 0 1-.04-.461c0-.43.108-1.022.589-1.503a.5.5 0 0 1 .353-.146m.122 2.112v-.002zm0-.002v.002a.5.5 0 0 1-.122.51L6.293 6.878a.5.5 0 0 1-.511.12H5.78l-.014-.004a5 5 0 0 0-.288-.076 5 5 0 0 0-.765-.116c-.422-.028-.836.008-1.175.15l5.51 5.509c.141-.34.177-.753.149-1.175a5 5 0 0 0-.192-1.054l-.004-.013v-.001a.5.5 0 0 1 .12-.512l3.536-3.535a.5.5 0 0 1 .532-.115l.096.022c.087.017.208.034.344.034q.172.002.343-.04L9.927 2.028q-.042.172-.04.343a1.8 1.8 0 0 0 .062.46z"/>
    </symbol>
    <!-- CHANNEL -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="channel" viewBox="0 0 16 16">
      <path d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5M3.854 2.146a.5.5 0 0 1 0 .708l-1.5 1.5a.5.5 0 0 1-.708 0l-.5-.5a.5.5 0 1 1 .708-.708L2 3.293l1.146-1.147a.5.5 0 0 1 .708 0m0 4a.5.5 0 0 1 0 .708l-1.5 1.5a.5.5 0 0 1-.708 0l-.5-.5a.5.5 0 1 1 .708-.708L2 7.293l1.146-1.147a.5.5 0 0 1 .708 0m0 4a.5.5 0 0 1 0 .708l-1.5 1.5a.5.5 0 0 1-.708 0l-.5-.5a.5.5 0 0 1 .708-.708l.146.147 1.146-1.147a.5.5 0 0 1 .708 0"/>
    </symbol>
    <!-- PICTURE-IN-PICTURE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="picture-in-picture" viewBox="0 0 16 16">
      <path d="M0 3.5A1.5 1.5 0 0 1 1.5 2h13A1.5 1.5 0 0 1 16 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 12.5zM1.5 3a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5z"/>
      <path d="M8 8.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5z"/>
    </symbol>
    <!-- NEXT PAGE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="next" viewBox="0 0 16 16">
      <path d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8"/>
    </symbol>
    <!-- PREVIOUS PAGE -->
    <symbol xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" id="prev" viewBox="0 0 16 16">
      <path d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8"/>
    </symbol>
  </svg>

  <div class="container" id="pageContainer">
    <div id="m3uInputContainer">
      <div class="box">
        <div class="m3u-controls">
          <input type="url" id="m3uUrlInput" required placeholder="输入 M3U 文件 URL">
          <button id="loadM3uButton"><svg width="20" height="20"><use xlink:href="#read-from-url"/></svg></button>
          <button id="closeM3uButton"><svg width="20" height="20"><use xlink:href="#close"/></svg></button>
        </div>
  
        <div id="m3uList"></div>
  
        <div class="tools">
          <div class="settings-row">
            <label class="label">自动检查可用性</label>
            <label class="switch">
              <input type="checkbox" id="autoCheckCheckbox">
              <span class="slider"></span>
            </label>
          </div>
  
          <div class="settings-row">
            <label class="label">检查缩略图</label>
            <label class="switch">
              <input type="checkbox" id="storeFrameCheckbox">
              <span class="slider"></span>
            </label>
          </div>
  
          <div class="settings-row">
            <label class="label">截图时间 (<span id="screenshotTimeDisplay">0</span>s)</label>
            <input type="range" id="screenshotTime" class="range" min="1" max="300" step="1">
          </div>
  
          <div class="settings-row">
            <label class="label">跳过可用缩略图</label>
            <label class="switch">
              <input type="checkbox" id="onlyCheckBrokenCheckbox">
              <span class="slider"></span>
            </label>
          </div>
  
          <div class="settings-row">
            <label class="label">播放时静音</label>
            <label class="switch">
              <input type="checkbox" id="muteWhenPlayCheckbox">
              <span class="slider"></span>
            </label>
          </div>
  
          <div class="settings-row">
            <label class="label">检查超时 (<span id="checkTimeoutDisplay">0</span>ms)</label>
            <input type="range" id="checkTimeout" class="range" min="5" max="60" step="1">
          </div>
  
          <div class="settings-row settings-usage hidden">
            <label class="label">数据使用情况</label>
            <div id="databaseSize"></div>
          </div>
  
          <div class="settings-row settings-usage hidden">
            <div id="databaseCategories"></div>
          </div>
  
          <div class="settings-row">
            <label class="label">启用日志</label>
            <label class="switch">
              <input type="checkbox" id="enableLoggingCheckbox">
              <span class="slider"></span>
            </label>
          </div>
        </div>
  
        <div id="logContainer" class="tools hidden">
          <div class="debug">
            <button id="logClearButton" class="hidden"><svg width="20" height="20"><use xlink:href="#reset"/></svg></button>
            <code id="debugLogs">&gt; 日志</code>
          </div>
        </div>

      </div>
    </div>
    <div class="player-interface">
      <div id="playlistContainer">
        <div class="box">
          <div id="playlistContent">
            <div class="top-buttons" id="topButtons">
              <button type="button" id="closeButton"><svg width="20" height="20"><use xlink:href="#close"/></svg></button>
              <button type="button" id="channelButton">加载中...</button>
              <button type="button" id="searchFormButton" class="channel-hidden"><svg width="20" height="20"><use xlink:href="#search"/></svg></button>
              <button type="button" id="listCheckButton" class="channel-hidden" data-checking="false"><svg width="20" height="20"><use xlink:href="#list-check"/></svg></button>
            </div>

            <form id="searchContainer" class="hidden">
              <div class="search">
                <input type="text" id="searchInput" required placeholder="搜索...">
                <button type="reset" id="clearButton" class="hidden"><svg width="20" height="20"><use xlink:href="#reset"/></svg></button>
              </div>
              <button type="submit" id="searchButton" class="hidden"><svg width="20" height="20"><use xlink:href="#search"/></svg></button>
            </form>

            <ul id="channelList" class="menu-list hidden"></ul>
            <ul id="playlistItems" class="menu-list"></ul>

            <div id="pageControls" class="page-controls">
              <div id="pagination">
                <button id="prevPage" disabled><svg width="20" height="20"><use xlink:href="#prev"/></svg></button>
                <div class="page-information">
                  <input id="pageControl" class="range" min="1" type="range">
                  <div id="pageInfo"></div>
                </div>
                <button id="nextPage" disabled><svg width="20" height="20"><use xlink:href="#next"/></svg></button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="video-container">
        <div class="box box-video">
          <div class="video-wrapper">

            <figure id="videoContainer">
              <video id="videoPlayer" playsinline poster="background.jpeg"></video>
              <div id="videoControls" class="user-controls controls transparent">
                <div class="buttons">
                  <button id="playVideoButton" disabled class="stopped"><svg width="20" height="20"><use xlink:href="#play"/></svg></button>
                  <button id="pauseVideoButton" class="hidden"><svg width="20" height="20"><use xlink:href="#pause"/></svg></button>
                  <div class="divider"></div>
                  <button id="pinButton"><svg width="20" height="20"><use xlink:href="#unpin"/></svg></button>
                  <button id="speakerButton"><svg width="20" height="20"><use xlink:href="#mute"/></svg></button>
                  <button id="pipButton" disabled><svg width="20" height="20"><use xlink:href="#picture-in-picture"/></svg></button>
                  <button id="fullscreenButton" class="hidden" disabled><svg width="20" height="20"><use xlink:href="#fullscreen"/></svg></button>
                </div>
                <div id="progressBar" class="progress">
                  <span id="currentTimeDisplay" class="time">00:00</span>
                  <input id="progressControl" class="range hidden" type="range" value="0" min="0" max="0">
                  <span id="totalTimeDisplay" class="time">00:00</span>
                </div>
              </div>
            </figure>

            <video id="frameVideo" playsinline muted></video>
          </div>
        </div>
        <div class="box box-controls">
          <div id="bottomButtons" class="user-controls">
            <button id="rewindButton" disabled><svg width="20" height="20"><use xlink:href="#rewind"/></svg></button>
            <button id="forwardButton" disabled><svg width="20" height="20"><use xlink:href="#forward"/></svg></button>
            <button id="favoriteButton" disabled><svg width="20" height="20"><use xlink:href="#favorite"/></svg></button>
            <button id="dislikeButton" disabled><svg width="20" height="20"><use xlink:href="#dislike"/></svg></button>
            <button id="reCaptureButton" disabled><svg width="20" height="20"><use xlink:href="#list-check"/></svg></button>
            <button id="settingsButton"><svg width="20" height="20"><use xlink:href="#gear"/></svg></button>
            <button id="playListButton"><svg width="20" height="20"><use xlink:href="#list"/></svg></button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
const DB_VERSION = 19;
const UNSAFE_HTTP = 'http://';
const CONSTS = {
  IS_NATIVE: (typeof window.electronAPI !== 'undefined'),
  ICON_PLAY: '<svg width="20" height="20"><use xlink:href="#play"/></svg>',
  ICON_UNPAUSE: '<svg width="20" height="20"><use xlink:href="#unpause"/></svg>',
  ICON_PAUSE: '<svg width="20" height="20"><use xlink:href="#pause"/></svg>',
  ICON_STOP: '<svg width="20" height="20"><use xlink:href="#stop"/></svg>',
  ICON_CANCEL: '<svg width="20" height="20"><use xlink:href="#cancel"/></svg>',
  ICON_FULLSCREEN: '<svg width="20" height="20"><use xlink:href="#fullscreen"/></svg>',
  ICON_UNFAVORITE: '<svg width="20" height="20"><use xlink:href="#unfavorite"/></svg>',
  ICON_FAVORITE: '<svg width="20" height="20"><use xlink:href="#favorite"/></svg>',
  ICON_DISLIKE: '<svg width="20" height="20"><use xlink:href="#dislike"/></svg>',
  ICON_UNDISLIKE: '<svg width="20" height="20"><use xlink:href="#undislike"/></svg>',
  ICON_SPEAKER_ON: '<svg width="20" height="20"><use xlink:href="#unmute"/></svg>',
  ICON_SPEAKER_OFF: '<svg width="20" height="20"><use xlink:href="#mute"/></svg>',
  ICON_READ_FROM_URL: '<svg width="20" height="20"><use xlink:href="#read-from-url"/></svg>',
  ICON_UPDATE_FROM_URL: '<svg width="20" height="20"><use xlink:href="#update-from-url"/></svg>',
  ICON_PINNED: '<svg width="20" height="20"><use xlink:href="#pin"/></svg>',
  ICON_UNPINNED: '<svg width="20" height="20"><use xlink:href="#unpin"/></svg>',
  ICON_CHECK: '<svg width="20" height="20"><use xlink:href="#list-check"/></svg>',
  ICON_CLOSE: '<svg width="20" height="20"><use xlink:href="#close"/></svg>',
  ICON_BACK: '<svg width="20" height="20"><use xlink:href="#back"/></svg>',
  POSTER: 'background.jpeg',
  KILOBYTE: 1024,
  MEGABYTE: 1048576,
  /** @type {string} **/
  BASE_URL: (typeof window.electronAPI === 'undefined') ? window.location.origin : 'https://mihui.net',
  CONTROL_DISPLAY_TIMEOUT: 1500,
  CODES: {
    NONE: 0,
    LIKE: 1,
    DISLIKE: 2
  },
  CHANNELS: {
    RAW: '原始频道',
    ALL: '所有频道',
    FAVORITE: '收藏频道'
  },
  PLAYER: {
    PLAYBACK_RATE_FAST: 2,
    PLAYBACK_RATE_NORMAL: 1,
    PRESS_TOLERANCE_TIME: 500,
  },
  STATUS: {
    OK: 1,
    BAD: 0
  }
};

const TYPES = { M3U: 'm3u', TXT: 'txt' };
const SOURCES = { URL: 'url', CONTENT: 'content' };
const VARS = {
  CURRENT_TITLE: '', CURRENT_GROUP: '', CURRENT_URL: '', CURRENT_ID: '',
  PING_TIMEOUT: 0, THUMBNAIL_TIMEOUT: 3,
  URLS: new Set(),
  /** @type {Object.<string, number>} **/
  VIDEO_PLAYED_DURATION: {},
  /** @type {string} **/
  TRANSACTION: '',
  ALWAYS_ON_TOP: false,
  DISLIKES: [],
  CONTROL_TIMER: 0,
  IS_GLOBALLY_HIDDEN: false,
  IS_AUTO_CHECK: false,
  IS_CHECKING_BROKEN_ONLY: false,
  IS_LOGGING_ENABLED: false,
  HAS_THUMBNAIL: false,
  IS_MUTED: false,
  PLAYLIST_PAGE: 1,
  ITEMS_PER_PAGE: 15,
  QUICK_PLAY_TIMER: 0,
};

const database = new Database(DB_VERSION);

class VideoStorage {
  cached = {};
  /**
   * Set into cache
   * @param {string} key Storage key
   * @param {any} data Data to be stored
   */
  set(key, data) {
    this.cached[key] = data;
  }
  /**
   * Get from LocalStorage
   * @param {string} key Storage key
   * @param {'json'|'string'|'number'|'integer'} type Data type
   * @returns {string|Object.<string, any>|boolean|number|null} Returns data
   */
  get(key, type = 'json') {
    if(Object.hasOwn(this.cached, key)) {
      return this.cached[key];
    }
    const data = window.localStorage.getItem(key);

    if(type === 'json') {
      if(data) {
        try {
          const json = JSON.parse(data);
          this.set(key, json);
          return json;
        }
        catch(error) {}
      }
      return null;
    }
    else if(type === 'number') {
      if(data) {
        return Number(data);
      }
      return null;
    }
    else if(type === 'integer') {
      if(data) {
        try {
          return parseInt(data);
        }
        catch(error) {}
      }
      return null;
    }
    this.set(key, data);
    return this.cached[key];

    return null;
  }
  /**
   * Get string from LocalStorage
   * @param {string} key Storage key
   * @returns {string|null} Returns data
   */
  getString(key) {
    return this.get(key, 'string');
  }
  /**
   * Get number from LocalStorage
   * @param {string} key Storage key
   * @returns {number|null} Returns data
   */
  getNumber(key) {
    return this.get(key, 'number');
  }
  /**
   * Get integer from LocalStorage
   * @param {string} key Storage key
   * @returns {number|null} Returns data
   */
  getInteger(key, defaultVal = 0) {
    const val = this.get(key, 'integer');
    if(typeof val === 'number')  {
      return val;
    }
    return defaultVal;
  }
  /**
   * Get JSON from LocalStorage
   * @param {string} key Storage key
   * @returns {Object.<string, any>|null} Returns data
   * @example
   * getJSON('my-json');
   * // returns { name: 'John', age: 30 }
   */
  getJSON(key) {
    return this.get(key, 'json');
  }
  /**
   * Get boolean from LocalStorage
   * @param {string} key Storage key
   * @param {boolean} defaultVal Default value
   * @returns {boolean} Returns data
   */
  getBoolean(key, defaultVal = false) {
    const val = this.get(key, 'boolean');
    if(['true', '1', 'yes', 'on', true].includes(val)) {
      return true;
    }
    if(['false', '0', 'no', 'off', true].includes(val)) {
      return false;
    }
    return defaultVal;
  }
  /**
   * Save into LocalStorage
   * @param {string} key Storage key
   * @param {any} data Data to be stored
   * @param {'json'|'string'|'number'} type Type of data to be stored
   */
  save(key, data, type = 'json') {
    this.set(key, data);
    window.localStorage.setItem(key, type === 'json' ? JSON.stringify(data) : data);
  }
  /**
   * Save string into LocalStorage
   * @param {string} key Storage key
   * @param {string} data Data to be stored
   */
  saveString(key, data) {
    return this.save(key, data, 'string');
  }
  /**
   * Save number into LocalStorage
   * @param {string} key Storage key
   * @param {number} data Data to be stored
   * @returns {void}
   */
  saveNumber(key, data) {
    return this.save(key, data, 'number');
  }
  /**
   * Save integer into LocalStorage
   * @param {string} key Storage key
   * @param {number} data Data to be stored
   * @returns {void}
   */
  saveInteger(key, data) {
    return this.save(key, data, 'integer');
  }
  /**
   * Save boolean data into LocalStorage
   * @param {string} key Storage key
   * @param {boolean} data Data to be stored
   */
  saveBoolean(key, data) {
    return this.save(key, data, 'boolean');
  }
  /**
   * Save JSON into LocalStorage
   * @param {string} key Storage key
   * @param {Object.<string, any>} json Data to be stored
   * @returns {void}
   * @example
   * saveJSON('my-json', {
   *   name: 'John',
   *   age: 30
   * });
   */
  saveJSON(key, json) {
    return this.save(key, json, 'json');
  }
  /**
   * Delete from LocalStorage
   * @param {string} key Storage key
   */
  delete(key) {
    window.localStorage.removeItem(key);
    delete this.cached[key];
  }
}

const storage = new VideoStorage();

function getElementById(idList = []) {
  const domList = [];
  for(const id of idList) {
    domList.push(document.getElementById(id));
  }
  return domList;
}

/** @type {[
 * HTMLBodyElement,
 * HTMLVideoElement, HTMLInputElement, HTMLButtonElement, HTMLButtonElement, HTMLButtonElement,
 * HTMLButtonElement, HTMLButtonElement, HTMLDivElement, HTMLDivElement,
 * HTMLButtonElement, HTMLDivElement, HTMLFormElement, HTMLButtonElement, HTMLButtonElement,
 * HTMLButtonElement, HTMLButtonElement, HTMLButtonElement, HTMLButtonElement, HTMLInputElement,
 * HTMLButtonElement, HTMLButtonElement, HTMLButtonElement, HTMLDivElement, HTMLButtonElement,
 * HTMLInputElement, HTMLButtonElement, HTMLButtonElement, HTMLInputElement, HTMLUListElement,
 * HTMLUListElement, HTMLDivElement, HTMLElement, HTMLButtonElement, HTMLDivElement,
 * HTMLDivElement, HTMLButtonElement, HTMLDivElement, HTMLInputElement, HTMLInputElement,
 * HTMLInputElement, HTMLSpanElement, HTMLElement, HTMLVideoElement,
 * HTMLInputElement, HTMLSpanElement, HTMLSpanElement, HTMLDivElement, HTMLButtonElement,
 * HTMLInputElement,
 * HTMLDivElement, HTMLInputElement, HTMLDivElement, HTMLButtonElement, HTMLInputElement,
 * HTMLSpanElement, HTMLInputElement, HTMLButtonElement, HTMLButtonElement, HTMLDivElement,
 * ]} **/
const [
  pageBody,
  videoPlayer, m3uUrlInput, closeM3uButton, pipButton, searchFormButton,
  loadM3uButton, settingsButton, m3uInputContainer, playlistContent,
  playVideoButton, m3uList, searchContainer, speakerButton, channelButton,
  favoriteButton, playListButton, rewindButton, forwardButton, searchInput,
  fullscreenButton, prevButton, nextButton, pageInfo, listCheckButton,
  pageControl, clearButton, closeButton, m3uContentKey, channelList,
  playlistItems, paginationGroup, videoContainer, dislikeButton, pageControls,
  pageContainer, databaseSize, databaseCategories, storeFrameCheckbox, autoCheckCheckbox,
  checkTimeout, checkTimeoutDisplay, debugLogs, frameVideo,
  progressControl, currentTimeDisplay, totalTimeDisplay, videoControls, logClearButton,
  onlyCheckBrokenCheckbox,
  progressBar, enableLoggingCheckbox, logContainer, pauseVideoButton, screenshotTime,
  screenshotTimeDisplay, muteWhenPlayCheckbox, reCaptureButton, pinButton, topButtons,
 ] = 
getElementById([
  'pageBody',
  'videoPlayer', 'm3uUrlInput', 'closeM3uButton', 'pipButton', 'searchFormButton',
  'loadM3uButton', 'settingsButton', 'm3uInputContainer', 'playlistContent',
  'playVideoButton', 'm3uList', 'searchContainer', 'speakerButton', 'channelButton',
  'favoriteButton', 'playListButton', 'rewindButton', 'forwardButton', 'searchInput',
  'fullscreenButton', 'prevPage', 'nextPage', 'pageInfo', 'listCheckButton',
  'pageControl', 'clearButton', 'closeButton', 'm3uContentKey', 'channelList',
  'playlistItems', 'pagination', 'videoContainer', 'dislikeButton', 'pageControls',
  'pageContainer', 'databaseSize', 'databaseCategories', 'storeFrameCheckbox', 'autoCheckCheckbox',
  'checkTimeout', 'checkTimeoutDisplay', 'debugLogs', 'frameVideo',
  'progressControl', 'currentTimeDisplay', 'totalTimeDisplay', 'videoControls', 'logClearButton',
  'onlyCheckBrokenCheckbox',
  'progressBar', 'enableLoggingCheckbox', 'logContainer', 'pauseVideoButton', 'screenshotTime',
  'screenshotTimeDisplay', 'muteWhenPlayCheckbox', 'reCaptureButton', 'pinButton', 'topButtons',
]);

/** @type {Array<{ title: string, url: string, group: string }>} **/
let filteredPlaylistData = [];
let stopURL = null;

class AppShell {
  /** @type {Object.<string, Array<{ title: string, group: string, url: string }>>} **/
  channels = {};
  blacklist = [];
  SITE_TITLE = 'Hunhe IPTV';
  currentCategory = CONSTS.CHANNELS.ALL;
  /** @type {WakeLockSentinel|null} */
  wakeLockSentinel = null;

  /**
   * Get channels
   * @param {Object.<string, Array<{ title: string, group: string, url: string }>>} channels Channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Set channels
   * @param {Object.<string, Array<{ title: string, group: string, url: string }>>} channels Channels
   */
  setChannels(channels) {
    this.channels = channels;
  }
  /**
   * @param {string} key Channel key
   * @param {Array<{ title: string, group: string, url: string }>} channel Channel
   */
  setChannel(key, channel) {
    this.channels[key] = channel;
  }
  /**
   * Initialize channel
   * @param {string} key Channel key
   */
  initChannel(key) {
    if (Object.hasOwn(this.channels, key) === false) {
      this.setChannel(key, []);
    }
  }
  /**
   * Add channel
   * @param {string} key Channel key
   * @param {Array<{ title: string, group: string, url: string }>} channel Channel
   */
  addChannel(key, channel) {
    this.channels[key].push(channel);
  }
  /**
   * Get channel data
   * @param {string} key Channel key
   * @returns {Array<{ title: string, group: string, url: string }>} Channel
   */
  getChannel(key) {
    return this.channels[key];
  }
  /**
   * Get selected channel
   * @param {string} key Channel key
   * @param {Array<{ title: string, group: string, url: string }>} channel Channel
   */
  getSelectedChannel() {
    return this.channels[this.currentCategory];
  }
  /**
   * @param {URL} url Video URL
   */
  addBlackList(url) {
    if(this.blacklist.indexOf(url.hostname) === -1) {
      this.blacklist.push(url.hostname);
    }
  }

  displayPlayerControls(showNativeControls = false, showCustomControls = false) {
    if (document.fullscreenEnabled) {
      if(showCustomControls) {
        videoControls.classList.remove('transparent');
      }
      else if(showNativeControls) {
        videoPlayer.controls = showNativeControls;
      }
      else {
        videoControls.classList.add('transparent');
      }
      return true;
    }
    videoPlayer.controls = true;
    return false;
  }

  initUI() {
    const playListVisible = storage.getString('is-playlist-visible') || 'false';
    if(playListVisible === 'false') {
      pageBody.classList.remove('menu');
    }
    else {
      pageBody.classList.add('menu');
    }

    if(this.displayPlayerControls()) {
      fullscreenButton.classList.remove('hidden');
    }
  }

  /**
   * @param {string} url Request URL
   * @param {Object} opts Request options
   * @returns {Promise<string>} Returns the response
   */
  async makeRequest(url, opts = {}) {
    return new Promise((resolve, reject) => {
      /** @type {RequestInit} */
      const options = { referrerPolicy: 'no-referrer', ...opts };
      const response = fetch(url, options).then(response => {
        if (response.ok || response.status === 302) {
          response.text().then(data => {
            if (data) {
              resolve(data); 
            }
          }).catch(error => {
            reject(error);
          });
        }
      }).catch(error => {
        reject(error);
      });
    });
  }

  /**
   * Generate a blank frame for the video
   */
  generateBlankFrame() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'darkblue';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    canvas.toBlob(blob => {
      stopURL = URL.createObjectURL(blob);
    }, 'video/mp4');
  }
  /**
   * Convert a timestamp to a time ago string
   * @param {string} timestamp Timestamp
   */
  timeAgo(timestamp) {
    if (typeof timestamp !== 'number' || isNaN(timestamp) || timestamp < 0) {
      return '未知';
    }
    const now = new Date().getTime();
    const secondsPast = Math.floor((now - timestamp) / 1000);
    if (secondsPast < 5) {
      return '刚刚';
    }
    if (secondsPast < 60) {
      return Math.floor(secondsPast) + ' 秒前';
    }
    if (secondsPast < 3600) {
      return Math.floor(secondsPast / 60) + ' 分钟前';
    }
    if (secondsPast < 86400) {
      return Math.floor(secondsPast / 3600) + ' 小时前';
    }
    if (secondsPast < 30 * 86400) { // 30天
      return Math.floor(secondsPast / 86400) + ' 天前';
    }
    if (secondsPast < 365 * 86400) { // 365天
      return Math.floor(secondsPast / (30 * 86400)) + ' 月前';
    }
    return Math.floor(secondsPast / (365 * 86400)) + ' 年前';
  }
  /**
   * Change the title of the page
   * @param {string} title The title to set
   */
  changeTitle(title) { document.title = title; }
  /**
   * Reset title
   */
  resetTitle() {
    this.changeTitle(this.SITE_TITLE);
  }
  /**
   * Put the page on top
   * @param {boolean} isOnTop Whether the page is on top
   */
  putOnTop(isOnTop) {}
  /**
   * Get the cached Playlist URL
   * @return {string} The cached m3u URL
   */
  getPlayListUrl() {
    return storage.getString('playlist-url') || '';
  }
  /**
   * @param {string} itemCode The item code to fetch
   */
  async fetchFavorites(itemCode = CONSTS.CODES.LIKE) {
    /** @type {{ data: Array<{ id: string, code: string }> }} */
    const { data } = await database.listData(FAV_STORE);
    this.setChannel(CONSTS.CHANNELS.FAVORITE, data.filter(x => x.code === itemCode || typeof x.code === 'undefined'));
    return this.getChannel(CONSTS.CHANNELS.FAVORITE);
  }
  /**
   * @param {string} itemCode The item code to fetch
   */
  async fetchDislikes(itemCode = CONSTS.CODES.DISLIKE) {
    /** @type {{ data: Array<{ id: string, code: string }> }} */
    const { data } = await database.listData(FAV_STORE);
    VARS.DISLIKES = data.filter(x => x.code === itemCode).map(x => x.id);
  }
  /**
   * Get last played video data
   * @returns {{ url: string, group: string, title: string }?} Returns Play item
   */
  getLastVideoItem() {
    const data = storage.getJSON('last-played-video');
    return data;
  }
  /**
   * If the URL is favorite
   * @param {string} id ID
   * @returns {Promise<number>} Returns true or false
   */
  async fetchPlayItemCode(id) {
    const { data, error } = await database.readData(id, FAV_STORE);
    if(error) {
      printLog('fetchPlayItemCode.error', error.message);
      return CONSTS.CODES.NONE;
    }
    return data ? data.code : CONSTS.CODES.NONE;
  }

  refreshDislikeButton(itemCode) {
    if(itemCode === CONSTS.CODES.DISLIKE) {
      dislikeButton.innerHTML = CONSTS.ICON_UNDISLIKE;
      dislikeButton.dataset['action'] = 'remove';
      dislikeButton.classList.add('remove');
    }
    else {
      dislikeButton.innerHTML = CONSTS.ICON_DISLIKE;
      dislikeButton.dataset['action'] = 'add';
      dislikeButton.classList.remove('remove');
    }
    dislikeButton.disabled = false;
  }
  /**
   * @param {{ title: string, url: string, group: string }} item Play item
   */
  async loadFavorite(item) {
    dislikeButton.dataset['id'] = favoriteButton.dataset['id'] = item.id;
    dislikeButton.dataset['url'] = favoriteButton.dataset['url'] = item.url;
    dislikeButton.dataset['group'] = favoriteButton.dataset['group'] = item.group;
    dislikeButton.dataset['title'] = favoriteButton.dataset['title'] = item.title;

    const itemCode = await this.fetchPlayItemCode(item.id);
    this.refreshFavoriteButton(itemCode);
    this.refreshDislikeButton(itemCode);
  }

  loadReCapture(item) {
    reCaptureButton.disabled = false;
    reCaptureButton.dataset['id'] = item.id;
    reCaptureButton.dataset['url'] = item.url;
    reCaptureButton.dataset['group'] = item.group;
    reCaptureButton.dataset['title'] = item.title;
    reCaptureButton.classList.add('recapture');
  }

  muteOrUnmuteVideo(mute) {
    videoPlayer.muted = mute;
    speakerButton.innerHTML = videoPlayer.muted ? CONSTS.ICON_SPEAKER_ON : CONSTS.ICON_SPEAKER_OFF;
  }
  /**
   * @param {{ title: string, url: string, group: string }} playingItem Play item
   * @param {string} duration Duration
   * @param {boolean} isLive Is live
   **/
  async onPlay(playingItem, duration = '0', isLive = false) {
    this.showErrorMessage();
    currentTimeDisplay.textContent = this.getMinutes(videoPlayer.currentTime);
    totalTimeDisplay.textContent = this.getMinutes(duration);
    progressControl.max = duration;
    if(isLive) {
      progressBar.classList.add('hidden');
      totalTimeDisplay.classList.add('hidden');
      currentTimeDisplay.classList.add('hidden');
    }
    else {
      progressBar.classList.remove('hidden');
      totalTimeDisplay.classList.remove('hidden');
      currentTimeDisplay.classList.remove('hidden');
      pauseVideoButton.classList.remove('hidden');
    }
    this.saveLastPlayedVideo(playingItem);
  }
  /**
   * 播放视频
   * @param {{ url: string, group: string, title: string }} source Play data source
   * @param {number} duration Duration
   * @param {boolean} isLive Is alive
   */
  playVideSource(source, duration = '0', isLive = false) {
    const lastPlayedTime = VARS.VIDEO_PLAYED_DURATION[source.url];
    if (!isNaN(lastPlayedTime)) {
      videoPlayer.currentTime = lastPlayedTime;
    }
    videoPlayer.play().catch(error => {
      this.showErrorMessage('无法播放所选视频，请尝试其他源或检查网络连接。');
    }).then(() => {
      this.onPlay(source, duration, isLive);
    });
  }

  hlsPlay(source) {
    printLog('hlsPlay');
    try {
      const hls = new Hls({
        enableWorker: true,
        lowLatencyMode: true,
        capLevelToPlayerSize: true
      });
      hls.loadSource(source.url);
      hls.attachMedia(videoPlayer);
      hls.once(Hls.Events.LEVEL_LOADED, (evt, data) => {
        printLog('Hls.Events.LEVEL_LOADED');
        if (!data?.details) {
          return printLog('Warning: Data details is undefined.');
        }
        const duration = data?.details?.totalduration || 0;
        const isLive = data?.details?.live || false;
        this.playVideSource(source, duration, isLive);
      });
      hls.once(Hls.Events.MANIFEST_PARSED, (evt, data) => {
        printLog('Hls.Events.LEVEL_LOADED');
        if (!data?.details) {
          return printLog('Warning: Data details is undefined.');
        }
        const duration = data?.details?.totalduration || 0;
        const isLive = data?.details?.live || false;
        this.playVideSource(source, duration, isLive);
      });
      hls.once(Hls.Events.ERROR, (error, data) => {
        printLog('Hls.Events.ERROR', 'data.fatal->', data.fatal, 'data.type->', data.type);
        printLog('Hls.Events.ERROR', JSON.stringify(error));
        if (data.fatal) {
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              printLog('Hls.ErrorTypes.NETWORK_ERROR', '重试网络请求');
              hls.startLoad();
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              printLog('Hls.ErrorTypes.MEDIA_ERROR', '处理媒体播放错误');
              if(videoPlayer.src === stopURL || videoPlayer.src === '') {
                printLog('Hls.ErrorTypes.MEDIA_ERROR', '停止视频');
                hls.destroy();
              }
              else if(videoPlayer.src) {
                printLog('Hls.ErrorTypes.MEDIA_ERROR', '重新加载视频');
                hls.swapAudioCodec();
                hls.recoverMediaError(); 
              }
              break;
            default:
              printLog(data.type, '其他错误类型');
              hls.destroy();
              break;
          }
        }
        else {
          printLog('HLS ERROR unknown');
        }
      });
    }
    catch(error) {
      printLog('HLS ERROR 1', error.message);
    }
  }

  onLoadedMetadata (evt) {
    printLog('videoPlayer.loadedmetadata');
    if (source) {
      this.playVideSource(source, evt.target.duration);
    }
  }

  nativePlay(source) {
    printLog('nativePlay');
    videoPlayer.removeEventListener('loadedmetadata', this.onLoadedMetadata);
    videoPlayer.src = source.url;
    videoPlayer.addEventListener('loadedmetadata', this.onLoadedMetadata);
  }

  refreshFavoriteButton(itemCode) {
    if(itemCode === CONSTS.CODES.LIKE) {
      favoriteButton.innerHTML = CONSTS.ICON_UNFAVORITE;
      favoriteButton.dataset['action'] = 'remove';
      favoriteButton.classList.add('remove');
    }
    else {
      favoriteButton.innerHTML = CONSTS.ICON_FAVORITE;
      favoriteButton.dataset['action'] = 'add';
      favoriteButton.classList.remove('remove');
    }
    favoriteButton.disabled = false;
  }

  getMinutes(duration) {
    // 类型检查和异常处理
    if (typeof duration !== 'number' || isNaN(duration) || Number.isNaN(duration)) {
      return '00:00';
    }

    const dNumber = parseInt(duration, 10);
    const minutes = Math.floor(dNumber / 60);
    const seconds = dNumber % 60;

    // 处理分钟数小于 10 的情况
    const formattedMinutes = minutes < 10 ? `0${minutes}` : minutes.toString();
    const formattedSeconds = seconds < 10 ? `0${seconds}` : seconds.toString();

    // 使用模板字符串拼接结果
    return `${formattedMinutes}:${formattedSeconds}`;
  }

  /**
   * 重置列表样式
   * @param {string} videoUrl 视频地址
   * @param {Array<string>} classList 样式列表
   */
   resetListStyles(videoUrl, classList = []) {
    classList.forEach(style => {
      this.resetListStyle(style);
    });
    playlistItems.childNodes.forEach((li) => {
      if(li.dataset['url'] === videoUrl) {
        classList.forEach(style => {
          li.classList.add(style);
        });
        return;
      }
    });
  }

  /**
   * @param {{ title: string, group: string, url: string }} source Play item
   * @param {boolean} isUserAction If it is controled by user
   */
  playVideo(source, isUserAction = true) {
    if (source) {
      this.changeTitle(source.title);
    } else {
      this.resetTitle();
    }
    this.loadVideoTimestamp();

    this.loadFavorite(source);
    this.loadReCapture(source);
    this.resetControlButtons(false, false);
    if(isUserAction === false) { return; }

    storage.delete('last-played-video');
    this.muteOrUnmuteVideo(VARS.IS_MUTED);

    currentTimeDisplay.textContent = this.getMinutes(0);
    totalTimeDisplay.textContent = this.getMinutes(0);
    progressControl.value = progressControl.max = '0';

    this.resetListStyles(source.url, ['preview', 'active']);

    if (Hls.isSupported() && (source.url.startsWith(UNSAFE_HTTP) === false || CONSTS.IS_NATIVE)) {
      this.hlsPlay(source);
    }
    else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
      this.nativePlay(source);
    }
    else {
      this.showErrorMessage('您的浏览器不支持 HLS 视频流。');
    }
  }

  playLastVideo(isUserAction = true) {
    const lastPlayedItem = this.getLastVideoItem();
    if (lastPlayedItem) {
      this.playVideo(lastPlayedItem, isUserAction);
    }
  }

  resetListStyle(className, list = playlistItems) {
    for(const node of list.childNodes) {
      node.classList.remove(className);
    }
  }
  /**
   * @param {HTMLLIElement} li List item
   * @param {{ title: string, url: string, group: string }} item Play item
   */
  playNow(li, item) {
    if(li.dataset['broken']) return;
    this.playVideo(item);
  }

  showPlayButton() {
    playVideoButton.innerHTML = CONSTS.ICON_PLAY;
    pauseVideoButton.innerHTML = CONSTS.ICON_UNPAUSE;
    playVideoButton.className = 'stopped';
    this.displayPlayerControls();
    videoPlayer.className = 'paused';
    pipButton.disabled = fullscreenButton.disabled = true;
  }

  changePoster(poster) {
    if(poster) {
      videoPlayer.poster = poster;
      pageBody.style.background = `transparent url("${poster}") center center / cover no-repeat`;
    }
  }

  isPlaying() {
    return videoPlayer.paused === false || playVideoButton.className === 'played' || playVideoButton.className === 'playing';
  }

  stopVideo(removePreview = true, isReset = false, poster = CONSTS.POSTER) {
    printLog('stopVideo');
    videoPlayer.pause();
    if(stopURL) videoPlayer.src = stopURL;
    videoPlayer.pause();
    videoPlayer.removeAttribute('src');
    videoPlayer.load();
    pauseVideoButton.classList.add('hidden');
    currentTimeDisplay.textContent = this.getMinutes(0);
    totalTimeDisplay.textContent = this.getMinutes(0);
    progressControl.value = progressControl.max = '0';

    this.resetTitle();
    this.showPlayButton();
    this.resetControlButtons(false, isReset);
    this.saveVideoTimestamp();
    this.changePoster(poster);
    this.resetListStyle('active');
    if(removePreview) {
      this.resetListStyle('preview');
    }
    this.releaseWakeLock();
  }
  /**
   * @param {HTMLLIElement} li List item
   * @param {{ title: string, url: string, group: string }} item Play item
   * @param {string} frame Poster
   */
  async previewNow(li, item, frame) {
    printLog('previewNow');
    this.stopVideo(true, false, frame);
    if(li.dataset['broken']) return;
    if(li.classList.contains('frame')) {
      li.classList.add('preview');
    }

    this.loadFavorite(item);
    this.loadReCapture(item);
    this.saveLastPlayedVideo(item);
  }
  /**
   * Get latency style
   * @param {string} message Message
   * @param {string} type Message type
   * @returns {string} Returns latency style
   */
  getLatencyStyle(latency) {
    if (latency < 800) return 'good';
    if (latency <= 2000) return 'average';
    return 'bad';
  }
  /**
   * @param {HTMLLIElement} li List item
   * @param {{ status: number, duration: number, frame: string, latency: number, timeout: boolean }} checkResult List item
   * @param {{ url: string, group: string, title: string }} lastPlayedItem Last played data
   */
  async updateListItemStyle(li, checkResult, lastPlayedItem) {
    const itemId = li.dataset['id'];
    const itemCode = await this.fetchPlayItemCode(itemId);
    li.className = '';
    if (checkResult.status === CONSTS.STATUS.OK) {
      li.classList.add(this.getLatencyStyle(checkResult.latency));
      if(checkResult.frame) {
        li.dataset['frame'] = URL.createObjectURL(checkResult.frame);
        li.classList.add('frame');
      }
      const durationText = checkResult.duration ? `[${this.getMinutes(checkResult.duration)}]` : '';
      li.dataset['duration'] = durationText;
    }
    else {
      if(checkResult.timeout) {
        li.dataset['timeout'] = true;
        li.classList.add('timeout');
      }
      else {
        li.classList.add('broken');
      }
    }
    if(lastPlayedItem?.url === li.dataset['url']) {
      li.classList.add('preview');
      if(this.isPlaying()) {
        li.classList.add('active');
      }
      if(li.classList.contains('frame')) {
        this.changePoster(li.dataset['frame']);
      }
    }
    if(itemCode === CONSTS.CODES.LIKE && this.currentCategory !== CONSTS.CHANNELS.FAVORITE) {
      li.classList.add('favorite');
    }
  }
  /**
   * @param {HTMLVideoElement} video Video tag
   * @param {string} url URL
   * @param {Hls?} hls Hls instance
   * @param {boolean} isRandom If the duration is random
   * @returns {Promise<{ frame: string, duration: number }?>} Returns frame URL
   */
  async captureFrame(url, hls = null, isRandom = false) {
    if(VARS.HAS_THUMBNAIL === false) { return null; }
    const canvas = document.createElement('canvas');
    const canvasContext = canvas.getContext('2d');

    /**
     * @type {(videoTag: HTMLVideoElement) => Promise<{ frame: string, duration: number }>} Draw video frame
     */
    const drawVideo = (videoTag) => {
      return new Promise((resolve, reject) => {
        canvas.width = videoTag.videoWidth;
        canvas.height = videoTag.videoHeight;
        canvasContext.drawImage(videoTag, 0, 0, canvas.width, canvas.height);
        canvas.toBlob((blob) => {
          if(videoTag.currentTime > 0) {
            return resolve({ frame: blob, duration: videoTag.duration });
          }
          return reject(null);
        });
      });
    };

    if(isRandom) {
      try {
        return await drawVideo(videoPlayer);
      }
      catch(error) {
        return await this.captureFrame(url, hls, false);
      }
    }
    const frame = await new Promise((resolve) => {
      let timer = 0;

      if(hls) {
        hls.attachMedia(frameVideo);
      }
      else if(url) {
        frameVideo.src = url;
      }
      else {
        return resolve(null);
      }
      const cleanupEvents = (payload) => {
        frameVideo.removeEventListener('seeked', onSeeked);
        frameVideo.removeEventListener('loadedmetadata', onLoadedMetaData);
        clearTimeout(timer);
        resolve(payload);
      };
      const onLoadedMetaData = (evt) => {
        canvas.width = frameVideo.videoWidth;
        canvas.height = frameVideo.videoHeight;
        frameVideo.play().then(() => {
          const captureTime = (isRandom ? Math.ceil(Math.random() * 300) : VARS.THUMBNAIL_TIMEOUT);
          frameVideo.currentTime = captureTime;
        }).catch(error => {
          cleanupEvents(null);
        });
      },
      onSeeked = (evt) => {
        drawVideo(frameVideo).then(data => {
          cleanupEvents(data);
        }).catch(error => {
          cleanupEvents(null);
        });
      };

      frameVideo.addEventListener('seeked', onSeeked);
      frameVideo.addEventListener('loadedmetadata', onLoadedMetaData);

      timer = setTimeout(() => {
        cleanupEvents(null);
      }, VARS.PING_TIMEOUT - 1000);
    });
    return frame;
  }

  /**
   * 检查视频可播放性
   * @param {string} url URL
   * @returns {{ status: number, duration: number, frame: string, latency: 0, timeout: boolean }}
   **/
  async checkVideoPlayability(url, isRandom = false) {
    const timestamp = new Date().getTime();
    return new Promise((resolve) => {
      let timeoutId = 0;
      let resolved = false;
      /**
       * Return value
       * @param {{ status: number, duration: number, frame: string, latency: number, timeout: boolean, alive: boolean }} val New value
       */
      const resolveProblem = (val) => {
        const data = Object.assign({}, {
          status: CONSTS.STATUS.BAD, duration: 0, frame: null, latency: new Date().getTime() - timestamp, timeout: false
        }, val);
        if (resolved) {
          console.log('repeated.data--->', data);
          return resolved;
        }
        console.log('resolved.data--->', data);
        resolved = true;
        return resolve(data);
      };
      let videoUrl = null;
      try {
        videoUrl = new URL(url);
        // if(this.blacklist.includes(videoUrl.hostname)) {
        //   throw new Error(`${videoUrl.hostname} is not available!`);
        // }
      }
      catch(error) {
        console.warn('error--->', error);
        return resolveProblem({ latency: new Date().getTime() - timestamp });
      }
      if (Hls.isSupported() && (url.startsWith(UNSAFE_HTTP) === false || CONSTS.IS_NATIVE)) {
        try {
          const hls = new Hls({
            enableWorker: true,
            lowLatencyMode: false,
            capLevelToPlayerSize: true,
            maxBufferHole: 5,
            maxBufferLength: 10,
            maxBufferSize: 60 * 1000 * 1000,
          });
          const cleanup = () => {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            hls.destroy();
          };

          hls.loadSource(url);
          hls.once(Hls.Events.MANIFEST_PARSED, async (evt, data) => {
            const latency = new Date().getTime() - timestamp;
            const captured = await this.captureFrame(url, hls, isRandom);
            cleanup();
            resolveProblem({ status: CONSTS.STATUS.OK, duration: captured?.duration, frame: captured?.frame, latency, event: Hls.Events.MANIFEST_PARSED });
          });

          hls.once(Hls.Events.ERROR, (error, data) => {
            console.warn(error, data);
            if(data.details === 'bufferSeekOverHole') {
              return;
            }
            cleanup();
            // this.addBlackList(videoUrl);
            resolveProblem({ latency: new Date().getTime() - timestamp, event: Hls.Events.ERROR });
          });

          timeoutId = setTimeout(() => {
            cleanup();
            resolveProblem({ latency: new Date().getTime() - timestamp, timeout: true, event: null });
          }, VARS.PING_TIMEOUT);
        }
        catch(error) {
          printLog('HLS ERROR 2');
        }
      }
      else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
        const video = document.createElement('video');
        video.src = url;
        const cleanup = () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          video.remove();
        };

        video.onloadedmetadata = async (evt) => {
          const latency = new Date().getTime() - timestamp;
          const captured = await this.captureFrame(url, null, isRandom);
          cleanup();
          resolveProblem({ status: CONSTS.STATUS.OK, latency, timeout: true, event: 'onloadedmetadata' });
        };

        video.onerror = () => {
          cleanup();
          this.addBlackList(videoUrl);
          resolveProblem({ latency: new Date().getTime() - timestamp, event: 'onerror' });
        };

        timeoutId = setTimeout(() => {
          cleanup();
          resolveProblem({ latency: new Date().getTime() - timestamp, timeout: true, event: null });
        }, VARS.PING_TIMEOUT);
      }
      else {
        resolveProblem({ latency: new Date().getTime() - timestamp, event: 'none', url });
      }
    });
  }

  async showCheckButton(isChecking) {
    if(isChecking) {
      listCheckButton.classList.add('checking');
      listCheckButton.innerHTML = CONSTS.ICON_CANCEL;
    }
    else {
      listCheckButton.classList.remove('checking');
      listCheckButton.innerHTML = CONSTS.ICON_CHECK;
    }
  }

  /**
   * Refresh video playability
   * @param {HTMLLIElement} li List item
   */
  async refreshVideoPlayability(li) {
    const videoUrl = li.dataset['url'];
    const id = li.dataset['id'];
    this.showCheckButton(true);
    // No cache or cleaned
    // Check video playability
    li.className = 'checking';
    const result = await this.checkVideoPlayability(videoUrl);
    await database.updateData({ id, result }, STA_STORE);
    const lastPlayedItem = this.getLastVideoItem();
    await this.updateListItemStyle(li, result, lastPlayedItem);
    this.showCheckButton(false);
  }

  // 显示播放列表页面
  async displayPlaylistPage(page, transaction) {
    playlistItems.innerHTML = '';
    /** @type {Array<{ title: string, url: string, group: string }>} **/
    const itemsToDisplay = filteredPlaylistData || [];
    const startIndex = (page - 1) * VARS.ITEMS_PER_PAGE;
    const endIndex = startIndex + VARS.ITEMS_PER_PAGE;
    const pageItems = itemsToDisplay.slice(startIndex, endIndex);
    const lastPlayedItem = this.getLastVideoItem();

    listCheckButton.disabled = true;
    // Loop list items
    pageItems.forEach(async (item, index) => {
      /** @type {HTMLLIElement} **/
      const li = document.createElement('li');
      /** @type {HTMLDivElement} **/
      const label = document.createElement('label');
      label.className = 'label';
      /** @type {HTMLElement} **/
      const text = document.createElement('i');
      text.textContent = item.group === this.currentCategory ? item.title : `[${item.group}] ${item.title}`;
      label.append(text);

      if(item.url.startsWith(UNSAFE_HTTP) && CONSTS.IS_NATIVE === false) {
        li.dataset['http'] = true;
        li.classList.add('http');
        li.classList.add('broken');
      }

      li.dataset['id'] = item.id;
      li.dataset['url'] = item.url;
      li.dataset['group'] = item.group;
      li.dataset['duration'] = '';
      li.title = item.title;

      li.onclick = (evt) => {
        evt.preventDefault();
        const { currentTarget } = evt;
        const frame = currentTarget.dataset['frame'] ? currentTarget.dataset['frame'] : CONSTS.POSTER;
        const isOK = currentTarget.classList.contains('broken') === false;
        const isFresh = currentTarget.classList.length === 0 || currentTarget.classList.contains('broken') || currentTarget.classList.contains('timeout');
        if(isFresh) {
          this.refreshVideoPlayability(currentTarget);
        }
        else if((videoPlayer.poster === frame || frame === CONSTS.POSTER) && isOK && !this.isPlaying() && isFresh === false) {
          this.playNow(currentTarget, item);
        }
        else {
          this.previewNow(currentTarget, item, frame);
        }
      };
      li.append(label);
      playlistItems.appendChild(li);
    });

    // Update styles
    for (const li of playlistItems.childNodes) {
      const id = li.dataset['id'];
      /** @type {{ data: { result: { status: number, duration: number, frame: string, latency: number, timeout: boolean } }, error: Error }} */
      const { data: playCache, error } = await database.readData(id, STA_STORE);
      if(error) {
        printLog('displayPlaylistPage.error', error.message);
        return;
      }
      if (playCache) {
        await this.updateListItemStyle(li, playCache.result, lastPlayedItem);
      }
      else if (VARS.IS_AUTO_CHECK && transaction === VARS.TRANSACTION) {
        await this.refreshVideoPlayability(li);
      }
    }

    this.showCheckButton(false);
    listCheckButton.disabled = topButtons.classList.contains('channel');
  }

  // 初始化播放列表
  async initializePlaylist() {
    filteredPlaylistData = this.getSelectedChannel().filter(x => VARS.DISLIKES.includes(x.id) === false);
    this.displayPlaylistPage(VARS.PLAYLIST_PAGE, VARS.TRANSACTION).catch(error => {
      printLog('initializePlaylist.displayPlaylistPage.error', error.message);
    });
    this.updatePaginationControls();
  }

  // 显示播放列表内容
  showPlaylistContent() {
    printLog('showPlaylistContent');
    pageBody.classList.remove('settings');
    this.displayPlayerControls();
  }

  async processM3uData(type, data, fromCache = false, isBooting = false) {
    await this.initPlayData(type, data);
    await this.initializeCategories(isBooting);
    this.initializePlaylist();

    this.showPlaylistContent();
    this.showErrorMessage();
  }

  // 更新分页控件
  updatePaginationControls() {
    const itemsToDisplay = filteredPlaylistData || [];
    const totalPages = Math.ceil(itemsToDisplay.length / VARS.ITEMS_PER_PAGE);
    const hasData = itemsToDisplay.length > 0;
    pageControl.max = totalPages;

    if(hasData) {
      pageInfo.innerHTML = `第 <span id="pageCurrent">${VARS.PLAYLIST_PAGE}</span> / ${totalPages} 页`;
      pageControl.min = 1;
    }
    else {
      pageInfo.textContent = '';
      pageControl.min = 0;
    }
    pageControl.value = VARS.PLAYLIST_PAGE;
    prevButton.disabled = (VARS.PLAYLIST_PAGE === 1 || hasData === false);
    nextButton.disabled = (VARS.PLAYLIST_PAGE === totalPages || hasData === false);
  }

  gotoPage(p) {
    VARS.PLAYLIST_PAGE = p;
    storage.saveInteger('playlist-page', p);
    this.displayPlaylistPage(VARS.PLAYLIST_PAGE, VARS.TRANSACTION = crypto.randomUUID()).catch(error => {
      printLog('gotoPage.error', error.message);
    });
    this.updatePaginationControls();
  }
  /**
   * List the store
   * @param {string} source The source to list
   */
  async listStore(source) {
    printLog('listStore');
    settingsButton.disabled = true;
    const cachedM3uSource = SOURCES.URL;
    const cachedM3uUrl = this.getPlayListUrl();

    m3uList.innerHTML = '';

    /** @type {{ data: Array<{ key: string, id: string, source: string }> }} **/
    const { data: list } = await database.listData(M3U_STORE);
    for(const m3uItem of list) {
      const url = database.decodeString(m3uItem.id);
      const isCurrent = cachedM3uUrl.includes(url);

      const divItem = document.createElement('div');
      const aItem = document.createElement('a');

      aItem.className = 'load';
      aItem.dataset['id'] = m3uItem.id;
      aItem.onclick = async (evt) => {
        /** @type {HTMLAnchorElement} **/
        const element = evt.target;
        /** @type {{ data: { id: string, m3u: string, source: string, type: string, time: number }, error: Error }} */
        const { data, error } = await database.readData(element.dataset['id']);
        if(error) {
          printLog('listStore.error', error.message);
          return;
        }
        if(element.textContent === cachedM3uUrl) {
          return;
        }
        if(data.source === SOURCES.URL) {
          this.setUrlInput(database.decodeString(m3uItem.id));
        }
        this.gotoPage(1);
        this.saveCategoryToCache(CONSTS.CHANNELS.ALL);
        this.loadCurrentChannel();
        await this.processM3uData(data.type || TYPES.M3U, data);
      };
      divItem.title = this.timeAgo(m3uItem.time);
      divItem.append(aItem);

      if(isCurrent) {
        aItem.innerHTML = '<strong>['.concat(this.getChannel(CONSTS.CHANNELS.RAW).length).concat(']</strong>&nbsp;').concat(url);
        divItem.classList.add('active');
        const rItem = document.createElement('a');
        rItem.innerText = '刷';
        rItem.className = 'refresh';
        rItem.dataset['id'] = m3uItem.id;
        rItem.onclick = async (evt) => {
          evt.preventDefault();
          const element = evt.target;
          if(element.classList.contains('disabled')) { return; }

          this.loadM3uUrl({ m3uUrl: url, fromCache: false, isBooting: false, onStart: () => {
            element.classList.add('disabled');
          }, onSuccess: async (type, data, cached, isBooting) => {
            await this.listStore('fetch');
          }, onCompleted: () => {
            element.classList.remove('disabled');
          } });
        };

        divItem.append(rItem);
      }
      else {
        aItem.textContent = url;
        const dItem = document.createElement('a');
        dItem.innerText = '删';
        dItem.className = 'delete';
        dItem.dataset['id'] = m3uItem.id;
        dItem.onclick = async (evt) => {
          evt.preventDefault();
          /** @type {HTMLAnchorElement} **/
          const deleteButton = evt.target;
          if(deleteButton.classList.contains('ready')) {
            await database.deleteData(evt.target.dataset['id']);
            this.listStore('click');
          }
          else {
            deleteButton.classList.add('ready');
          }
        };
        divItem.append(dItem);
      }
      m3uList.append(divItem);
    }
    settingsButton.disabled = false;
  }
  /**
   * Save the channel to cache
   * @param {string} channel Category
   */
  saveCategoryToCache(channel) {
    this.currentCategory = channel;
    storage.saveString('selected-channel', channel);
  }
  /**
   * Load the current channel
   * @param {boolean} isBooting Is booting
   * @returns {string} Returns the current channel
   */
  loadCurrentChannel(isBooting = false) {
    if(isBooting) {
      this.currentCategory = CONSTS.CHANNELS.ALL;
      let channel = storage.getString('selected-channel');
      if(channel && channel !== this.currentCategory) {
        /** @type {Array<string>} */
        const channels = Object.keys(this.channels);
        if(channels.includes(channel) === false) {
          channel = this.currentCategory;
        }
        this.saveCategoryToCache(channel);
      }
    }
    channelButton.textContent = topButtons.classList.contains('channel') ? '返回' : this.currentCategory;
    return this.currentCategory;
  }

  switchChannel() {
    // Channel
    if(channelList.classList.contains('hidden')) {
      channelList.classList.remove('hidden');
      playlistItems.classList.add('hidden');
      searchInput.classList.add('hidden');
      pageControls.classList.add('hidden');
      topButtons.classList.add('channel');
      closeButton.innerHTML = CONSTS.ICON_BACK;
    }
    // Playlist
    else {
      channelList.classList.add('hidden');
      playlistItems.classList.remove('hidden');
      searchInput.classList.remove('hidden');
      pageControls.classList.remove('hidden');
      topButtons.classList.remove('channel');
      closeButton.innerHTML = CONSTS.ICON_CLOSE;
    }
    this.loadCurrentChannel();
  }

  /**
   * @param {boolean} isBooting - Whether or not the app is booting
   */
  async initializeCategories(isBooting = false) {
    await this.fetchFavorites();
    await this.fetchDislikes();

    channelList.innerHTML = '';
    const selectedChannel = this.loadCurrentChannel(isBooting);

    for (let category in this.getChannels()) {
      if(category === CONSTS.CHANNELS.RAW){
        continue;
      }
      /** @type {HTMLLIElement} **/
      const li = document.createElement('li');
      const size = this.getChannel(category).length;
      li.dataset['channel'] = category;
      li.dataset['duration'] = size;
      /** @type {HTMLDivElement} **/
      const label = document.createElement('label');
      label.className = 'label';
      /** @type {HTMLElement} **/
      const text = document.createElement('i');
      text.textContent = category;
      label.append(text);
      li.append(label);
      if(size === 0) {
        li.classList.add('bad');
        li.classList.add('broken');
      }
      else {
        li.onclick = async (evt) => {
          evt.preventDefault();
          const { currentTarget } = evt;
          if(currentTarget.classList.contains('selected') || li.dataset['duration'] === '0') {
            return;
          }
          /** @type {{ channel: string }} **/
          const { channel = CONSTS.CHANNELS.ALL } = currentTarget.dataset;
          this.resetListStyle('selected', channelList);
          li.classList.add('selected');
          this.saveCategoryToCache(channel);
          // 重置搜索
          searchInput.value = '';
          // 更新当前类别的数据
          if(this.currentCategory === CONSTS.CHANNELS.FAVORITE) {
            filteredPlaylistData = await this.fetchFavorites();
          }
          else {
            filteredPlaylistData = this.getChannel(this.currentCategory === CONSTS.CHANNELS.ALL ? CONSTS.CHANNELS.RAW : this.currentCategory);
          }
          this.gotoPage(1);
          this.switchChannel();
        };
      }

      if(selectedChannel === category) {
        li.classList.add('selected');
      }
      channelList.appendChild(li);
    }
  }
  /**
   * @param {string} url URL
   */
  processUrl(url) {
    if(url.includes('#')) {
      return url.substring(0, url.indexOf('#'));
    }
    return url;
  }
  /**
   * 处理 M3U 文件单行
   * @param {string} line Line
   */
  processM3uLine(line) {
    if (line.startsWith('#EXTINF:')) {
      const infoLine = line.substring(8);
      const groupMatch = infoLine.match(/group-title="([^"]+)"/);
      VARS.CURRENT_GROUP = groupMatch ? groupMatch[1] : CONSTS.CHANNELS.ALL;
      VARS.CURRENT_TITLE = infoLine.split(',').pop().trim();
    } else if (line && !line.startsWith('#')) {
      const processedUrl = this.processUrl(line);
      VARS.CURRENT_ID = database.encodeString(processedUrl);
      if(VARS.DISLIKES.includes(VARS.CURRENT_ID)) {
        return;
      }
      if (!VARS.URLS.has(processedUrl)) {
        VARS.URLS.add(processedUrl);
        const item = { id: VARS.CURRENT_ID, title: VARS.CURRENT_TITLE || processedUrl, url: processedUrl, group: VARS.CURRENT_GROUP };

        this.addChannel(CONSTS.CHANNELS.ALL, item);
        if (VARS.CURRENT_GROUP !== CONSTS.CHANNELS.ALL) {
          this.initChannel(VARS.CURRENT_GROUP);
          this.addChannel(VARS.CURRENT_GROUP, item);
        }
      }
    }
  }
  /**
   * 处理 TXT 文件单行
   * @param {string} line Text line
   */
  async processTxtLine(line) {
    if (line.endsWith('#genre#')) {
      const infoLine = line.replace(',#genre#', '');
      VARS.CURRENT_GROUP = infoLine ? infoLine : CONSTS.CHANNELS.ALL;
    } else if (line && !line.endsWith('#genre#')) {
      const lineArray = line.split(',');
      if(lineArray.length < 2) return;
      VARS.CURRENT_URL = this.processUrl(lineArray.pop().trim());
      VARS.CURRENT_ID = database.encodeString(VARS.CURRENT_URL);
      VARS.CURRENT_TITLE = lineArray.pop().trim();
      if(VARS.DISLIKES.includes(VARS.CURRENT_ID)) {
        return;
      }
      if (!VARS.URLS.has(VARS.CURRENT_URL)) {
        VARS.URLS.add(VARS.CURRENT_URL);
        const group = VARS.CURRENT_GROUP || CONSTS.CHANNELS.ALL;
        const item = { id: VARS.CURRENT_ID, title: VARS.CURRENT_TITLE, url: VARS.CURRENT_URL, group };

        this.addChannel(CONSTS.CHANNELS.ALL, item);
        if (group !== CONSTS.CHANNELS.ALL) {
          this.initChannel(group);
          this.addChannel(group, item);
        }
      }
    }
  }
  /**
   * Initialize the playlist data.
   * @param {string} type The type of data to load.
   * @param {{ m3u: string, time: string }} data The data to load.
   */
  async initPlayData(type, data) {
    // Data in channels
    this.setChannels({
      [CONSTS.CHANNELS.RAW]: [],
      [CONSTS.CHANNELS.ALL]: [],
      [CONSTS.CHANNELS.FAVORITE]: []
    });
    VARS.URLS.clear();

    await this.fetchDislikes();

    const lines = data.m3u.split('\n');

    for(const item of lines) {
      const line = item.trim();
      // [M3U] Start - Process data
      if(type === TYPES.M3U) {
        this.processM3uLine(line);
      }
      else if (type === TYPES.TXT) {
        this.processTxtLine(line);
      }
      // [M3U] End - Process data
    }
    this.setChannel(CONSTS.CHANNELS.RAW, [...this.getChannel(CONSTS.CHANNELS.ALL)]);
  }
  /**
   * 设置URL输入框
   * @param {string} url URL
   * @param {string} label Label
   */
  setUrlInput(url, label = CONSTS.ICON_UPDATE_FROM_URL) {
    m3uUrlInput.value = url;
    loadM3uButton.innerHTML = label;
    storage.saveString('playlist-url', url);
  }

  async loadM3uFile(fromCache = false, isBooting = false) {
    /** @type {string} **/
    const m3uUrl = m3uUrlInput.value.trim();
    this.loadM3uUrl({ m3uUrl, fromCache, isBooting, onSuccess: async (type, data, cached, isBooting) => {
      await this.processM3uData(type, data, cached, false, isBooting);
      await this.listStore('fetch');
      this.gotoPage(1);
    } });
  }
  /**
   * Show m3u input box
   */
  async showM3uInput() {
    if(pageBody.classList.contains('settings')) {
      this.showPlaylistContent();
    }
    else {
      await this.listStore('showM3uInput');
      pageBody.classList.add('settings');
      this.displayPlayerControls(true, true);
    }

    const { totalSize, storeSize } = await database.totalSize();
    databaseSize.textContent = this.toSize(totalSize);
    databaseCategories.innerHTML = '';

    document.querySelectorAll('.settings-usage').forEach(item => item.classList.remove('hidden'));

    const labels = { [FAV_STORE]: '收藏', [M3U_STORE]: '频道', [STA_STORE]: '缓存' };
    for(const item in storeSize) {
      /** @type {HTMLButtonElement} */
      const button = document.createElement('button');
      button.textContent = `${labels[item]}: ${this.toSize(storeSize[item])}`;
      button.ondblclick = async () => {
        await database.purgeData(item);
        window.location.reload();
      };
      databaseCategories.append(button);
    }
  }

  loadVideoTimestamp() {
    VARS.VIDEO_PLAYED_DURATION = storage.getJSON('video-played-duration') || {};
  }

  setVideoTimestamp(url, timestamp, source) {
    VARS.VIDEO_PLAYED_DURATION[url] = timestamp;
    storage.set('video-played-duration', VARS.VIDEO_PLAYED_DURATION);
  }

  saveVideoTimestamp() {
    storage.saveJSON('video-played-duration', VARS.VIDEO_PLAYED_DURATION);
  }

  async loadLocalCache() {
    const playListUrl = storage.getString('playlist-url') || '';
    if (playListUrl) {
      this.setUrlInput(playListUrl);
      await this.loadM3uFile(true, true); // 添加一个参数来表示这是从缓存加载
    }
    else {
      await this.showM3uInput();
    }
    this.loadVideoTimestamp();

    VARS.PLAYLIST_PAGE = storage.getInteger('playlist-page', 1);

    VARS.HAS_THUMBNAIL = storage.getBoolean('has-thumbnail');
    storeFrameCheckbox.checked = VARS.HAS_THUMBNAIL;
    screenshotTime.disabled = !storeFrameCheckbox.checked;

    VARS.IS_AUTO_CHECK = storage.getBoolean('is-auto-check');
    autoCheckCheckbox.checked = VARS.IS_AUTO_CHECK;

    VARS.IS_LOGGING_ENABLED = storage.getBoolean('is-logging-enabled');
    enableLoggingCheckbox.checked = VARS.IS_LOGGING_ENABLED;
    if(VARS.IS_LOGGING_ENABLED) { logContainer.classList.remove('hidden'); }

    VARS.IS_CHECKING_BROKEN_ONLY = storage.getBoolean('is-checking-broken-only');
    onlyCheckBrokenCheckbox.checked = VARS.IS_CHECKING_BROKEN_ONLY;

    VARS.PING_TIMEOUT = storage.getInteger('ping-timeout', 10000);
    checkTimeout.value = Math.round(VARS.PING_TIMEOUT / 1000);
    checkTimeoutDisplay.textContent = checkTimeout.value;

    VARS.THUMBNAIL_TIMEOUT = storage.getInteger('thumbnail-timeout', 3);
    screenshotTime.value = VARS.THUMBNAIL_TIMEOUT;
    screenshotTimeDisplay.textContent = screenshotTime.value;

    VARS.IS_MUTED = storage.getBoolean('is-muted', true);
    muteWhenPlayCheckbox.checked = VARS.IS_MUTED;
  }
  /**
   * 将字节转换为合适的单位大小
   * @param {number} val 字节数
   * @returns {string} 转换后的大小字符串
   */
  toSize(val) {
    // 类型检查
    if (typeof val !== 'number' || val < 0) {
      return val;
    }
    // 转换逻辑
    if (val < CONSTS.KILOBYTE) {
      return `${val} B`;
    } else if (val < CONSTS.MEGABYTE) {
      return (val / CONSTS.KILOBYTE).toFixed(2) + ' KB';
    } else {
      return (val / CONSTS.MEGABYTE).toFixed(2) + ' MB';
    }
  }

  onStopped() {
    this.showPlayButton();
    this.resetTitle();
    this.saveVideoTimestamp();
    this.displayPlayerControls(false, true);
  }

  saveLastPlayedVideo(playingItem) {
    storage.saveJSON('last-played-video', playingItem);
  }

  seekVideo(time) {
    videoPlayer.currentTime += time;
    this.handleNormalPlay();
  }

  detectM3uUrl() {
    loadM3uButton.disabled = !m3uUrlInput.checkValidity();
    const cachedM3uUrl = this.getPlayListUrl();
    if(cachedM3uUrl === m3uUrlInput.value) {
      loadM3uButton.innerHTML = CONSTS.ICON_UPDATE_FROM_URL;
    }
    else {
      loadM3uButton.innerHTML = CONSTS.ICON_READ_FROM_URL;
    }
  }

  resetControlButtons(isPlaying, isReset = false) {
    if(isPlaying) {
      rewindButton.disabled = forwardButton.disabled = false;
      progressControl.classList.remove('hidden');
    }
    else {
      rewindButton.disabled = forwardButton.disabled = true;
      progressControl.classList.add('hidden');
    }
    reCaptureButton.disabled = isReset;
    playVideoButton.disabled = dislikeButton.disabled = favoriteButton.disabled = isReset || false;
    if(isReset) {
      dislikeButton.classList.remove('remove');
      dislikeButton.innerHTML = CONSTS.ICON_DISLIKE;
      favoriteButton.classList.remove('remove');
      favoriteButton.innerHTML = CONSTS.ICON_FAVORITE;
      reCaptureButton.classList.remove('recapture');
    }
  }

  async releaseWakeLock() {
    try {
      await this.wakeLockSentinel?.release();
    }
    catch(error) {
      console.warn(error);
    }
    finally {
      this.wakeLockSentinel = null;
    }
  }

  async requestWakeLock() {
    await this.releaseWakeLock();

    try {
      this.wakeLockSentinel = await navigator.wakeLock.request('screen');
    }
    catch(error) {
      console.warn(error);
    }
  }

  onPlaying() {
    playVideoButton.innerHTML = CONSTS.ICON_STOP;
    pauseVideoButton.innerHTML = CONSTS.ICON_PAUSE;
    pipButton.disabled = fullscreenButton.disabled = false;
    playVideoButton.className = 'played';
    this.showErrorMessage();
    videoPlayer.className = '';
    this.resetControlButtons(true);
    clearTimeout(VARS.CONTROL_TIMER);
    VARS.CONTROL_TIMER = setTimeout(this.displayPlayerControls, CONSTS.CONTROL_DISPLAY_TIMEOUT);
    this.requestWakeLock();
  }

  setFullscreenData(state) {
    videoContainer.dataset['fullscreen'] = !!state;
  }
  /**
   * Reset poster
   * @param {Event} evt Node
   * @returns {boolean} Returns boolean value if the event was handled
   */
  resetPoster(evt) {
    /** @type {HTMLElement} **/
    const node = evt.target;
    const nodeName = node.tagName.toLowerCase();
    switch(nodeName) {
      case 'input':
      case 'button':
      case 'svg':
        return false;
      case 'video':
        node.poster = CONSTS.POSTER;
        // if(this.isPlaying()) videoPlayer.requestFullscreen();
        // return;
      default:
        {
          evt.preventDefault();
          evt.stopPropagation();
        }
    }

    if(node.poster !== CONSTS.POSTER) {
      storage.delete('last-played-video');
      this.stopVideo(true, true, node.poster);
      appShell.displaySideMenu(false);
      return true;
    }
    return false;
  }

  gotoNextPage() {
    const itemsToDisplay = filteredPlaylistData || [];
    if (VARS.PLAYLIST_PAGE < Math.ceil(itemsToDisplay.length / VARS.ITEMS_PER_PAGE)) {
      VARS.PLAYLIST_PAGE++;
      this.gotoPage(VARS.PLAYLIST_PAGE);
    }
  }

  gotoPrevPage() {
    if (VARS.PLAYLIST_PAGE > 1) {
      VARS.PLAYLIST_PAGE--;
      this.gotoPage(VARS.PLAYLIST_PAGE);
    }
  }
  /**
   * @param {string} id ID
   * @param {boolean} payload Data
   * @param {{ m3uUrl: string, fromCache: boolean, isBooting: boolean, onStart: () => void, onSuccess: (type: string, data: { id: string, m3u: string, source: string, type: string, time: number }, cached: boolean, isBooting: boolean) => Promise<void>, onCompleted: () => void }} options 参数对象
   */
  async fetchM3u(id, payload, options) {
    printLog('fetchM3u');
    options.onStart();
    m3uUrlInput.disabled = loadM3uButton.disabled = true;
    const { m3uUrl, fromCache = false, isBooting = false } = options;
    const type = (m3uUrl.endsWith('m3u') || m3uUrl.endsWith('m3u8')) ? TYPES.M3U : m3uUrl.endsWith('txt') ? TYPES.TXT : '';

    const safeUrl = (m3uUrl.startsWith(UNSAFE_HTTP) && CONSTS.IS_NATIVE === false) ? new URL(`${window.location.origin}/api/fetch?url=${encodeURIComponent(m3uUrl)}`).href : m3uUrl;
    try {
      const data = await this.makeRequest(safeUrl, { cache: 'no-store' });
      if (data) {
        const time = new Date().getTime();
        const x = { id, m3u: data, source: SOURCES.URL, type, time };
        if (payload) {
          await database.updateData(x);
        } else {
          await database.addData(x);
        }
        await options.onSuccess(type, x, fromCache, isBooting);
      }
      else {
        this.showErrorMessage('加载 M3U 文件时出错，请检查 URL 是否正确。');
        this.showM3uInput();
      }
    } catch (error) {
      this.showErrorMessage(`加载 M3U 文件时出错，请检查 URL 是否正确。${error.message}`);
      this.showM3uInput();
    }
    finally {
      m3uUrlInput.disabled = loadM3uButton.disabled = false;
      options.onCompleted();
    }
  }
  /**
   * 加载 M3U 文件
   * @param {{ m3uUrl: string, fromCache: boolean, isBooting: boolean, onStart: () => void, onSuccess: (type: string, data: { id: string, m3u: string, source: string, type: string, time: number }, cached: boolean, isBooting: boolean) => Promise<void>, onCompleted: () => void }} options 参数对象
   */
  async loadM3uUrl(opts) {
    /** @type {{ m3uUrl: string, fromCache: boolean, isBooting: boolean, onStart: () => void, onSuccess: (type: string, data: { id: string, m3u: string, source: string, type: string, time: number }, cached: boolean, isBooting: boolean) => Promise<void>, onCompleted: () => void }} **/
    const options = Object.assign({}, {
      m3uUrl: '', fromCache: false, isBooting: false,
      onStart: () => { },
      /**
       * @param {string} type Type
       * @param {{ id: string, m3u: string, source: string, type: string, time: number }} data Data
       * @param {boolean} cached Cached
       * @param {boolean} isBooting Is booting
       */
      onSuccess: (type, data, cached, isBooting) => { },
      onCompleted: () => { }
    }, opts);
    const { m3uUrl, fromCache = false, isBooting = false } = options;
    const type = (m3uUrl.endsWith('m3u') || m3uUrl.endsWith('m3u8')) ? TYPES.M3U : m3uUrl.endsWith('txt') ? TYPES.TXT : '';

    if (type && m3uUrlInput.checkValidity()) {
      const id = database.encodeString(m3uUrl);
      const { data: payload, error } = await database.readData(id);
      if(error) {
        this.showErrorMessage('请输入有效的 M3U 文件 URL。');
        printLog('loadM3uFile.fetchDataAndProcess.error', error.message);
        return;
      }
      if (payload && payload.m3u && fromCache) {
        await this.processM3uData(type, payload, true, isBooting, false);
      } else {
        this.fetchM3u(id, payload, options);
      }
    }
    else {
      this.showErrorMessage('请输入有效的 M3U 文件 URL。');
    }
  }
  // 执行搜索
  performSearch() {
    printLog('performSearch');
    const searchTerm = searchInput.value.toLowerCase();
    if ([CONSTS.CHANNELS.RAW, CONSTS.CHANNELS.ALL].includes(this.currentCategory)) {
      filteredPlaylistData = this.getChannel(CONSTS.CHANNELS.RAW).filter(item => 
        item.title.toLowerCase().includes(searchTerm)
      );
    }
    else {
      filteredPlaylistData = this.getSelectedChannel().filter(item => 
        item.title.toLowerCase().includes(searchTerm)
      );
    }
    this.gotoPage(1);
  }
  // 刷新当前页面
  async refreshCurrentPage(transaction, isChecking = false) {
    if(isChecking) {
      //
    }
    else {
      this.showCheckButton(true);
      const lastPlayedItem = this.getLastVideoItem();

      const items = playlistItems.childNodes;
      for (let i = 0; i < items.length; i++) {
        /** @type {HTMLLIElement} */
        const li = items[i];
        if(li.classList.contains('frame') && VARS.IS_CHECKING_BROKEN_ONLY) {
          continue;
        }
        li.className = '';
      }

      for (let i = 0; i < items.length; i++) {
        /** @type {HTMLLIElement} */
        const li = items[i];
        if(li.classList.contains('frame') && VARS.IS_CHECKING_BROKEN_ONLY) {
          continue;
        }
        li.className = 'checking';
        const itemUrl = li.dataset['url'];

        if (itemUrl) {
          if(transaction === VARS.TRANSACTION) {
            const result = await this.checkVideoPlayability(itemUrl);
            const id = li.dataset['id'];
            await database.updateData({ id, result }, STA_STORE);
            await this.updateListItemStyle(li, result, lastPlayedItem);
          }
          else {
            li.className = '';
          }
        }
        else {
          li.classList.add('broken');
        }
      }
    }
    this.showCheckButton(false);
  }

  // 加载缓存的数据
  async startup() {
    await this.loadLocalCache();
    this.gotoPage(VARS.PLAYLIST_PAGE);
    this.playLastVideo(false);

    await this.listStore('startup');

    this.initUI('startup');

    this.generateBlankFrame();
    this.resetTitle();

    // const data = await database.queryData(STA_STORE, 'staStatusOK', 1);
    // console.log(data);
  }

  displaySideMenu(show = false) {
    // Hide playlist
    if(show) {
      this.showPlaylistContent();
      pageBody.classList.add('menu');
    }
    // Show playlist
    else {
      pageBody.classList.remove('menu');
      this.displayPlayerControls();
    }
    storage.saveString('is-playlist-visible', show ? 'true' : 'false');
  }

  async addFavorite(id, url, title, group, code = CONSTS.CODES.LIKE) {
    await database.updateData({ id, url, title, group, code }, FAV_STORE);
    this.refreshFavoriteButton(code);
    this.refreshDislikeButton(code);
    await this.initializeCategories();
    this.initializePlaylist();
  }

  async deleteFavorite(id) {
    const { data, error } = await database.deleteData(id, FAV_STORE);
    if(error) {
      printLog('deleteFavorite.error', error);
    }
    this.refreshFavoriteButton(CONSTS.CODES.NONE);
    this.refreshDislikeButton(CONSTS.CODES.NONE);
    await this.initializeCategories();
    this.initializePlaylist();
  }

  showErrorMessage(message = '') {
    if(message.length > 0) {
      console.warn(' >', message);
    }
  }
  getDominantColor(imageData) {
    if(imageData) {
      const pixelCount = imageData.data.length / 4;
      const colorCount = new Map();
      const alphaThreshold = 128; // 可根据需求调整透明度阈值

      for (let i = 0; i < pixelCount; i++) {
        const offset = i * 4;
        const r = imageData.data[offset];
        const g = imageData.data[offset + 1];
        const b = imageData.data[offset + 2];
        const a = imageData.data[offset + 3];

        if (a >= alphaThreshold) {
          const color = (r << 16) | (g << 8) | b;
          const count = colorCount.get(color) || 0;
          colorCount.set(color, count + 1);
        }
      }

      let maxCount = 0;
      let dominantColor = null;

      for (const [color, count] of colorCount.entries()) {
        if (count > maxCount) {
          maxCount = count;
          dominantColor = color;
        }
      }
      if(dominantColor) {
        const r = (dominantColor >> 16) & 0xFF;
        const g = (dominantColor >> 8) & 0xFF;
        const b = dominantColor & 0xFF;
        return `rgb(${r}, ${g}, ${b})`;
      }
    }
    return '';
  }
  updateBackground() {
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = videoPlayer.videoWidth;
      canvas.height = videoPlayer.videoHeight;

      ctx.drawImage(videoPlayer.poster, 0, 0, canvas.width, canvas.height);

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const dominantColor = this.getDominantColor(imageData);

      pageBody.style.background = `
        radial-gradient(circle, ${dominantColor} 0%, #000 100%)
      `;
      // const imageUrl = canvas.toDataURL('image/png');
      // document.body.style.backgroundImage = `url(${imageUrl})`;
    }
    catch(error) {}
  }

  togglePictureInPicture() {
    if (document.pictureInPictureElement) {
      document.exitPictureInPicture();
    }
    else {
      videoPlayer.requestPictureInPicture();
    }
  }

  handleQuickPlay () {
    VARS.QUICK_PLAY_TIMER = setTimeout(() => {
      videoPlayer.playbackRate = CONSTS.PLAYER.PLAYBACK_RATE_FAST;
    }, CONSTS.PLAYER.PRESS_TOLERANCE_TIME);
  }

  handleNormalPlay () {
    clearTimeout(VARS.QUICK_PLAY_TIMER);
    videoPlayer.playbackRate = CONSTS.PLAYER.PLAYBACK_RATE_NORMAL;
  }

} // End of class

class WebShell extends AppShell {
  initUI() {
    super.initUI();
    pinButton.remove();
  }
}

class ElectronShell extends AppShell {
  SITE_TITLE = 'Hunhe IPTV | v1.0';
  async makeRequest(url, opts = {}) {
    const options = { referrerPolicy: 'no-referrer', ...opts };
    return new Promise((resolve, reject) => {
      const response = window['electronAPI'].makeRequest(url, options);
      if(response.error) {
        reject(response.error);
      }
      else if(response.data) {
        resolve(response.data);
      }
      else {
        reject({});
      }
    });
  }

  changeTitle(title) {
    window['electronAPI'].changeTitle(title);
  }
  putOnTop(isOnTop) {
    window['electronAPI'].putOnTop(isOnTop);
  }
}

/** @type {AppShell} **/
const appShell = CONSTS.IS_NATIVE ? new ElectronShell() : new WebShell();

/**
 * @param {Array<any>} args Arguments
 */
function printLog(...args) {
  if(VARS.IS_LOGGING_ENABLED) {
    debugLogs.innerHTML = `$ ${args.join(' ')}\n`.concat(debugLogs.innerHTML);
    logClearButton.classList.remove('hidden');
  }
}

favoriteButton.addEventListener('dblclick', async (evt) => {
  evt.stopPropagation();
  const id = favoriteButton.dataset['id'];
  const url = favoriteButton.dataset['url'];
  const group = favoriteButton.dataset['group'];
  const title = favoriteButton.dataset['title'];
  const isAddingData = favoriteButton.dataset['action'] === 'add';
  const isDeletingData = favoriteButton.dataset['action'] === 'remove';
  console.log('isAddingData->', isAddingData);
  console.log('isDeletingData->', isDeletingData);
  if(isAddingData) {
    appShell.addFavorite(id, url, title, group, CONSTS.CODES.LIKE);
  }
  else if(isDeletingData) {
    appShell.deleteFavorite(id);
  }
});

dislikeButton.addEventListener('dblclick', async (evt) => {
  evt.stopPropagation();
  const id = dislikeButton.dataset['id'];
  const url = dislikeButton.dataset['url'];
  const group = dislikeButton.dataset['group'];
  const title = dislikeButton.dataset['title'];
  const isAddingData = dislikeButton.dataset['action'] === 'add';
  const isDeletingData = dislikeButton.dataset['action'] === 'remove';
  console.log('isAddingData->', isAddingData);
  console.log('isDeletingData->', isDeletingData);
  if(isAddingData) {
    appShell.addFavorite(id, url, title, group, CONSTS.CODES.DISLIKE);
  }
  else if(isDeletingData) {
    appShell.deleteFavorite(id);
  }
});
// 
reCaptureButton.addEventListener('pointerdown', async (evt) => {
  evt.stopPropagation();
  const url = reCaptureButton.dataset['url'];
  const group = favoriteButton.dataset['group'];
  const title = favoriteButton.dataset['title'];
  const id = favoriteButton.dataset['id'];

  reCaptureButton.disabled = true;
  reCaptureButton.classList.remove('recapture');
  const result = await appShell.checkVideoPlayability(url, true);
  await database.updateData({ id, result }, STA_STORE);
  const lastPlayedItem = appShell.getLastVideoItem();

  for(const node of playlistItems.childNodes) {
    if(node.dataset['url'] === url) {
      appShell.updateListItemStyle(node, result, lastPlayedItem);
      appShell.changePoster(node.dataset['frame']);
      break; 
    }
  }
  reCaptureButton.disabled = false;
  reCaptureButton.classList.add('recapture');
});

pinButton.addEventListener('pointerdown', async (evt) => {
  evt.stopPropagation();
  VARS.ALWAYS_ON_TOP = !VARS.ALWAYS_ON_TOP;
  appShell.putOnTop(VARS.ALWAYS_ON_TOP);
  if(VARS.ALWAYS_ON_TOP) {
    pinButton.innerHTML = CONSTS.ICON_PINNED;
    pinButton.classList.add('pinned');
  }
  else {
    pinButton.innerHTML = CONSTS.ICON_UNPINNED;
    pinButton.classList.remove('pinned');
  }
});

loadM3uButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.loadM3uFile(false);
});

closeM3uButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.showM3uInput();
});

settingsButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.showM3uInput();
  appShell.muteOrUnmuteVideo(true);
});

prevButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.gotoPrevPage();
});
prevButton.addEventListener('dblclick', (evt) => {
  evt.preventDefault();
  appShell.gotoPrevPage();
});

nextButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.gotoNextPage();
});
nextButton.addEventListener('dblclick', (evt) => {
  evt.preventDefault();
  appShell.gotoNextPage();
});

pageControl.addEventListener('change', (evt) => {
  appShell.gotoPage(parseInt(evt.target.value));
  document.getElementById('pageCurrent').textContent = VARS.PLAYLIST_PAGE;
});
pageControl.addEventListener('input', (evt) => {
  document.getElementById('pageCurrent').textContent = parseInt(evt.target.value);
});
searchFormButton.addEventListener('click', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  searchContainer.classList.toggle('hidden');
  searchInput.focus();
});
searchContainer.addEventListener('submit', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  if(searchContainer.checkValidity())
    appShell.performSearch();
});

searchInput.addEventListener('blur', (evt) => {
  if(evt.target.value === '') {
    searchFormButton.dispatchEvent(new Event('click'));
  }
});

searchInput.addEventListener('keyup', (evt) => {
  if(evt.target.value === '') {
    clearButton.classList.add('hidden');
  }
  else {
    clearButton.classList.remove('hidden');
  }
});

searchInput.addEventListener('input', function() {
  if (this.value === '') {
    filteredPlaylistData = appShell.getChannel(appShell.currentCategory === CONSTS.CHANNELS.ALL ? CONSTS.CHANNELS.RAW : appShell.currentCategory);
    appShell.gotoPage(1);
  }
  searchInput.dispatchEvent(new Event('keyup'));
});

m3uUrlInput.addEventListener('blur', (evt) => {
  appShell.detectM3uUrl();
});
m3uUrlInput.addEventListener('keyup', (evt) => {
  appShell.detectM3uUrl();
});
m3uUrlInput.addEventListener('input', (evt) => {
  appShell.detectM3uUrl();
});

clearButton.addEventListener('click', (evt) => {
  evt.stopPropagation();
  evt.preventDefault();
  searchInput.value = '';
  appShell.performSearch();
  searchInput.dispatchEvent(new Event('keyup'));
  searchInput.focus();
});

closeButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  if(topButtons.classList.contains('channel')) {
    channelButton.dispatchEvent(new Event('pointerdown'));
  }
  else {
    playListButton.dispatchEvent(new Event('pointerdown'));
  }
});
m3uInputContainer.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  if(evt.target.id === 'm3uInputContainer') {
    closeM3uButton.dispatchEvent(new Event('pointerdown'));
  }
});

m3uInputContainer.addEventListener('dblclick', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
});

listCheckButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.refreshCurrentPage(VARS.TRANSACTION = crypto.randomUUID(), listCheckButton.classList.contains('checking'));
});

videoPlayer.addEventListener('timeupdate', (evt) => {
  if(videoPlayer.src === stopURL) { return; }
  // appShell.updateBackground();
  const lastPlayedItem = appShell.getLastVideoItem();
  if(lastPlayedItem) {
    /** @type {HTMLVideoElement} **/
    const player = evt.target;
    progressControl.value = player.currentTime;
    if(player.currentTime > 0) appShell.setVideoTimestamp(lastPlayedItem.url, player.currentTime, 'timeupdate');
    if (progressControl.max === '0' && player.duration) {
      progressControl.max = player.duration;
      totalTimeDisplay.textContent = appShell.getMinutes(player.duration);
    }
    currentTimeDisplay.textContent = appShell.getMinutes(player.currentTime);
  }
});
videoPlayer.addEventListener('pause', (evt) => {
  printLog('videoPlayer.pause');
  appShell.onStopped();
});

videoPlayer.addEventListener('seeked', (evt) => {
  const lastPlayedItem = appShell.getLastVideoItem();
  if(lastPlayedItem) {
    appShell.setVideoTimestamp(lastPlayedItem.url, videoPlayer.currentTime, 'seeked');
  }
});
videoPlayer.addEventListener('canplay', (evt) => {
  printLog('videoPlayer.canplay');
});
videoPlayer.addEventListener('play', (evt) => {
  printLog('videoPlayer.play');
  appShell.onPlaying();
});
videoPlayer.addEventListener('loadeddata', (evt) => {
  printLog(`videoPlayer.loadeddata - ${videoPlayer.readyState}`);
  if(videoPlayer.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA)
    appShell.displayPlayerControls(true, true);
});
videoPlayer.addEventListener('playing', (evt) => {
  printLog(`videoPlayer.playing - ${videoPlayer.networkState}`);
});
videoPlayer.addEventListener('emptied', (evt) => {
  printLog('videoPlayer.emptied');
});
videoPlayer.addEventListener("stalled", (evt) => {
  /** @type {HTMLVideoElement} */
  const player = evt.target;
  printLog('videoPlayer.stalled', player.paused);
  if(player.paused) {
    appShell.onStopped();
  }
});

videoPlayer.addEventListener("suspend", (evt) => {
  printLog('videoPlayer.suspend');
});

videoPlayer.addEventListener('waiting', (evt) => {
  printLog('videoPlayer.waiting');
  playVideoButton.className = 'playing';
  playVideoButton.innerHTML = CONSTS.ICON_CANCEL;
  playVideoButton.disabled = false;
});
videoPlayer.addEventListener('canplaythrough', (evt) => {
  printLog('videoPlayer.canplaythrough');
  if(appShell.isPlaying())
    appShell.onPlaying();
});
videoPlayer.addEventListener('ended', (evt) => {
  printLog('videoPlayer.ended');
  appShell.onStopped(true);
});
videoPlayer.addEventListener('error', (evt) => {
  printLog('videoPlayer.error');
  if(videoPlayer.src === stopURL) {
    appShell.showPlayButton();
    return;
  }
  appShell.showErrorMessage('加载视频时出错，请尝试其他源或检查网络连接。');
});
['mouseover', 'touchstart', 'mousemove', 'mousedown'].forEach(eventType => {
  [videoPlayer, videoControls, videoContainer].forEach(element => {
    element.addEventListener(eventType, () => {
      clearTimeout(VARS.CONTROL_TIMER);
      appShell.displayPlayerControls(true, true);
    }, { passive: true });
  });
});
['mouseout', 'touchend', 'mouseleave', 'touchcancel'].forEach(eventType => {
  [videoPlayer, videoControls].forEach(element => {
    element.addEventListener(eventType, () => {
      clearTimeout(VARS.CONTROL_TIMER);
      VARS.CONTROL_TIMER = setTimeout(appShell.displayPlayerControls, CONSTS.CONTROL_DISPLAY_TIMEOUT);
    });
  });
});
[videoPlayer, videoControls, videoContainer].forEach(element => {
  element.addEventListener('touchcancel', () => {
    clearTimeout(VARS.CONTROL_TIMER);
    VARS.CONTROL_TIMER = setTimeout(appShell.displayPlayerControls, CONSTS.CONTROL_DISPLAY_TIMEOUT);
  });
});
videoPlayer.addEventListener('click', (evt) => {
  clearTimeout(VARS.CONTROL_TIMER);
  if(videoControls.classList.contains('transparent')) {
    appShell.displayPlayerControls(true, true);
  }
  else {
    appShell.displayPlayerControls();
  }
});

videoPlayer.addEventListener('dblclick', (evt) => {
  appShell.resetPoster(evt);
});
videoPlayer.addEventListener('volumechange', (evt) => {
  const isMuted = videoPlayer.muted || videoPlayer.volume === 0;
  speakerButton.innerHTML = isMuted ? CONSTS.ICON_SPEAKER_ON : CONSTS.ICON_SPEAKER_OFF;
});
progressControl.addEventListener('change', (evt) => {
  const value = evt.target.value;
  const currentTime = parseFloat(value);
  printLog('progressControl.change', currentTime);
});

progressControl.addEventListener('input', (evt) => {
  const value = evt.target.value;
  try {
    const currentTime = parseFloat(value);
    currentTimeDisplay.textContent = appShell.getMinutes(currentTime);
    if (!isNaN(currentTime) && !Number.isNaN(currentTime)) {
      videoPlayer.currentTime = currentTime;
    }
  } catch (error) {}
});

playVideoButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  if(appShell.isPlaying()) {
    appShell.stopVideo(false);
  }
  else {
    appShell.playLastVideo();
  }
});

pauseVideoButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  if(videoPlayer.paused) {
    videoPlayer.play().then(() => {
      
    }).catch(error => {
      
    });
  }
  else {
    videoPlayer.pause();
  }
});

speakerButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.muteOrUnmuteVideo(!videoPlayer.muted);
});
pipButton.addEventListener('click', (evt) => {
  evt.stopPropagation();
  appShell.togglePictureInPicture();
});
fullscreenButton.addEventListener('pointerdown', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();

  if (document.fullscreenElement === null && document.fullscreenEnabled) {
    // The document is not in fullscreen mode
    videoPlayer.requestFullscreen();
    appShell.setFullscreenData(true);
  } else {
    // The document is in fullscreen mode
    document.exitFullscreen();
    appShell.setFullscreenData(false);
  }
});

rewindButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.seekVideo(-30);
});

forwardButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.seekVideo(30);
});

playListButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.displaySideMenu(pageBody.classList.contains('menu') === false);
});

storeFrameCheckbox.addEventListener('change', (evt) => {
  VARS.HAS_THUMBNAIL = evt.target.checked;
  storage.saveBoolean('has-thumbnail', VARS.HAS_THUMBNAIL);
  screenshotTime.disabled = !evt.target.checked;
});
autoCheckCheckbox.addEventListener('change', (evt) => {
  VARS.IS_AUTO_CHECK = evt.target.checked;
  storage.saveBoolean('is-auto-check', VARS.IS_AUTO_CHECK);
});
checkTimeout.addEventListener('input', (evt) => {
  VARS.PING_TIMEOUT = parseInt(evt.target.value) * 1000;
  checkTimeoutDisplay.textContent = evt.target.value;
  storage.saveInteger('ping-timeout', VARS.PING_TIMEOUT);
});

screenshotTime.addEventListener('input', (evt) => {
  VARS.THUMBNAIL_TIMEOUT = parseInt(evt.target.value);
  screenshotTimeDisplay.textContent = evt.target.value;
  storage.saveInteger('thumbnail-timeout', VARS.THUMBNAIL_TIMEOUT);
});

onlyCheckBrokenCheckbox.addEventListener('change', (evt) => {
  VARS.IS_CHECKING_BROKEN_ONLY = evt.target.checked;
  storage.saveBoolean('is-checking-broken-only', VARS.IS_CHECKING_BROKEN_ONLY);
});

enableLoggingCheckbox.addEventListener('change', (evt) => {
  VARS.IS_LOGGING_ENABLED = evt.target.checked;
  storage.saveBoolean('is-logging-enabled', VARS.IS_LOGGING_ENABLED);
  if(VARS.IS_LOGGING_ENABLED) {
    logContainer.classList.remove('hidden');
  }
  else {
    logContainer.classList.add('hidden');
  }
});

muteWhenPlayCheckbox.addEventListener('change', (evt) => {
  VARS.IS_MUTED = evt.target.checked;
  storage.saveBoolean('is-muted', VARS.IS_MUTED);
});

logClearButton.addEventListener('click', (evt) => {
  logClearButton.classList.add('hidden');
  debugLogs.innerHTML = '> 日志';
});

channelButton.addEventListener('pointerdown', (evt) => {
  evt.stopPropagation();
  appShell.switchChannel();
});

videoContainer.addEventListener('touchstart', (evt) => appShell.handleQuickPlay());
videoContainer.addEventListener('touchend', (evt) => appShell.handleNormalPlay());
videoContainer.addEventListener('touchcancel', (evt) => appShell.handleNormalPlay());

videoContainer.addEventListener('mousedown', (evt) => appShell.handleQuickPlay());
videoContainer.addEventListener('mouseup', (evt) => appShell.handleNormalPlay());
videoContainer.addEventListener('mouseout', (evt) => appShell.handleNormalPlay());

videoPlayer.addEventListener('contextmenu', (evt) => evt.preventDefault());

document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape' || event.keyCode === 27) {
    event.preventDefault();
    if(VARS.IS_GLOBALLY_HIDDEN) {
      pageContainer.className = 'container';
    }
    else {
      pageContainer.className = 'hidden';
      appShell.muteOrUnmuteVideo(true);
      videoPlayer.pause();
    }
    VARS.IS_GLOBALLY_HIDDEN = !VARS.IS_GLOBALLY_HIDDEN;
  }
  else if(event.key === 'ArrowLeft' || event.keyCode === 37) {
    event.preventDefault();
    appShell.seekVideo(-30);
  }
  else if(event.key === 'ArrowRight' || event.keyCode === 39) {
    event.preventDefault();
    appShell.seekVideo(30);
  }
  else if (event.key === 'ArrowUp' || event.keyCode === 38) {
    event.preventDefault();
    appShell.seekVideo(60);
  }
  else if (event.key === 'ArrowDown' || event.keyCode === 40) {
    event.preventDefault();
    appShell.seekVideo(-60);
  }
});
document.addEventListener('dblclick', (evt) => {
  appShell.resetPoster(evt);
});
window.addEventListener('beforeunload', (evt) => {
  appShell.saveVideoTimestamp();
});

// 初始化
window.addEventListener('DOMContentLoaded', (evt) => {
  appShell.startup();
});

</script>
</body>
</html>
